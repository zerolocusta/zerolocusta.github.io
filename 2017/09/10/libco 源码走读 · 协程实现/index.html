<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Medium-Well</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="libco 源码走读 · 协程实现最近正在计划做一个c++上的Actor模型框架, 准备利用libco作为协程调度器, 需要对libco进行改造, 读起了libco源码 0. 源码蓝图0.1 功能假设读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设     * libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间">
<meta property="og:type" content="article">
<meta property="og:title" content="Medium-Well">
<meta property="og:url" content="https://zerolocusta.github.io/2017/09/10/libco 源码走读 · 协程实现/index.html">
<meta property="og:site_name" content="Medium-Well">
<meta property="og:description" content="libco 源码走读 · 协程实现最近正在计划做一个c++上的Actor模型框架, 准备利用libco作为协程调度器, 需要对libco进行改造, 读起了libco源码 0. 源码蓝图0.1 功能假设读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设     * libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%8811.56.26.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.56.12.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.54.09.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.52.19.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.25.52.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.37.52.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.05.19.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.17.00.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.23.57.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.24.06.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png">
<meta property="og:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14%201.png">
<meta property="og:updated_time" content="2017-09-15T08:17:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Medium-Well">
<meta name="twitter:description" content="libco 源码走读 · 协程实现最近正在计划做一个c++上的Actor模型框架, 准备利用libco作为协程调度器, 需要对libco进行改造, 读起了libco源码 0. 源码蓝图0.1 功能假设读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设     * libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间">
<meta name="twitter:image" content="https://zerolocusta.github.io/2017/09/10/libco%20源码走读%20·%20协程实现/libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%8811.56.26.png">
  
    <link rel="alternate" href="/atom.xml" title="Medium-Well" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Medium-Well</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">locustchen</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zerolocusta.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-libco 源码走读 · 协程实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/10/libco 源码走读 · 协程实现/" class="article-date">
  <time datetime="2017-09-10T13:18:22.000Z" itemprop="datePublished">2017-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="libco-源码走读-·-协程实现"><a href="#libco-源码走读-·-协程实现" class="headerlink" title="libco 源码走读 · 协程实现"></a>libco 源码走读 · 协程实现</h1><p><code>最近正在计划做一个c++上的Actor模型框架, 准备利用libco作为协程调度器, 需要对libco进行改造, 读起了libco源码</code></p>
<h1 id="0-源码蓝图"><a href="#0-源码蓝图" class="headerlink" title="0. 源码蓝图"></a>0. 源码蓝图</h1><h2 id="0-1-功能假设"><a href="#0-1-功能假设" class="headerlink" title="0.1 功能假设"></a>0.1 功能假设</h2><pre><code>读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设
    * libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间
    * 在做协程上下文转换时, 会利用汇编对当前逻辑进行保存, 然后将控制权让渡给主协程调度器, 由调度器决定下一个运行的协程
    * 保存协程上下文需要额外的栈, 但是libco的介绍里说了它利用了共享栈去保存协程状态
根据以上假设, 找出了几个相对应的文件和函数
    * epoll与调度器
    `co_routine.h` 中
        * 用于运行协程的主调度循环
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_eventloop</span><span class="params">(stCoEpoll_t *ctx, <span class="keyword">pfn_co_eventloop_t</span> pfn, <span class="keyword">void</span> *arg)</span></span></div></pre></td></tr></table></figure>
<pre><code>* 用于创建协程
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int co_create(stCoRoutine_t **co, const stCoRoutineAttr_t *attr, void *(*routine)(void *), void *arg);</div></pre></td></tr></table></figure>
<pre><code>* 用于载入协程
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">(stCoRoutine_t *co)</span></span></div></pre></td></tr></table></figure>
<pre><code>* 挂起协程相关操作
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_ct</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_env</span><span class="params">(stCoRoutineEnv_t *env)</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield</span><span class="params">(stCoRoutine_t *co)</span></span></div></pre></td></tr></table></figure>
<hr>
<h2 id="0-2-简单尝试"><a href="#0-2-简单尝试" class="headerlink" title="0.2 简单尝试"></a>0.2 简单尝试</h2><pre><code>API那么多, 眼花缭乱了, 先找几个最简单的, 尝试一下他的效果吧
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 新建协程的API</span></div><div class="line">int co_create(stCoRoutine_t **co, const stCoRoutineAttr_t *attr, void *(*routine)(void *), void *arg);</div><div class="line"></div><div class="line"><span class="comment">// 挂起当前协程的API</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_ct</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">// 恢复被挂起协程的API</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">(stCoRoutine_t *co)</span></span></div></pre></td></tr></table></figure>
<pre><code>利用这三个协程的创建, 挂起, 恢复, 简单地观察一下libco的协程运行状况.
简单的写一个测试的demo
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"co_routine.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span><span class="params">(<span class="keyword">void</span> *args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[foo] Before Yield ①\n"</span>);</div><div class="line">    co_yield_ct();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[foo] After  Yield ②\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bar</span><span class="params">(<span class="keyword">void</span> *args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[bar] Before Yield ③\n"</span>);</div><div class="line">    co_yield_ct();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[bar] After  Yield ④\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    stCoRoutine_t *foo_co = <span class="literal">NULL</span>;</div><div class="line">    stCoRoutine_t *bar_co = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 创建foo_co协程, 并且使用foo函数作为其入口函数</span></div><div class="line">    co_create(&amp;foo_co, <span class="literal">NULL</span>, foo, <span class="number">0</span>);</div><div class="line">    <span class="comment">// 创建bar_co协程, 并且使用bar函数作为其入口函数</span></div><div class="line">    co_create(&amp;bar_co, <span class="literal">NULL</span>, bar, <span class="number">0</span>);</div><div class="line">    <span class="comment">// 初次载入 foo_co 协程</span></div><div class="line">    co_resume(foo_co);</div><div class="line">    <span class="comment">// 初次载入 bar_co 协程</span></div><div class="line">    co_resume(bar_co);</div><div class="line">    <span class="comment">// 再次载入 foo_co 协程</span></div><div class="line">    co_resume(foo_co);</div><div class="line">    <span class="comment">// 再次载入 bar_co 协程</span></div><div class="line">    co_resume(bar_co);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>运行结果
            ![](libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.00.40.png)
符合我们对协程的预期和理解, 接下来应该深入`co_create`, `co_resume` 和 `co_yield_ct()`去理解libco究竟如何实现这个过程了.
</code></pre><hr>
<h2 id="0-3-跟踪co-create"><a href="#0-3-跟踪co-create" class="headerlink" title="0.3 跟踪co_create"></a>0.3 跟踪<code>co_create</code></h2><h3 id="0-3-1-co-create函数本体"><a href="#0-3-1-co-create函数本体" class="headerlink" title="0.3.1 co_create函数本体"></a>0.3.1 <code>co_create</code>函数本体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">co_create</span><span class="params">(stCoRoutine_t **ppco, <span class="keyword">const</span> stCoRoutineAttr_t *attr, <span class="keyword">pfn_co_routine_t</span> pfn, <span class="keyword">void</span> *arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// 尝试获取当前线程的 全局协程运行环境</span></div><div class="line">	<span class="keyword">if</span> (!co_get_curr_thread_env())</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 如果当前线程的 全局协程运行环境 未初始化,</span></div><div class="line">		<span class="comment">// 那么初始化它</span></div><div class="line">		co_init_curr_thread_env();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 这里的 co_create_env </span></div><div class="line">	<span class="comment">// 要理解为 根据pfn入口函数, </span></div><div class="line">	<span class="comment">// 创建 协程私有的运行环境 , </span></div><div class="line">	<span class="comment">// 要和上面的 全局运行环境 分开</span></div><div class="line">	stCoRoutine_t *co = co_create_env(co_get_curr_thread_env(), attr, pfn, arg);</div><div class="line">	*ppco = co;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>根据`co_create`的源码, 发现
        * libco每个线程都有一个全局协程运行环境
        * 每个协程也有自己的私有运行环境(类似于上下文)
</code></pre><h3 id="0-3-1-co-get-curr-thread-env-函数本体"><a href="#0-3-1-co-get-curr-thread-env-函数本体" class="headerlink" title="0.3.1 co_get_curr_thread_env()函数本体"></a>0.3.1 <code>co_get_curr_thread_env()</code>函数本体</h3><pre><code>先看看这个::当前线程的协程全局运行环境::是什么吧
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">stCoRoutineEnv_t *<span class="title">co_get_curr_thread_env</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">return</span> g_arrCoEnvPerThread[GetPid()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>`co_get_curr_thread_env()`根据不同的当前 线程/进程  id, 去获取相应的`stCoRoutineEnv_t`
`g_arrCoEnvPerThread`数组长这样
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> stCoRoutineEnv_t *g_arrCoEnvPerThread[<span class="number">204800</span>] = &#123;<span class="number">0</span>&#125;;</div></pre></td></tr></table></figure>
<h3 id="0-3-2-stCoRoutineEnv-t结构体"><a href="#0-3-2-stCoRoutineEnv-t结构体" class="headerlink" title="0.3.2 stCoRoutineEnv_t结构体"></a>0.3.2 <code>stCoRoutineEnv_t</code>结构体</h3><pre><code>这个协程环境存了什么呢? 
简单的看一下`stCoRoutineEnv_t`结构体
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutineEnv_t</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="comment">// 协程的调用栈 (resume/yield 栈) </span></div><div class="line">	stCoRoutine_t *pCallStack[<span class="number">128</span>];</div><div class="line">  <span class="comment">// 协程调用栈的大小</span></div><div class="line">	<span class="keyword">int</span> iCallStackSize;</div><div class="line">  <span class="comment">// 当前线程使用的 epoll</span></div><div class="line">	stCoEpoll_t *pEpoll;</div><div class="line"></div><div class="line">	<span class="comment">// for copy stack log lastco and nextco</span></div><div class="line">  <span class="comment">// 共享栈, 目前无视这个概念, 留到后面再深究</span></div><div class="line">	stCoRoutine_t *pending_co;</div><div class="line">	stCoRoutine_t *occupy_co;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<pre><code>目前看起来还是云里雾里, 因为这个`stCoRoutineEnv_t`需要和`co_resume` 和 `co_yield_ct()` 结合起来理解, 先放一边吧
</code></pre><h3 id="0-3-3-co-init-curr-thread-env-函数本体"><a href="#0-3-3-co-init-curr-thread-env-函数本体" class="headerlink" title="0.3.3 co_init_curr_thread_env()函数本体"></a>0.3.3 <code>co_init_curr_thread_env()</code>函数本体</h3><pre><code>`co_create`下一个函数就是`co_init_curr_thread_env()`
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">co_init_curr_thread_env</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// 获取当前 线程/进程 id</span></div><div class="line">	<span class="keyword">pid_t</span> pid = GetPid();</div><div class="line"></div><div class="line">	<span class="comment">// 在堆中建立 stCoRoutineEnv_t 结构体</span></div><div class="line">	<span class="comment">// 将指针存入 g_arrCoEnvPerThread 相应的位置中</span></div><div class="line">	g_arrCoEnvPerThread[pid] = (stCoRoutineEnv_t *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(stCoRoutineEnv_t));</div><div class="line">	stCoRoutineEnv_t *env = g_arrCoEnvPerThread[pid];</div><div class="line"></div><div class="line">	<span class="comment">// 初始化调用栈大小</span></div><div class="line">	env-&gt;iCallStackSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个self协程</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutine_t</span> *<span class="title">self</span> = <span class="title">co_create_env</span>(<span class="title">env</span>, <span class="title">NULL</span>, <span class="title">NULL</span>, <span class="title">NULL</span>);</span></div><div class="line">	<span class="comment">// 设置self协程为当前线程的主协程</span></div><div class="line">	self-&gt;cIsMain = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 共享栈相关</span></div><div class="line">	env-&gt;pending_co = <span class="literal">NULL</span>;</div><div class="line">	env-&gt;occupy_co = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 初始化self协程的上下文</span></div><div class="line">	coctx_init(&amp;self-&gt;ctx);</div><div class="line"></div><div class="line">	<span class="comment">// 将self协程置入 pCallStack 协程调用栈的栈底</span></div><div class="line">	env-&gt;pCallStack[env-&gt;iCallStackSize++] = self;</div><div class="line"></div><div class="line">	<span class="comment">// 暂时无视epoll</span></div><div class="line">	stCoEpoll_t *ev = AllocEpoll();</div><div class="line">	SetEpoll(env, ev);›</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>`co_init_curr_thread_env()`中有几个关键点
        * `stCoRoutine_t`结构体
        * `self`主协程
        * `pCallStack` 协程调用栈
`stCoRoutine_t`结构体 和 `self`主协程延后关注, 先看看当前`pCallStack`的样子
            ![](libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.58.18.png)
`self`协程被置入`pCallStack`的底部
</code></pre><h3 id="0-3-4-stCoRoutine-t结构体"><a href="#0-3-4-stCoRoutine-t结构体" class="headerlink" title="0.3.4 stCoRoutine_t结构体"></a>0.3.4 <code>stCoRoutine_t</code>结构体</h3><pre><code>`stCoRoutine_t`是用于描述和记录**一个协程**上下文的结构体
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stCoRoutine_t</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">	stCoRoutineEnv_t *env; 	<span class="comment">// 记录协程所在的当前线程全局环境</span></div><div class="line">	<span class="keyword">pfn_co_routine_t</span> pfn; 	<span class="comment">// 当前协程运行的入口函数</span></div><div class="line">	<span class="keyword">void</span> *arg;   	<span class="comment">// 传递给入口函数的形参</span></div><div class="line">	<span class="keyword">coctx_t</span> ctx; 	<span class="comment">// 保存着当前协程的寄存器状态</span></div><div class="line">	<span class="keyword">char</span> cStart; 	<span class="comment">// 记录当前协程是否已经开始执行</span></div><div class="line">	<span class="keyword">char</span> cEnd;   	<span class="comment">// 记录当前协程是否已经结束执行</span></div><div class="line">	<span class="keyword">char</span> cIsMain;	<span class="comment">// 记录当前协程是否为主协程</span></div><div class="line">	<span class="keyword">char</span> cEnableSysHook; <span class="comment">// 记录当前协程是否开启系统API钩子</span></div><div class="line">	<span class="keyword">char</span> cIsShareStack;  <span class="comment">// 记录当前协程是否开启共享栈</span></div><div class="line">	<span class="comment">// 系统API钩子相关, 本节无视之</span></div><div class="line">	<span class="keyword">void</span> *pvEnv;</div><div class="line"></div><div class="line">	stStackMem_t* stack_mem;<span class="comment">// 记录当前协程存放栈数据的内存地址</span></div><div class="line"></div><div class="line">	<span class="comment">// 以下均为共享栈相关, 本节无视之</span></div><div class="line">	<span class="keyword">char</span>* stack_sp; </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> save_size;</div><div class="line">	<span class="keyword">char</span>* save_buffer;</div><div class="line">	stCoSpec_t aSpec[<span class="number">1024</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<pre><code>需要关注`coctx_t`和`stStackMem_t`这个结构体, 因为 恢复_保存(resume_yield) 协程的运行状态就靠他了.
</code></pre><h3 id="0-3-5-coctx-t-和-stStackMem-t"><a href="#0-3-5-coctx-t-和-stStackMem-t" class="headerlink" title="0.3.5 coctx_t 和 stStackMem_t"></a>0.3.5 <code>coctx_t</code> 和 <code>stStackMem_t</code></h3><pre><code>仔细观察::章节0.2 简单尝试::中, 在`main`函数中通过`co_resume`载入`foo_co`, 并且调用`foo`函数, 而在`foo`函数中, 通过`co_yield_ct`回到`main`函数中, 而后在**再次调用**`foo`函数的时候, 又能回到上一次调用`co_yield_ct`的地方, 并继续执行直到函数返回.
在那段代码里, `main`函数没有直接调用`foo`, 而在`foo`中也没有直接调用`main`, 但是却能通过`co_resume`和`co_yield_ct`来回调用
这里的魔法: **利用汇编, 保存被挂起协程的运行现场, 然后恢复别的协程的运行现场**
运行现场, 其实更确切的说法是, 协程被挂起前 CPU寄存器 和 内存中栈 的状态.
而`coctx_t`就是记录着协程被挂起前 CPU寄存器状态 的结构了.
至于协程被挂起前 内存中栈的状态, 当然记录在`stack_mem`里
要把 寄存器状态、内存中栈的状态 和协程运行状态的关系说清楚, 要理解::处理器中的寄存器(libco里仅支持x86及amd64)::还有::X86调用约定::, 以及::操作系统如何载入程序、分配内存并运行的::.
_即使libco同时支持x86和amd64架构, 但是为了简化文章, 这里只探讨x86架构_
</code></pre><h4 id="0-3-5-1-x86处理器中的寄存器"><a href="#0-3-5-1-x86处理器中的寄存器" class="headerlink" title="0.3.5.1 x86处理器中的寄存器"></a>0.3.5.1 x86处理器中的寄存器</h4><pre><code>这里只关注主要用到的几个
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%8811.56.26.png" alt=""><br>    x86主要用到这几个寄存器</p>
<h4 id="0-3-5-2-x86调用协定"><a href="#0-3-5-2-x86调用协定" class="headerlink" title="0.3.5.2 x86调用协定"></a>0.3.5.2 x86调用协定</h4><pre><code>根据维基百科上的[X86调用约定](https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl), 在c语言中发生函数调用时, 调用者会操作寄存器和内存, 保存函数调用前状态, 然后跳转到被调函数的地址
这里有三个很重要的寄存器
        * esp:  栈指针, 用于存放当前栈的位置
        * ebp: 基栈指针, 用于存放当前函数栈帧的开始位置
        * eip: 存放着下一条指令的地址, CPU会自动读取eip并载入取下一条指令

参考维基百科上[X86调用约定](https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl)给出的实例, 存在这样的c语言代码
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">callee</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">caller</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">register</span> <span class="keyword">int</span> ret;</div><div class="line">    </div><div class="line">    ret = callee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">    ret += <span class="number">5</span>;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>编译后产生这样的代码,
(0 - 9是我添加的, 用于简单标识出地址, 实际编译不会产生)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">       .globl  caller</div><div class="line"> caller:</div><div class="line">0       pushl   %ebp			# 记录调用caller函数的栈帧</div><div class="line">1       movl    %esp, %ebp   # 构造caller栈帧</div><div class="line">2       pushl   $3           # 逆序将callee函数入栈</div><div class="line">3       pushl   $2</div><div class="line">4       pushl   $1</div><div class="line">5       call    callee       # 调用callee函数</div><div class="line">6       addl    $12,%esp     # 缩减栈大小</div><div class="line">7       addl    $5,%eax      # 将callee返回值+ 5</div><div class="line">8       leave					# 清理栈帧</div><div class="line">9       ret					# 返回至调用者</div></pre></td></tr></table></figure>
<pre><code>    * `pushl [操作数]`:  `push long`, 将操作数中的值推入栈中, 并将栈指针增加4字节的大小.
    * `movl [a] [b]`    : `move long`, 将 a 中的4字节值复制到 b 中
    * `call [函数地址]` :  将eip中的值推入栈中, 并跳转到函数地址
    * `addl [a] [b]`    :  相当于`b = a + b`
    * `leave`                   : 清空当前函数调用栈帧
    * `ret`                       : 从栈顶取得eip地址, 返回至该地址
可视化这个函数调用
    1. `call callee`前
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.56.12.png" alt=""></p>
<pre><code>2. `call callee时`
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.54.09.png" alt=""></p>
<pre><code>3. `call callee后 - leave前`
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.52.19.png" alt=""><br>    函数调用就是操纵CPU寄存器和内存栈, 有了这样的概念, 那么我们在协程切换时, 直接利用<strong>汇编</strong>操纵寄存器和栈就好啦.</p>
<pre><code>1. 保存当前协程所处寄存器状态
2. 回复需要载入协程的寄存器状态
</code></pre><h4 id="0-3-5-3-操作系统如何载入程序、分配内存并运行的"><a href="#0-3-5-3-操作系统如何载入程序、分配内存并运行的" class="headerlink" title="0.3.5.3 操作系统如何载入程序、分配内存并运行的"></a>0.3.5.3 操作系统如何载入程序、分配内存并运行的</h4><pre><code>寄存器的问题解决了, 但是栈的问题还没解决
操作系统在载入程序时, 会给一个线程分配**一个**固定大小的栈, 而在libco中, 一个线程里有多个协程
先来看看所有协程都使用操作系统分配的一个栈会怎样
仍然利用上面的::章节0.2 简单尝试::中实例代码展示
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.25.52.png" alt=""><br>    如果只有一个栈,  在<code>co_yield_ct</code>时, <code>foo_co</code>的栈帧被抹去, 可是这时<code>foo_co</code>还没执行完啊, 抹去了<code>foo_co</code>栈帧, 那么就没办法恢复<code>foo_co</code>被挂起前状态了.<br>    所以, 必须要有一个地方存放协程的栈帧, 可以申请堆内存去存放协程的栈帧<br><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.37.52.png" alt=""><br>    利用汇编, 将esp和ebp指向我们申请的堆内存就好了, 这样程序运行的时候从esp和ebp取得的就是堆内存中的地址</p>
<hr>
<h3 id="0-3-6-coctx-t结构体"><a href="#0-3-6-coctx-t结构体" class="headerlink" title="0.3.6 coctx_t结构体"></a>0.3.6 <code>coctx_t</code>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coctx_t</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__i386__)</span></div><div class="line">	<span class="keyword">void</span> *regs[ <span class="number">8</span> ];</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">	<span class="keyword">void</span> *regs[ <span class="number">14</span> ];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  <span class="comment">// 栈大小</span></div><div class="line">	<span class="keyword">size_t</span> ss_size;</div><div class="line">  <span class="comment">// 栈指针</span></div><div class="line">	<span class="keyword">char</span> *ss_sp;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//----- --------</span></div><div class="line"><span class="comment">// 32 bit</span></div><div class="line"><span class="comment">// | regs[0]: ret |</span></div><div class="line"><span class="comment">// | regs[1]: ebx |</span></div><div class="line"><span class="comment">// | regs[2]: ecx |</span></div><div class="line"><span class="comment">// | regs[3]: edx |</span></div><div class="line"><span class="comment">// | regs[4]: edi |</span></div><div class="line"><span class="comment">// | regs[5]: esi |</span></div><div class="line"><span class="comment">// | regs[6]: ebp |</span></div><div class="line"><span class="comment">// | regs[7]: eax |</span></div></pre></td></tr></table></figure>
<pre><code>只关注x86架构下, `coctx_t`存放了8个CPU寄存器的值, 就是::0.3.5.1 x86处理器中的寄存器::那张图里的8个, 堆中协程栈的大小和起始位置
</code></pre><h3 id="0-3-7-coctx-t结构体的相关操作"><a href="#0-3-7-coctx-t结构体的相关操作" class="headerlink" title="0.3.7 coctx_t结构体的相关操作"></a>0.3.7 <code>coctx_t</code>结构体的相关操作</h3><h4 id="0-3-7-1-coctx-init函数-初始化coctx-t结构体"><a href="#0-3-7-1-coctx-init函数-初始化coctx-t结构体" class="headerlink" title="0.3.7.1 coctx_init函数, 初始化coctx_t结构体"></a>0.3.7.1 <code>coctx_init</code>函数, 初始化<code>coctx_t</code>结构体</h4><p><code>coctx_init</code>源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">coctx_init</span><span class="params">( <span class="keyword">coctx_t</span> *ctx )</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">memset</span>( ctx,<span class="number">0</span>,<span class="keyword">sizeof</span>(*ctx));</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="0-3-7-1-coctx-make函数-准备协程入口"><a href="#0-3-7-1-coctx-make函数-准备协程入口" class="headerlink" title="0.3.7.1 coctx_make函数, 准备协程入口"></a>0.3.7.1 <code>coctx_make</code>函数, 准备协程入口</h4><p><code>coctx_make</code>源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span></div><div class="line">&#123;</div><div class="line">	kEIP = <span class="number">0</span>,</div><div class="line">	kESP = <span class="number">7</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">coctx_make</span><span class="params">(<span class="keyword">coctx_t</span> *ctx, <span class="keyword">coctx_pfn_t</span> pfn, <span class="keyword">const</span> <span class="keyword">void</span> *s, <span class="keyword">const</span> <span class="keyword">void</span> *s1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">//make room for coctx_param</span></div><div class="line">	<span class="keyword">char</span> *sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - <span class="keyword">sizeof</span>(<span class="keyword">coctx_param_t</span>);</div><div class="line">  <span class="comment">// 清空sp末位, (-16L == 0xfffffff0), 为了内存对齐</span></div><div class="line">	sp = (<span class="keyword">char</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)sp &amp; <span class="number">-16L</span>);</div><div class="line"></div><div class="line">	<span class="keyword">coctx_param_t</span> *param = (<span class="keyword">coctx_param_t</span> *)sp;</div><div class="line">	param-&gt;s1 = s;</div><div class="line">	param-&gt;s2 = s1;</div><div class="line"></div><div class="line">	<span class="built_in">memset</span>(ctx-&gt;regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(ctx-&gt;regs));</div><div class="line"></div><div class="line">	<span class="comment">// sizeof(void*)是给pfn的形参预留的位置</span></div><div class="line">	ctx-&gt;regs[kESP] = (<span class="keyword">char</span> *)(sp) - <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">	ctx-&gt;regs[kEIP] = (<span class="keyword">char</span> *)pfn;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>调用`coctx_make`后, 堆中协程栈和`coctx_t`结构体状态
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.05.19.png" alt=""></p>
<h3 id="0-3-8-跟踪co-create-env"><a href="#0-3-8-跟踪co-create-env" class="headerlink" title="0.3.8 跟踪co_create_env"></a>0.3.8 跟踪<code>co_create_env</code></h3><p><code>co_create_env</code>用于申请协程结构体<code>stCoRoutine_t</code>的内存及协程栈的内存<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct stCoRoutine_t *<span class="title">co_create_env</span><span class="params">(stCoRoutineEnv_t *env, <span class="keyword">const</span> stCoRoutineAttr_t *attr, <span class="keyword">pfn_co_routine_t</span> pfn, <span class="keyword">void</span> *arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">	stCoRoutineAttr_t at;</div><div class="line">	<span class="keyword">if</span> (attr)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 复制 stCoRoutineAttr_t 至 at 中</span></div><div class="line">		<span class="built_in">memcpy</span>(&amp;at, attr, <span class="keyword">sizeof</span>(at));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (at.stack_size &lt;= <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		at.stack_size = <span class="number">128</span> * <span class="number">1024</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (at.stack_size &gt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">8</span>)</div><div class="line">	&#123;</div><div class="line">		at.stack_size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">8</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (at.stack_size &amp; <span class="number">0xFFF</span>)</div><div class="line">	&#123;</div><div class="line">		at.stack_size &amp;= ~<span class="number">0xFFF</span>;</div><div class="line">		at.stack_size += <span class="number">0x1000</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	stCoRoutine_t *lp = (stCoRoutine_t *) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>( stCoRoutine_t ));</div><div class="line"></div><div class="line">	<span class="built_in">memset</span>(lp, <span class="number">0</span>, (<span class="keyword">long</span>)(<span class="keyword">sizeof</span>(stCoRoutine_t)));</div><div class="line"></div><div class="line">	lp-&gt;env = env;</div><div class="line">	lp-&gt;pfn = pfn;</div><div class="line">	lp-&gt;arg = arg;</div><div class="line"></div><div class="line">	stStackMem_t *stack_mem = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">if</span> (at.share_stack)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 共享栈, 本章不关注</span></div><div class="line">		stack_mem = co_get_stackmem(at.share_stack);</div><div class="line">		at.stack_size = at.share_stack-&gt;stack_size;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 为协程申请运行栈</span></div><div class="line">		stack_mem = co_alloc_stackmem(at.stack_size);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 以下均为初始化协程信息</span></div><div class="line">	lp-&gt;stack_mem = stack_mem;</div><div class="line"></div><div class="line">	lp-&gt;ctx.ss_sp = stack_mem-&gt;stack_buffer;</div><div class="line">	lp-&gt;ctx.ss_size = at.stack_size;</div><div class="line"></div><div class="line">	lp-&gt;cStart = <span class="number">0</span>;</div><div class="line">	lp-&gt;cEnd = <span class="number">0</span>;</div><div class="line">	lp-&gt;cIsMain = <span class="number">0</span>;</div><div class="line">	lp-&gt;cEnableSysHook = <span class="number">0</span>;</div><div class="line">	lp-&gt;cIsShareStack = at.share_stack != <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	lp-&gt;save_size = <span class="number">0</span>;</div><div class="line">	lp-&gt;save_buffer = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> lp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="0-4-跟踪co-resume"><a href="#0-4-跟踪co-resume" class="headerlink" title="0.4 跟踪co_resume"></a>0.4 跟踪<code>co_resume</code></h2><p>协程的栈, 存放寄存器<code>coctx_t</code>结构体准备好了, 接下来是调用<code>co_resume</code>载入协程了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_resume</span><span class="params">(stCoRoutine_t *co)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="comment">// 获取协程全局环境</span></div><div class="line">	stCoRoutineEnv_t *env = co-&gt;env;</div><div class="line">  <span class="comment">// 获取上一个协程</span></div><div class="line">	stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[env-&gt;iCallStackSize - <span class="number">1</span>];</div><div class="line">  <span class="comment">// 检查协程是否已经执行过</span></div><div class="line">	<span class="keyword">if</span> (!co-&gt;cStart)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 创建协程入口, coctx_make在上面讨论过</span></div><div class="line">		<span class="comment">// 注意这里 CoRoutineFunc</span></div><div class="line">		coctx_make(&amp;co-&gt;ctx, (<span class="keyword">coctx_pfn_t</span>)CoRoutineFunc, co, <span class="number">0</span>);</div><div class="line">		co-&gt;cStart = <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">  <span class="comment">// 增加 pCallStack 协程调用栈, 并设置为 co</span></div><div class="line">	env-&gt;pCallStack[env-&gt;iCallStackSize++] = co;</div><div class="line">  <span class="comment">// 保存当前协程现场, 切换到 co 协程现场</span></div><div class="line">	co_swap(lpCurrRoutine, co);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="0-4-1-CoRoutineFunc协程入口函数"><a href="#0-4-1-CoRoutineFunc协程入口函数" class="headerlink" title="0.4.1 CoRoutineFunc协程入口函数"></a>0.4.1 <code>CoRoutineFunc</code>协程入口函数</h3><p>在<code>co_resume</code>的<code>coctx_make</code>中, 并没有直接将需要运行的函数直接传递给<code>coctx_make</code>, 而是将另一个函数<code>CoRoutineFunc</code>和<code>co</code>传给它, 先看<code>CoRoutineFunc</code>的源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我认为 void * 是为了兼容历史遗留的API</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">CoRoutineFunc</span><span class="params">(stCoRoutine_t *co, <span class="keyword">void</span> *)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">if</span> (co-&gt;pfn)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 在此调用需要运行在协程中的函数</span></div><div class="line">		co-&gt;pfn(co-&gt;arg);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 将协程运行完成的标识置为1</span></div><div class="line">	co-&gt;cEnd = <span class="number">1</span>;</div><div class="line"></div><div class="line">	stCoRoutineEnv_t *env = co-&gt;env;</div><div class="line">	<span class="comment">// 直接跳到上一个协程, co_yield_env 后面会讨论, 无需返回</span></div><div class="line">	co_yield_env(env);</div><div class="line">	<span class="comment">// return 0 不该发生, 否则引发 SIGSEGV</span></div><div class="line">  <span class="comment">// 因为没有构造返回地址</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>再看在调用`coctx_make(&amp;co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, 0);`后,   堆中协程栈和`coctx_t`结构体状态.
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.17.00.png" alt=""></p>
<h3 id="0-4-2-回到co-resume"><a href="#0-4-2-回到co-resume" class="headerlink" title="0.4.2 回到co_resume"></a>0.4.2 回到<code>co_resume</code></h3><pre><code>同样以::章节0.2 简单尝试::中实例代码为例, 标上行号
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function">2 </span>&#123;</div><div class="line"><span class="number">3</span>     stCoRoutine_t *foo_co = <span class="literal">NULL</span>;</div><div class="line"><span class="number">4</span>     stCoRoutine_t *bar_co = <span class="literal">NULL</span>;</div><div class="line"><span class="number">5</span>     <span class="comment">// 创建foo_co协程, 并且使用foo函数作为其入口函数</span></div><div class="line"><span class="number">6</span>     co_create(&amp;foo_co, <span class="literal">NULL</span>, foo, <span class="number">0</span>);</div><div class="line"><span class="number">7</span>     <span class="comment">// 创建bar_co协程, 并且使用bar函数作为其入口函数</span></div><div class="line"><span class="number">8</span>     co_create(&amp;bar_co, <span class="literal">NULL</span>, bar, <span class="number">0</span>);</div><div class="line"><span class="number">9</span>     <span class="comment">// 初次载入 foo_co 协程</span></div><div class="line"><span class="number">10</span>    co_resume(foo_co);</div><div class="line"><span class="number">11</span>    <span class="comment">// 初次载入 bar_co 协程</span></div><div class="line"><span class="number">12</span>    co_resume(bar_co);</div><div class="line"><span class="number">13</span>    <span class="comment">// 再次载入 foo_co 协程</span></div><div class="line"><span class="number">14</span>    co_resume(foo_co);</div><div class="line"><span class="number">15</span>    <span class="comment">// 再次载入 bar_co 协程</span></div><div class="line"><span class="number">16</span>    co_resume(bar_co);</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure>
<pre><code>在第10行初次载入`foo_co`的时候, `env-&gt;pCallStack`的状态,
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png" alt=""></p>
<pre><code>调用`co_resume`增加pCallStack栈大小之后的状态                                            ![](libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52.png) 
</code></pre><h3 id="0-4-1-co-swap函数-切换协程"><a href="#0-4-1-co-swap函数-切换协程" class="headerlink" title="0.4.1 co_swap函数, 切换协程"></a>0.4.1 <code>co_swap</code>函数, 切换协程</h3><p><code>co_swap</code>是一个用汇编实现的方法<br>    它的签名<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">coctx_swap</span><span class="params">(<span class="keyword">coctx_t</span> *, <span class="keyword">coctx_t</span> *)</span> <span class="title">asm</span><span class="params">(<span class="string">"coctx_swap"</span>)</span></span></div></pre></td></tr></table></figure></p>
<pre><code>它的实现
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">leal 4(%esp), %eax //sp </div><div class="line">movl 4(%esp), %esp </div><div class="line">leal 32(%esp), %esp //parm a : &amp;regs[7] + sizeof(void*)</div><div class="line"></div><div class="line">pushl %eax //esp -&gt;parm a </div><div class="line"></div><div class="line">pushl %ebp</div><div class="line">pushl %esi</div><div class="line">pushl %edi</div><div class="line">pushl %edx</div><div class="line">pushl %ecx</div><div class="line">pushl %ebx</div><div class="line">pushl -4(%eax)</div><div class="line"></div><div class="line"></div><div class="line">movl 4(%eax), %esp //parm b -&gt; &amp;regs[0]</div><div class="line"></div><div class="line">popl %eax  //ret func addr</div><div class="line">popl %ebx  </div><div class="line">popl %ecx</div><div class="line">popl %edx</div><div class="line">popl %edi</div><div class="line">popl %esi</div><div class="line">popl %ebp</div><div class="line"></div><div class="line">popl %esp</div><div class="line">pushl %eax //set ret func addr</div><div class="line"></div><div class="line">xorl %eax, %eax</div><div class="line">ret</div></pre></td></tr></table></figure>
<pre><code>对于::章节0.2 简单尝试::中初次`co_resume`中的`co_swap`来说, 可视化后的图
    1. 保存`self`现场
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.23.57.png" alt=""></p>
<pre><code>2. 恢复`foo_co`现场
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.24.06.png" alt=""></p>
<pre><code>3. CPU会自动从eip寄存器去下一条指令地址, 即此时载入foo函数
</code></pre><hr>
<h2 id="跟踪co-yield-ct"><a href="#跟踪co-yield-ct" class="headerlink" title="跟踪co_yield_ct"></a>跟踪<code>co_yield_ct</code></h2><p>创建、载入协程都说完了, 然后就是挂起协程的<code>co_yield_ct</code>了吧<br>    源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_env</span><span class="params">(stCoRoutineEnv_t *env)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// pCallStack 调用栈中, 调用co_resume(当前协程)的协程</span></div><div class="line">	stCoRoutine_t *last = \</div><div class="line">		env-&gt;pCallStack[env-&gt;iCallStackSize - <span class="number">2</span>];</div><div class="line">	<span class="comment">// 栈顶部的协程, 也就是当前协程</span></div><div class="line">	stCoRoutine_t *curr = \</div><div class="line">		env-&gt;pCallStack[env-&gt;iCallStackSize - <span class="number">1</span>];</div><div class="line">	<span class="comment">// 栈大小减1, 栈顶元素出栈</span></div><div class="line">	env-&gt;iCallStackSize--;</div><div class="line">	<span class="comment">// 切换至 上一个协程</span></div><div class="line">	co_swap(curr, last);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">co_yield_ct</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	co_yield_env(co_get_curr_thread_env());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样以::章节0.2 简单尝试::中实例代码为例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span><span class="params">(<span class="keyword">void</span> *args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[foo] Before Yield ①\n"</span>);</div><div class="line">    co_yield_ct();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[foo] After  Yield ②\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>`foo`函数在调用`co_yield_ct`前, pCallStack的状态
</code></pre><p><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png" alt=""><br>    在调用<code>co_yield_ct</code>后, pCallStack的状态<br><img src="libco%20%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14%201.png" alt=""><br>    然后调用<code>co_swap</code>回到<code>self</code>协程中保存的现场</p>
<hr>
<h2 id="未解问题"><a href="#未解问题" class="headerlink" title="未解问题"></a>未解问题</h2><p>本章只探讨了libco中协程的基本操作, libco还有更多特性</p>
<pre><code>* 协程共享栈
* co_eventloop
* 系统钩子
</code></pre><p>之后再探讨</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zerolocusta.github.io/2017/09/10/libco 源码走读 · 协程实现/" data-id="cj7lmht1b000049t2ujhcggz1" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/10/libco 源码走读 · 协程实现/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 locustchen<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
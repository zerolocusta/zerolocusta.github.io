<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zerolocust]]></title>
  <link href="zerolocusta.github.io/atom.xml" rel="self"/>
  <link href="zerolocusta.github.io/"/>
  <updated>2018-05-20T11:26:25+08:00</updated>
  <id>zerolocusta.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Badger LSM 实现剖析 · Part 1 · Memtable 与 SST]]></title>
    <link href="zerolocusta.github.io/15259419469147.html"/>
    <updated>2018-05-10T16:45:46+08:00</updated>
    <id>zerolocusta.github.io/15259419469147.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">本文对应 commit <a href="https://github.com/dgraph-io/badger/tree/754278dbecbe8bfa0fec445d6af3bc2e0cf21911">754278d</a></h5>

<p>Badger LSM 参考了 RocksDB LSM 实现，本文结合 RocksDB 文档与 Badger 源码进行分析。</p>

<h3 id="toc_1">Memtable</h3>

<p>Badger LSM 中 Memtable 采用了 Skiplist 实现，其 Key 类型是 <code>[]byte</code>，而 Value 类型是 <code>ValueStruct</code>.</p>

<pre><code class="language-go">type ValueStruct struct {
    Meta      byte
    UserMeta  byte
    ExpiresAt uint64
    Value     []byte

    Version uint64     // 版本号不会被序列化
}
</code></pre>

<p>Skiplist 的实现利用<code>arena</code>连续的<code>[]byte</code>字节数组存储键值对，使用<code>node</code>存储键值对在<code>arena</code>中的位置（偏移量），将 Skiplist 扁平化存储，并且大量使用<code>atomic</code>操作以实现无锁操作(包括<code>arena</code>中使用原子操作实现无锁读写)。</p>

<p><code>type Skiplist struct</code>源码</p>

<pre><code class="language-go">type Skiplist struct {
    height int32   // 存储当前跳表高度
    head   *node   // 头部节点
    ref    int32   // 引用计数
    arena  *Arena  // arena指针
}
</code></pre>

<p>Skiplist 采用<code>*node</code>存储了头部指针，看似使用了链表的形式存储<code>node</code>，但实际上从<code>node</code>中并未直接看到任何链表结构。</p>

<p><code>type node struct</code>源码</p>

<pre><code class="language-go">type node struct {
    
    value uint64 // 同时包含了值的所在偏移量和值的大小(高32位为值的所在偏移量，低17位为值的大小)，合并存储是为了利用原子读写

    keyOffset uint32 // 键所在偏移量
    keySize   uint16 // 键大小

    height uint16

    tower [maxHeight]uint32
}
</code></pre>

<p>看似<code>node</code>中并没有任何能体现出链表结构的字段，其实利用了<code>tower</code>字段存储了当前<code>node</code>在每一层级中的后继节点在<code>arena</code>中的<strong>偏移量(offset)</strong>。</p>

<p>除此之外，此跳跃列表拥有比传统链表更好的性能，其风骚之处在于<code>arena</code>，利用连续的字节数组存储键值对，并且利用原子操作实现高效的无锁跳跃列表。</p>

<p><code>type arena struct</code>源码</p>

<pre><code class="language-go">type Arena struct {
    n   uint32
    buf []byte
}
</code></pre>

<p><code>buf</code>是起始时即申请好的固定大小（非常大）的字节数组，<code>n</code>是当前已使用<code>buf</code>位置的偏移量。在初始化时，<code>n</code>被置为1（0代表空）。</p>

<p>在<code>arena</code>中，分别有三种类型的数据存储在<code>buf</code>中，分别是<code>node</code>、<code>key</code>和<code>value</code>。在<code>skl.go</code>中，<code>newNode</code>方法展示了如何在<code>arena</code>中生成一个新的节点。</p>

<pre><code class="language-go">func newNode(arena *Arena, key []byte, v y.ValueStruct, height int) *node {
    // 在arena中生成节点，并获得node在arena中的偏移量
    offset := arena.putNode(height)
    // 通过偏移量获取arena中的节点指针
    node := arena.getNode(offset)
    // 在arena中置入key，并将其偏移量存入node中
    node.keyOffset = arena.putKey(key)
    // 保存键的大小
    node.keySize = uint16(len(key))
    // 保存节点高度
    node.height = uint16(height)
    // 在arena中置入值，并将其偏移量和大小编码存入node中
    node.value = encodeValue(arena.putVal(v), v.EncodedSize())
    return node
}
</code></pre>

<p>无论是<code>putNode</code>、<code>putKey</code>还是<code>putValue</code>均是通过原子操作实现无锁并发安全。</p>

<pre><code class="language-go">func (s *Arena) putNode(height int) uint32 {
    unusedSize := (maxHeight - height) * offsetSize

    l := uint32(MaxNodeSize - unusedSize + nodeAlign)
    n := atomic.AddUint32(&amp;s.n, l)
    y.AssertTruef(int(n) &lt;= len(s.buf),
        &quot;Arena too small, toWrite:%d newTotal:%d limit:%d&quot;,
        l, n, len(s.buf))

    m := (n - l + uint32(nodeAlign)) &amp; ^uint32(nodeAlign)
    return m
}

func (s *Arena) putVal(v y.ValueStruct) uint32 {
    l := uint32(v.EncodedSize())
    n := atomic.AddUint32(&amp;s.n, l)
    y.AssertTruef(int(n) &lt;= len(s.buf),
        &quot;Arena too small, toWrite:%d newTotal:%d limit:%d&quot;,
        l, n, len(s.buf))
    m := n - l
    v.Encode(s.buf[m:])
    return m
}

func (s *Arena) putKey(key []byte) uint32 {
    l := uint32(len(key))
    n := atomic.AddUint32(&amp;s.n, l)
    y.AssertTruef(int(n) &lt;= len(s.buf),
        &quot;Arena too small, toWrite:%d newTotal:%d limit:%d&quot;,
        l, n, len(s.buf))
    m := n - l
    y.AssertTrue(len(key) == copy(s.buf[m:n], key))
    return m
}
</code></pre>

<p><img src="media/15259419469147/PNG%20%E5%9B%BE%E5%83%8F-ED74F8B45DB3-1.png" alt="PNG 图像-ED74F8B45DB3-1"/><br/>
在这三个方法中，通过计算需要使用的空间，原子操作（<code>n := atomic.AddUint32(&amp;s.n, l)</code>）增加<code>Arena.n</code>的值，从而实现高效的并发安全写操作。</p>

<hr/>

<h5 id="toc_2">Put</h5>

<p><code>newNode()</code>展示了一个新的节点如何存储到<code>arena</code>中，然而未将节点置入 Skiplist 中，回到<code>skl.go</code>中，观察<code>Skiplist.Put</code>方法，了解键值对存储流程。</p>

<pre><code class="language-go">func (s *Skiplist) Put(key []byte, v y.ValueStruct) {

    listHeight := s.getHeight()
    var prev [maxHeight + 1]*node
    var next [maxHeight + 1]*node
    prev[listHeight] = s.head
    next[listHeight] = nil
    for i := int(listHeight) - 1; i &gt;= 0; i-- {
        // Use higher level to speed up for current level.
        prev[i], next[i] = s.findSpliceForLevel(key, prev[i+1], i)
        if prev[i] == next[i] {
            prev[i].setValue(s.arena, v)
            return
        }
    }
    // ...more
</code></pre>

<p><code>Put</code>方法分成两部分，上方代码是当前<code>key</code>已存在，采取直接替换<code>value</code>的方法。下半部分是当前<code>key</code>尚未存在，从而生成新的节点，插入新的键值对节点。</p>

<pre><code class="language-go">    // ...more
    height := randomHeight()    // 随机生成新节点的高度（伯努利试验）
    x := newNode(s.arena, key, v, height) // 生成新的节点

    listHeight = s.getHeight() // 获取当前 Skiplist 高度
    for height &gt; int(listHeight) {
       // 若新节点高度大于当前 Skiplist 高度，原子 CAS 当前 Skiplist 高度
        if atomic.CompareAndSwapInt32(&amp;s.height, listHeight, int32(height)) {
            break
        }
        // 获取新的 Skiplist 高度
        listHeight = s.getHeight()
    }

    for i := 0; i &lt; height; i++ {
        for {
            if prev[i] == nil {
                y.AssertTrue(i &gt; 1)

                prev[i], next[i] = s.findSpliceForLevel(key, s.head, i)

                y.AssertTrue(prev[i] != next[i])
            }
            nextOffset := s.arena.getNodeOffset(next[i])
            x.tower[i] = nextOffset
            if prev[i].casNextOffset(i, nextOffset, s.arena.getNodeOffset(x)) {
                break
            }
            prev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)
            if prev[i] == next[i] {
                y.AssertTruef(i == 0, &quot;Equality can happen only on base level: %d&quot;, i)
                prev[i].setValue(s.arena, v)
                return
            }
        }
    }
}
</code></pre>

<p><code>Put()</code>方法的多个部分都使用了<code>findSpliceForLevel()</code>，其作用是在指定 Skiplist 层级查找给出<code>key</code>的前继节点和后继节点。</p>

<pre><code class="language-go">func (s *Skiplist) findSpliceForLevel(key []byte, before *node, level int) (*node, *node) {
    for {
        next := s.getNext(before, level)
        if next == nil {
            return before, next
        }
        nextKey := next.key(s.arena)
        cmp := y.CompareKeys(key, nextKey)
        if cmp == 0 {
            return next, next
        }
        if cmp &lt; 0 {
            return before, next
        }
        before = next
    }
}
</code></pre>

<p>注意到<code>Put</code>方法在需要生成新节点时，使用了<strong>双层嵌套循环</strong>对节点当前高度所在链表进行更新。</p>

<p>由于在将当前节点设置为前继节点的后继节点是存在<code>CAS</code>操作（<code>prev[i].casNextOffset(i, nextOffset, s.arena.getNodeOffset(x))</code>），当出现对同一个<code>prev[i]</code>进行并发更新时，多个<code>CAS</code> 操作只有一个会成功，对于<strong>更新成功</strong>的一方，直接<code>break</code>即可。而对于<strong>更新失败</strong>，意味着此时其前继或是后继节点将会发生变化，需要重新查找前继和后继节点（<code>prev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)</code>），直到更新成功为止。</p>

<pre><code class="language-go">    for i := 0; i &lt; height; i++ {
        for {
            if prev[i] == nil {
                y.AssertTrue(i &gt; 1)

                prev[i], next[i] = s.findSpliceForLevel(key, s.head, i)

                y.AssertTrue(prev[i] != next[i])
            }
            // 获取后继节点在arena中的偏移量
            nextOffset := s.arena.getNodeOffset(next[i])
            // 设置当前节点的i层链表中的后继节点
            x.tower[i] = nextOffset
            // 通过 CAS 将当前节点替换为前继节点的后继节点
            if prev[i].casNextOffset(i, nextOffset, s.arena.getNodeOffset(x)) {
                break
            }
            // CAS 失败，重新查找当前节点的前继及后继节点
            prev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)
            if prev[i] == next[i] {
                y.AssertTruef(i == 0, &quot;Equality can happen only on base level: %d&quot;, i)
                prev[i].setValue(s.arena, v)
                return
            }
        }
    }
</code></pre>

<h4 id="toc_3">Memtable 总结</h4>

<ul>
<li>Memtable 采用 Skiplist 实现</li>
<li>Skiplist 利用字节数组与偏移量存储<code>node</code>、<code>key</code>和<code>value</code>信息，并利用大量原子操作实现高效并发安全读写操作。</li>
<li><code>arena</code>中的字节数组（<code>buf</code>）在构造时即被固定，在<code>db.go</code>中，<code>arena</code>大小被设置为<code>opt.MaxTableSize + opt.maxBatchSize + opt.maxBatchCount*int64(skl.MaxNodeSize)</code>。</li>
<li>对已存在于<code>memtable</code>中的<code>key</code>进行更新时，仅更新其节点中值在<code>arena.buf</code>中的偏移量，其旧值仍存在与<code>arena.buf</code>中，并不进行回收，从而造成浪费。然而考虑到 LSM 原理，此操作处于可接受的范围。</li>
</ul>

<hr/>

<h3 id="toc_4">Sorted String Table</h3>

<p><code>SST</code> 是只读的，通过<code>package table</code>中的文件及方法，观察<code>SST</code>如何进行序列化/反序列化以及查找。<br/>
<code>badger</code>的<code>SST</code>格式参照了<code>RocksDB</code>，其文档于<a href="https://github.com/google/leveldb/blob/master/doc/table_format.md">table_format</a>，然而<code>badger</code>并不完全遵从<code>RocksDB</code>的做法，在某些地方有些许差异。</p>

<blockquote>
<pre><code class="language-text">(RocksDB Table Format)
&lt;beginning_of_file&gt;
[data block 1]
[data block 2]
...
[data block N]
[meta block 1]
...
[meta block K]
[metaindex block]
[index block]
[Footer]        (fixed size; starts at file_size - sizeof(Footer))
&lt;end_of_file&gt;
</code></pre>
</blockquote>

<h4 id="toc_5">Builder</h4>

<p>首先观察一个<code>Memtable</code>是如何变为<code>SST</code>的。在<code>badger</code>中，通过<code>table/builder.go</code>将<code>Memtable</code>中的所有<code>key/value pairs</code>序列化。</p>

<p><code>type Builder struct</code></p>

<pre><code class="language-go">type Builder struct {
    counter int // 当前 block 已经写入多少个 key

    buf *bytes.Buffer // 存储Table的buffer

    baseKey    []byte // 当前block的第一个key
    baseOffset uint32 // 当前block相对于整个buf的偏移量

    restarts []uint32 // 所有blocks的baseOffset

    prevOffset uint32 // 上一个键值对在当前block中的偏移量

    keyBuf   *bytes.Buffer // 存储所有key的buffer，用于构造布隆过滤器
    keyCount int // Table key 总量
}
</code></pre>

<p><code>Builder</code>首先通过<code>NewTableBuilder</code>创建一个实例</p>

<pre><code class="language-go">func NewTableBuilder() *Builder {
    return &amp;Builder{
        keyBuf:     newBuffer(1 &lt;&lt; 20),
        buf:        newBuffer(1 &lt;&lt; 20),
        prevOffset: math.MaxUint32, // Used for the first element!
    }
}
</code></pre>

<p>通过<code>Add()</code>方法观察一个键值对是如何置入<code>Builder</code>中的</p>

<pre><code class="language-go">func (b *Builder) Add(key []byte, value y.ValueStruct) error {
    if b.counter &gt;= restartInterval {
        b.finishBlock()
        b.restarts = append(b.restarts, uint32(b.buf.Len()))
        b.counter = 0
        b.baseKey = []byte{}
        b.baseOffset = uint32(b.buf.Len())
        b.prevOffset = math.MaxUint32 
    }
    b.addHelper(key, value)
    return nil // Currently, there is no meaningful error.
}
</code></pre>

<p>在<code>Builder</code>中存在着<code>block</code>的概念，一个<code>block</code>是多个键值对的集合，在<code>badger</code>中，每个<code>block</code><strong>默认</strong>最多能存储100个键值对（<code>restartInterval = 100</code>)</p>

<p>跳过<code>Add()</code>方法中添加新<code>block</code>的部分，先看看添加键值对的主逻辑部分<code>addHelper()</code>方法。</p>

<p><code>addHelper()</code>首先将剔除时间戳的<code>keyNoTs</code>（<code>badger</code>中在写入<code>key</code>时会对其添加时间戳<code>Ts</code>）及其长度<code>klen</code>写入<code>keyBuf</code>，<code>keyBuf</code>在<code>Builder</code>生成<code>Table</code>时会被用于构造布隆过滤器，同时递增<code>keyCount</code>。</p>

<pre><code class="language-go">func (b *Builder) addHelper(key []byte, v y.ValueStruct) {
    // Add key to bloom filter.
    if len(key) &gt; 0 {
        var klen [2]byte
        keyNoTs := y.ParseKey(key)
        binary.BigEndian.PutUint16(klen[:], uint16(len(keyNoTs)))
        b.keyBuf.Write(klen[:])
        b.keyBuf.Write(keyNoTs)
        b.keyCount++
    }
    // ...more
</code></pre>

<p>接下来通过<code>keyDiff()</code>方法计算传入<code>key</code>与<code>baseKey</code>从头部开始相差的部分，以节省空间。考虑到 LSM 模型，<strong>有序</strong>遍历Memtable中键值对并<strong>有序</strong>地通过<code>Add()</code>方法添加至<code>Builder</code>并生成<code>SST</code>，<code>diffKey</code>在具有多个相似Key的场景下能节省非常多的空间。</p>

<pre><code class="language-go">    // ...more
    var diffKey []byte
    if len(b.baseKey) == 0 {
        b.baseKey = append(b.baseKey[:0], key...)
        diffKey = key
    } else {
        diffKey = b.keyDiff(key)
    }
    // ...more
</code></pre>

<p>随后针对这个键值对生成<code>header</code>，由于使用了<code>diffKey</code>的理念，<code>plen</code>记录了当前<code>key</code>与<code>baseKey</code>的具有相同前缀的偏移量，并分别保存<code>klen</code>（<code>diffKey</code>长度）、<code>vlen</code>（值长度）及<code>prev</code>（前一个键值对相对于当前<code>block</code>的偏移量）。</p>

<pre><code class="language-go">    // ...more
    h := header{
        plen: uint16(len(key) - len(diffKey)),
        klen: uint16(len(diffKey)),
        vlen: uint16(v.EncodedSize()),
        prev: b.prevOffset, // prevOffset is the location of the last key-value added.
    }
    // 重新计算prevOffset，供下一个键值对使用
    b.prevOffset = uint32(b.buf.Len()) - b.baseOffset 
    // ...more
</code></pre>

<p>最后将<code>header</code>、<code>diffKey</code>和<code>valueStruct</code>写入<code>buf</code>中。</p>

<pre><code class="language-go">    // ...more
    var hbuf [10]byte
    h.Encode(hbuf[:])
    b.buf.Write(hbuf[:])
    b.buf.Write(diffKey) // We only need to store the key difference.

    v.EncodeTo(b.buf)
    b.counter++ // Increment number of keys added for this current block.
}
</code></pre>

<p>一个键值对的结构如下</p>

<pre><code class="language-text">&lt;beginning_of_key_value_pair&gt;
[header]
[diffKey]
[valueStruct]
&lt;end_of_key_value_pair&gt;
</code></pre>

<hr/>

<h5 id="toc_6">block</h5>

<p><code>Builder</code>中使用<code>block</code>的概念组织键值对，就如<code>Add()</code>方法及<code>addHelper()</code>方法中看到的。</p>

<p>在<code>Add()</code>方法中，检测到当前<code>block</code>键值对个数超过了<code>restartInterval</code>，将会建立一个新的<code>block</code></p>

<pre><code class="language-go">    // in Add() method
    if b.counter &gt;= restartInterval {
        b.finishBlock()
        // Start a new block. Initialize the block.
        b.restarts = append(b.restarts, uint32(b.buf.Len()))
        b.counter = 0
        b.baseKey = []byte{}
        b.baseOffset = uint32(b.buf.Len())
        b.prevOffset = math.MaxUint32 // First key-value pair of block has header.prev=MaxInt.
    }
</code></pre>

<p><code>b.finishBlock()</code>函数将在当前<code>block</code>尾部添加一个空键值对，此举利用空键值对记录下<code>prevOffset</code>的位置，用于反向遍历。</p>

<pre><code class="language-go">func (b *Builder) finishBlock() {
    b.addHelper([]byte{}, y.ValueStruct{})
}
</code></pre>

<p><code>Add()</code>方法中在调用<code>b.finishBlock</code>后，通过<code>b.restarts = append(b.restarts, uint32(b.buf.Len()))</code>记录下新<code>block</code>的起始位置，<code>b.restarts</code>会在生成<code>Table</code>时利用其生成<code>block Index</code>。</p>

<p>由此可见一个<code>block</code>的结构如下</p>

<pre><code class="language-text">&lt;beginning_of_block&gt;
[base key/value pair 0]
[key/value pair 1]
...
[key/value pair N]
[empty key/value pair]
&lt;end_of_block&gt;
</code></pre>

<hr/>

<h5 id="toc_7">Finish() 序列化 Table</h5>

<p><code>Builder</code>最后通过<code>Finish()</code>函数序列化生成<code>Table</code>。</p>

<p>首先通过遍历<code>keyBuf</code>获取所有<code>key</code>，随后利用其生成布隆过滤器。</p>

<pre><code class="language-go">func (b *Builder) Finish() []byte {
    bf := bbloom.New(float64(b.keyCount), 0.01)
    var klen [2]byte
    key := make([]byte, 1024)
    for {
        if _, err := b.keyBuf.Read(klen[:]); err == io.EOF {
            break
        } else if err != nil {
            y.Check(err)
        }
        kl := int(binary.BigEndian.Uint16(klen[:]))
        if cap(key) &lt; kl {
            key = make([]byte, 2*int(kl)) // 2 * uint16 will overflow
        }
        key = key[:kl]
        y.Check2(b.keyBuf.Read(key))
        bf.Add(key)
    }
    // ...more
</code></pre>

<p>随后调用<code>b.finishBlock()</code>结束这最后一个<code>block</code></p>

<pre><code class="language-go">    // ...more
    b.finishBlock()
    // ...more
</code></pre>

<p>进而通过<code>b.restarts</code>生成定长<code>block Index</code>的，并将索引写入<code>buf</code></p>

<pre><code class="language-go">    // ...more
    index := b.blockIndex()
    b.buf.Write(index)
    // ...more
</code></pre>

<blockquote>
<p><code>blockIndex()</code>，通过<code>b.restarts</code>生成<code>block</code>所在偏移量的索引，并在末尾添加索引总长度。</p>

<pre><code class="language-go">func (b *Builder) blockIndex() []byte {
    // Store the end offset, so we know the length of the final block.
    b.restarts = append(b.restarts, uint32(b.buf.Len()))
    // Add 4 because we want to write out number of restarts at the end.
    sz := 4*len(b.restarts) + 4
    out := make([]byte, sz)
    buf := out
    for _, r := range b.restarts {
        binary.BigEndian.PutUint32(buf[:4], r)
        buf = buf[4:]
    }
    binary.BigEndian.PutUint32(buf[:4], uint32(len(b.restarts)))
    return out
}
</code></pre>

<p>由次可见，<code>block Index</code>的格式如下</p>

<pre><code class="language-text">&lt;beginning_of_block_index&gt;
[block 0 offset]
[block 1 offset]
...
[block N offset]
[block Index size]
&lt;end_of_block_index&gt;
</code></pre>
</blockquote>

<p>最后是序列化布隆过滤器，并将布隆过滤器长度写入<code>buf</code><strong>末尾的4个字节</strong>中，返回<code>buf.Bytes()</code></p>

<pre><code class="language-go">    // ...more
    bdata := bf.JSONMarshal()
    n, err := b.buf.Write(bdata)
    y.Check(err)
    var buf [4]byte
    binary.BigEndian.PutUint32(buf[:], uint32(n))
    b.buf.Write(buf[:])

    return b.buf.Bytes()
}
</code></pre>

<p>从而获得一个如下格式的序列化后的 Table</p>

<pre><code class="language-go">&lt;beginning_of_table&gt;
[data block 0]
[data block 1]
...
[data block N]
[block index]
[block index size (4 bytes)]
[bloom filter]
[bloom filter size (4 bytes)]
&lt;end_of_table&gt;
</code></pre>

<p>可以看出，就目前的<code>Table</code>格式而言，在<code>block</code>内部无法进行二分查找，只能遍历对应<code>block</code>找出对应的<code>key</code>，但是目前已有 Pull request <a href="https://github.com/dgraph-io/badger/pull/481">block iterator: seek with binary search</a> 解决此问题，为了行文流畅，本文暂不探讨此PR。</p>

<hr/>

<h4 id="toc_8">Table</h4>

<p><code>Builder</code>通过<code>Finish()</code>生成序列化后的<code>Table</code>，随后会被写入<code>.sst</code>文件中，此时再通过<code>Table.open()</code>打开该文件，从而使得<code>.sst</code>文件能进行查找及合并等操作。</p>

<p><code>type Table struct</code></p>

<pre><code class="language-go">type Table struct {
    sync.Mutex

    fd        *os.File //  文件指针
    tableSize int      // .sst文件大小

    blockIndex []keyOffset
    ref        int32 // For file garbage collection.  Atomic.

    loadingMode options.FileLoadingMode
    mmap        []byte // 通过mmap方式

    smallest, biggest []byte // 该.sst文件的最小及最大的key
    id                uint64 // .sst文件id

    bf bbloom.Bloom // 布隆过滤器
}
</code></pre>

<h5 id="toc_9">OpenTable()</h5>

<p>通过<code>OpenTable()</code>函数反序列化并构造出Table，首先是获取传入文件的信息，获取<code>.sst</code>文件的<code>id</code>、<code>size</code>，并构造<code>Table</code>结构体。</p>

<pre><code class="language-go">func OpenTable(fd *os.File, loadingMode options.FileLoadingMode) (*Table, error) {
    fileInfo, err := fd.Stat()
    if err != nil {
        // It&#39;s OK to ignore fd.Close() errs in this function because we have only read
        // from the file.
        _ = fd.Close()
        return nil, y.Wrap(err)
    }

    filename := fileInfo.Name()
    id, ok := ParseFileID(filename)
    if !ok {
        _ = fd.Close()
        return nil, errors.Errorf(&quot;Invalid filename: %s&quot;, filename)
    }
    t := &amp;Table{
        fd:          fd,
        ref:         1, // Caller is given one reference.
        id:          id,
        loadingMode: loadingMode,
    }
    
    t.tableSize = int(fileInfo.Size())
    // ...more
</code></pre>

<p>随后根据<code>loadingMode</code>决定使用<code>mmap</code>或是载入内存的方式将<code>fd</code>中数据读入<code>table</code>中，无论是那种模式，都是将数据转换为<code>[]byte</code>指针，对后续操作<strong>大多数</strong>都是透明的。</p>

<pre><code class="language-go">    // ...more
    if loadingMode == options.MemoryMap {
        t.mmap, err = y.Mmap(fd, false, fileInfo.Size())
        if err != nil {
            _ = fd.Close()
            return nil, y.Wrapf(err, &quot;Unable to map file&quot;)
        }
    } else if loadingMode == options.LoadToRAM {
        err = t.loadToRAM()
        if err != nil {
            _ = fd.Close()
            return nil, y.Wrap(err)
        }
    }
    // ...more
</code></pre>

<p>随后从文件中读入索引，<code>t.readIndex()</code>函数将会载入布隆过滤器并赋值到<code>Table.bf</code>中，解析<code>block Index</code>并根据索引获取每个<code>block</code>的首个<code>key</code>并赋值到<code>Table.blockIndex</code>中。</p>

<pre><code class="language-go">    // ...more
    if err := t.readIndex(); err != nil {
        return nil, y.Wrap(err)
    }
    // ...more
</code></pre>

<p>最后获取该<code>Table</code>的最大及最小值。</p>

<pre><code class="language-go">    // ...more
    it := t.NewIterator(false)
    defer it.Close()
    it.Rewind()
    if it.Valid() {
        t.smallest = it.Key()
    }

    it2 := t.NewIterator(true)
    defer it2.Close()
    it2.Rewind()
    if it2.Valid() {
        t.biggest = it2.Key()
    }
    return t, nil
}
</code></pre>

<hr/>

<h4 id="toc_10">Iterator</h4>

<p><code>Iterator</code>分别有<code>Block Iterator</code>、<code>Table Iterator</code>以及<code>Concat Iterator</code>。</p>

<h5 id="toc_11">Block Iterator</h5>

<p><code>block iterator</code>是针对单个<code>block</code>内部的迭代器。</p>

<pre><code class="language-go">type blockIterator struct {
    data    []byte
    pos     uint32
    err     error
    baseKey []byte

    key  []byte
    val  []byte
    init bool

    last header // The last header we saw.
}
</code></pre>

<p><code>block iterator</code>中最重要的是<code>Seek()</code>函数，用于查找需要的键。由于<code>block</code>内部的键值对是以<strong>有序双向列表</strong>，但也如前文所述，即使是有序的列表，<code>block</code>并没有提供足够的信息用于进行二分查找，从而只能使用遍历的方式查找对应的<code>key</code>。</p>

<p>同时，<code>Seek()</code>函数由于其函数名语义，并没有直接返回可能存在的键值对，又由于<code>block</code>内部的键值对按照从小到大排序，<code>Seek()</code>将该<code>iterator</code>定位到<strong>最接近</strong>该键的位置（<code>y.CompareKeys(k, key) &gt;= 0</code>），而判断该位置的键值对是否相等则交由调用者解决。</p>

<pre><code class="language-go">func (itr *blockIterator) Seek(key []byte, whence int) {
    itr.err = nil

    switch whence {
    case origin:
        itr.Reset()
    case current:
    }

    var done bool
    for itr.Init(); itr.Valid(); itr.Next() { // 通过iter迭代器遍历block内部的key
        k := itr.Key() // 获取 key
        if y.CompareKeys(k, key) &gt;= 0 {
            done = true
            break
        }
    }
    if !done {
        itr.err = io.EOF
    }
}
</code></pre>

<hr/>

<h5 id="toc_12">Table Iterator</h5>

<p><code>Table Iterator</code>是针对单个<code>Table</code>的迭代器。一个<code>Table</code>内部有多<code>block</code>，<code>block</code>不仅内部是有序的，多个<code>block</code>相互之间也是单调递增的，同时也有<code>block Index</code>有序地记录了各个<code>block</code>的<code>baseKey</code>的偏移量。</p>

<pre><code class="language-go">type Iterator struct {
    t    *Table // 迭代器对应的Table
    bpos int    // 目前迭代的block索引
    bi   *blockIterator // 对应block的迭代器
    err  error

    reversed bool // 是否反向遍历
}
</code></pre>

<p><code>Table Iterator</code>的<code>Seek()</code>就利用了<code>block Index</code>进行二分查找，快速定位<code>key</code>所在<code>block</code>。</p>

<pre><code class="language-go">func (itr *Iterator) Seek(key []byte) {
    if !itr.reversed {
        itr.seek(key)
    } else {
        itr.seekForPrev(key)
    }
}
</code></pre>

<p>关注正向遍历<code>itr.seek()</code>，<code>origin</code>指示初始化迭代器再进行遍历。</p>

<pre><code class="language-go">func (itr *Iterator) seek(key []byte) {
    itr.seekFrom(key, origin)
}
</code></pre>

<p><code>seekFrom</code>函数通过二分查找定位出<code>key</code>可能所在的<strong>后一个</strong><code>block</code>索引，然后通过<code>seekHelper</code>定位该<code>key</code>。</p>

<pre><code class="language-go">func (itr *Iterator) seekFrom(key []byte, whence int) {
    itr.err = nil
    switch whence {
    case origin:
        itr.reset()
    case current:
    }

    idx := sort.Search(len(itr.t.blockIndex), func(idx int) bool {
        ko := itr.t.blockIndex[idx]
        return y.CompareKeys(ko.key, key) &gt; 0 // 没有使用 &gt;= 0，从而对baseKey == key 情况也能使用相同的 itr.seekHelper(idx-1, key) 逻辑处理。
    })
    if idx == 0 {
        // idx 等于 0 说明该 Table 的最小的键也大于需要查找的 key
        itr.seekHelper(0, key) // 相当于 seekToFirst()
        return
    }
    itr.seekHelper(idx-1, key) // 在前一个block查找该key
    if itr.err == io.EOF { // 此测试为真即代表该key不存在
        if idx == len(itr.t.blockIndex) {
            return
        }
        itr.seekHelper(idx, key) // seekHelper 实际调用了 blockIterator.Seek 函数，由于查找失败会导致 blockIterator 触底，此处用于跳转至下一个block
    }
}
</code></pre>

<p><code>seekHelper()</code>用于获取并在对应<code>block</code>中查找<code>key</code>。</p>

<pre><code class="language-go">func (itr *Iterator) seekHelper(blockIdx int, key []byte) {
    itr.bpos = blockIdx
    block, err := itr.t.block(blockIdx)
    if err != nil {
        itr.err = err
        return
    }
    itr.bi = block.NewIterator()
    itr.bi.Seek(key, origin)
    itr.err = itr.bi.Error()
}
</code></pre>

<hr/>

<h6 id="toc_13">Concat Iterator</h6>

<p><code>Concat Iterator</code>是多个<code>Table</code>的遍历器，从它的实现来看，要求多个<code>Table</code>相互之间是有序的。</p>

<pre><code class="language-go">type ConcatIterator struct {
    idx      int // 当前使用的迭代器索引
    cur      *Iterator // 当前使用的迭代器
    iters    []*Iterator // 对应着各个Table
    tables   []*Table    // 以升序排列的各个Table
    reversed bool
}
</code></pre>

<p>同样是<code>Seek()</code>操作，展示<code>Concat Iterator</code>是如何搜索一个 key 的。</p>

<p>由于<code>ConcatIterator.Seek()</code>函数使用了二分搜索，所以必须由调用者保证<code>tables</code>是有序的。</p>

<p><code>Seek()</code>同样具有<code>reversed</code>的功能，但在这里只关注正向查找的功能。<code>Seek()</code>首先在各个<code>table</code>中使用二分搜索，查找出<code>key</code>所在的<code>table</code>，继而通过该<code>table</code>的<code>Iterator.Seek()</code>在该<code>Table</code>内继续查找<code>key</code>。</p>

<pre><code class="language-go">func (s *ConcatIterator) Seek(key []byte) {
    var idx int
    if !s.reversed {
        idx = sort.Search(len(s.tables), func(i int) bool {
            return y.CompareKeys(s.tables[i].Biggest(), key) &gt;= 0
        })
    } else {
        n := len(s.tables)
        idx = n - 1 - sort.Search(n, func(i int) bool {
            return y.CompareKeys(s.tables[n-1-i].Smallest(), key) &lt;= 0
        })
    }
    if idx &gt;= len(s.tables) || idx &lt; 0 {
        s.setIdx(-1)
        return
    }
    s.setIdx(idx)
    s.cur.Seek(key)
}
</code></pre>

<h3 id="toc_14">写在最后</h3>

<p>Part 1 剖析了 Memtable 以及 Sorted String Table 的结构，LSM 即由这两种结构组成。下一节继续探讨 Memtable 转换至 Sorted String Table 以及 Sorted String Table 之间的整合压缩<code>Compaction</code>过程。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第九章]]></title>
    <link href="zerolocusta.github.io/15127920862405.html"/>
    <updated>2017-12-09T12:01:26+08:00</updated>
    <id>zerolocusta.github.io/15127920862405.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Advanced Asynchronous Recipes</h2>

<p>如何利用一些高级的异步概念去改善我们饿 NodeJS 程序，这一章会介绍例如</p>

<ul>
<li>如何处理需要异步初始化的模块</li>
<li>如何利用少量的代价引入批量异步操作与缓存异步操作，从而获得性能提升</li>
<li>如何处理计算密集型的操作</li>
</ul>

<h3 id="toc_1">Requiring asynchronously initialized modules</h3>

<p>实际开发中存在不少需要异步初始化的模块，例如数据库客户端模块就是一个。只有在数据库连接完成后才可以进行操作。<br/>
  然而 NodeJS 的模块系统是同步的，在引入的一刻就可以被其他代码所使用了，这也就造成了模块初始化完成之前极有可能被其他代码使用，从而引起UB。</p>

<h4 id="toc_2">Canonical solutions</h4>

<p>为了说明这个问题以及它的解决方案，这里引入一个 db 模块例子，这个模块需要在连接上远程的数据库之后才能开始处理请求。</p>

<h5 id="toc_3">利用 EventEmitter 实现异步初始化模块调用</h5>

<p>以下代码假设 aDb 是需要异步初始化的模块</p>

<pre><code class="language-js">const db = require(&#39;aDb&#39;) // aDb是需要异步初始化的模块

function runFind(type, callback) {
    db.find(type, callback);
}

module.exports = function findAll(type, callback) {

  if (db.connected) {    // 检测db是否已经初始化完成
    runFind(type, callback); // 初始化完毕则直接调用查询函数
  } else {
    // 未初始化完毕则柯里化参数并订阅 connected 事件
    db.once(&#39;connected&#39;, runFind.bind(this, type, callback));
  }

}
</code></pre>

<p>上面这段代码利用了 EventEmitter 实现在数据库未初始化完毕的时候，模块函数被调用时，使用 once 函数订阅事件，而在模块初始化完毕后的调用则直接查询数据库。</p>

<h5 id="toc_4">利用 DI 实现异步初始化模块调用</h5>

<p>依赖注入利用反向注入已初始化的数据库模块至数据库API，从而实现初始化后才接受请求</p>

<pre><code class="language-js">// 在 findAll.js 中
module.exports = function(db) { // 依赖外部注入已经初始化完成的db
    return function findAll(type, callback) [
        db.findAll(type, callback);
    }
}
</code></pre>

<pre><code class="language-js">// 在 app.js 中
const db = require(&#39;aDb&#39;) //异步初始化的数据库模块
const findAllFactory = require(&#39;findAll&#39;);

db.on(&#39;connected&#39;, function() {
    // 订阅 connected 事件，在 db 初始化完成时注入
    const findAll = findAllFactory(db);
});
</code></pre>

<p>然而 DI 解决异步模块初始化的方法看起来很别扭（根本原因在于 NodeJS 并不能很好地应用这种风格），并且 DI 在日益增长的代码项目会慢慢变得庞大且难以维护。</p>

<h4 id="toc_5">Preinitialization queues</h4>

<p>总的来说，以上两种方法都不是很好。这里引入一种 Preinitialization queues 技巧，核心思想是利用<strong>队列</strong>，将模块初始化完成前的操作缓存起来，然后在模块初始化完成时按顺序执行队列中的操作。</p>

<p>在引入 Preinitialization queues 之前，先说明一个 asyncModule，以便之后针对这个异步初始化模块应用 Preinitialization queues 技术。</p>

<pre><code class="language-js">// asyncModule.js
&quot;use strict&quot;;

const asyncModule = {};

asyncModule.initialized = false;
asyncModule.initialize = callback =&gt; {
  setTimeout(() =&gt; {
    // 设置10秒后初始化状态为true
    asyncModule.initialized = true;
    callback();
  }, 10000);
};

asyncModule.tellMeSomething = callback =&gt; {
  process.nextTick(() =&gt; {
    if(!asyncModule.initialized) {
      // 检查模块初始化状态
      return callback(
        // 未初始化则返回Error
        new Error(&#39;I don\&#39;t have anything to say right now&#39;)
      );
    }
    // 初始化完成则返回 &#39;Current time is: &#39; + new Date() 字符串
    callback(null, &#39;Current time is: &#39; + new Date());
  });
};

module.exports = asyncModule;
</code></pre>

<p>然后使用  Preinitialization queues  技术，利用 asyncModuleWrap 封装 asyncModule</p>

<pre><code class="language-js">&quot;use strict&quot;;

const asyncModule = require(&#39;./asyncModule&#39;);

//The wrapper
const asyncModuleWrapper = {}
// 设置 模块的初始化状态为 false
asyncModuleWrapper.initialized = false;
// asyncModule.initialize 的钩子
asyncModuleWrapper.initialize = function() {
  // 在目前的状态中调用 initialize
  activeState.initialize.apply(activeState, arguments);
};
// asyncModule.tellMeSomething 的钩子
asyncModuleWrapper.tellMeSomething = function() {
  // 在目前的状态中调用 tellMeSomething
  activeState.tellMeSomething.apply(activeState, arguments);
};
// pending 队列用于存放在模块未初始化完成时的调用信息
let pending = [];
// notInitializedState 用于模拟 asyncModule
// 在 asyncModule 初始化完毕前替换它并缓存操作
let notInitializedState = {

  initialize: function(callback) {
    asyncModule.initialize(function() {
      // 初始化完毕设置状态为 true
      asyncModuleWrapper.initalized = true;
      // 目前的状态为 activeState
      activeState = initializedState;
      // 执行模块初始化完成前的所有 函数调用 
      pending.forEach(function(req) {
        asyncModule[req.method].apply(null, req.args);
      });
      // 重置队列
      pending = [];
      // 调用回调函数
      callback();
    });
  },
  
  tellMeSomething: function(callback) {
    // 此处添加log， 用于观察初始化前此函数被调用次数
    console.log(&#39;Call NotInitializedState tellMeSomething()&#39;);
    // 由于模块仍未初始化完成
    // 此时缓存函数调用参数并放入 pending 队列
    return pending.push({
      method: &#39;tellMeSomething&#39;,
      args: arguments
    });
  }
  
};

// initializedState 用于指代已经初始化完毕的 asyncModule
let initializedState = asyncModule;

// activeState 的初始化状态为 notInitializedState
let activeState = notInitializedState;

module.exports = asyncModuleWrapper;
</code></pre>

<h5 id="toc_6">Preinitialization queues 的核心思想</h5>

<p>hook 所有依赖模块初始化状态的函数，并且记录每一次模块初始化前的函数调用及其参数。在初始化完毕后执行所有挂起的函数函数调用，并解除 hook。</p>

<h3 id="toc_7">Asynchronous batching and caching</h3>

<p>在一些高吞吐量的服务中，<strong>缓存</strong>往往能优化服务性能，并且减少资源的消耗。这一节阐述如何方便地在异步操作上应用 Cache ，从而大幅提高吞吐量。</p>

<h4 id="toc_8">Implementing a server with no caching or batching</h4>

<p>为了说明没有缓存的服务和带缓存的服务之间的性能差别，这一节将会分别实现两种服务。</p>

<p>假设这个服务器将会在数据库中存储一种模型为<code>{transactionId: {amount, item}}</code>的JSON，而我们将会实现一个<code>totalSales(item, callback)</code>接口，这个接口将会搜索数据库中所有<code>transactionId.item === item</code>的元素，然后计算总数并通过 callback 返回。</p>

<p>通过数据模型可以看出，对于查询 item 的操作如果没有数据库直接支持，我们只能遍历所有数据并找出对应的item项，最后输出统计信息。</p>

<h5 id="toc_9">Asynchronous operation without caching and batching</h5>

<p>无缓存及批量操作的服务</p>

<pre><code class="language-js">&quot;use strict&quot;;
// 利用 leveldb 存储数据
const level = require(&#39;level&#39;);
const sublevel = require(&#39;level-sublevel&#39;);

const db = sublevel(level(&#39;example-db&#39;, {valueEncoding: &#39;json&#39;}));
const salesDb = db.sublevel(&#39;sales&#39;);

module.exports = function totalSales(item, callback) {
  console.log(&#39;totalSales() invoked&#39;);
  // 初始化 sum
  let sum = 0;
  salesDb.createValueStream()
    .on(&#39;data&#39;, data =&gt; {
      // 如果item为空，则统计数据库所有数据
      if(!item || data.item === item) {
        sum += data.amount;
      }
    })
    .on(&#39;end&#39;, () =&gt; {
      // 结束时回调
      callback(null, sum);
    });
};
</code></pre>

<p>以及为这个服务建立一个简单的HTTP透传服务。</p>

<pre><code class="language-js">&quot;use strict&quot;;

const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const totalSales = require(&#39;./totalSales&#39;);

http.createServer((req, res) =&gt; {
  const query = url.parse(req.url, true).query;
  totalSales(query.item, (err, sum) =&gt; {
    res.writeHead(200);
    res.end(`Total sales for item ${query.item} is ${sum}`);
  });
}).listen(8000, () =&gt; console.log(&#39;Started&#39;));
</code></pre>

<p>最后将会通过脚本往数据库中插入100K条数据，并通过一个test客户端，以200ms为间隔发出20个<strong>相同的</strong>请求，测试该服务器的耗时。<br/>
（测试结果）<br/>
<img src="media/15127920862405/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-14%20%E4%B8%8B%E5%8D%8811.07.41.png" alt="屏幕快照 2017-12-14 下午11.07.41"/></p>

<p>目前的模式是每次请求都重新查找一遍数据库（也有可能某些包引入优先级缓存）。</p>

<h5 id="toc_10">Asynchronous operation with batching</h5>

<p>对于20个<strong>相同的</strong>请求，服务查询返回<strong>完全</strong>相同的结果。<br/>
<img src="media/15127920862405/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-14%20%E4%B8%8B%E5%8D%8811.33.18.png" alt="屏幕快照 2017-12-14 下午11.33.18"/></p>

<p>这里尝试在服务端引入<strong>批处理（Batching）</strong>技术。</p>

<p>由于此服务的查询是由 item 作为条件查询出统计结果的，这里根据查询条件 item 作为批处理汇聚的 key。</p>

<pre><code class="language-js">&quot;use strict&quot;;

const totalSales = require(&#39;./totalSales&#39;);

const queues = {};
module.exports = function totalSalesBatch(item, callback) {
  // 在首次或 totalSales 完成时 调用 totalSalesBatch
  // queues[item]将为空
  // 而在当前 totalSales 未完成时，则会将回调函数推入对应的 queue
  // 从而汇聚一段时间内（totalSales查询时间）的相同查询。
  if(queues[item]) {
    console.log(&#39;Batching operation&#39;);
    return queues[item].push(callback);
  }
  
  // 初始化 Batching Queue
  queues[item] = [callback];
  totalSales(item, (err, res) =&gt; {
    // 在 totalSales 完成时，取出对应的 Batching Queue
    const queue = queues[item];
    // 将查询条件 item 对应的 Batching Queue 清除
    queues[item] = null; 
    // 回调所有 callback
    queue.forEach(cb =&gt; cb(err, res));
  });
};
</code></pre>

<p>上面这段代码创建了一个 totalSales 的代理，并且将请求汇聚。</p>

<p>（测试结果）<br/>
<img src="media/15127920862405/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-14%20%E4%B8%8B%E5%8D%8811.53.10.png" alt="屏幕快照 2017-12-14 下午11.53.10"/></p>

<p>很明显耗时少了一倍！<br/>
<img src="media/15127920862405/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-14%20%E4%B8%8B%E5%8D%8811.54.22.png" alt="屏幕快照 2017-12-14 下午11.54.22"/></p>

<h5 id="toc_11">Asynchronous operation caching</h5>

<p>上面的 Batching 对于需要长时间处理的操作很友好，但是如果是一些简单快速的API，可能在下一个相同操作请求进来之前就执行完了，这样就没有办法做到优化。<br/>
如果一个 API 获取的数据不需要实时性，可以利用 Caching 去优化查询，从而减少耗时。</p>

<p>以下的代码将 Batching 与 Caching 结合起来</p>

<pre><code class="language-js">&quot;use strict&quot;;

const totalSales = require(&#39;./totalSales&#39;);
// Batch Queue 
const queues = {};
// 缓存对象 
const cache = {};

module.exports = function totalSalesBatch(item, callback) {
  // 尝试从缓存中取出数据
  const cached = cache[item];
  if (cached) {
    // 如果缓存中数据存在则返回该数据
    console.log(&#39;Cache hit&#39;);
    // 保持接口一致性，异步返回该数据
    return process.nextTick(callback.bind(null, null, cached));
  }
  // 以下大部分与 Batching Request 相同
  if (queues[item]) {
    console.log(&#39;Batching operation&#39;);
    return queues[item].push(callback);
  }
  
  queues[item] = [callback];
  totalSales(item, (err, res) =&gt; {
    if (!err) {
      // 查询成功将结果放入缓存
      cache[item] = res;
      setTimeout(() =&gt; {
        // 设置超时，在既定时间后删除该缓存
        delete cache[item];
      }, 30 * 1000); //30 seconds expiry
    }
    
    const queue = queues[item];
    queues[item] = null;
    queue.forEach(cb =&gt; cb(err, res));
  });
};
</code></pre>

<p><strong>使用 Caching 要注意的是要保持异步接口的一致性，参考第二章中提到的 Unleashing Zalgo。</strong></p>

<p><img src="media/15127920862405/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-17%20%E4%B8%8A%E5%8D%8811.42.57.png" alt="屏幕快照 2017-12-17 上午11.42.57"/></p>

<p>运行结果</p>

<p><img src="media/15127920862405/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-17%20%E4%B8%8A%E5%8D%8811.45.15.png" alt="屏幕快照 2017-12-17 上午11.45.15"/></p>

<h3 id="toc_12">Running CPU-bound tasks</h3>

<p>相比起 IO密集型 的 Nodejs 应用， CPU密集型的应用无法利用事件循环处理耗时的计算任务，造成整个Nodejs进程的阻塞。</p>

<p>假设一种计算任务，需要在集合 \(S\) 中查找其所有子集 \(S_{1}\),\(S_{2}\)...\(S_{n}\) 中，子集中的和 \(\sum S_{x}\) 等于给定的数 sum。例如要就找出集合 <code>[1, 2, -4, 5, -3]</code> 中所有子集中和为 0 的子集，其中就有 <code>[1, 2, -3]</code> 与 <code>[2, -4, 5, -3]</code> 等满足条件。</p>

<p>如果不考虑算法上的优化（动态规划可将时间复杂度优化至\(O(N!)\))，其时间复杂度达到了 \(O(2^n)\)，即使是简单的30个元素的集合，计算复杂度也达到了\(2^{30}\)。</p>

<p>在解释如何在 Nodejs 中规避 CPU密集型 任务带来的进程阻塞问题之前，首先实现一个 计算集合中所有子集并查找出和为给定数 的工具吧。</p>

<pre><code class="language-js">// subsetSum.js

&quot;use strict&quot;;

const EventEmitter = require(&#39;events&#39;).EventEmitter;

class SubsetSum extends EventEmitter {
  // 构造函数中指定 sum 和 需要查找的 set
  constructor(sum, set) {
    super();
    this.sum = sum;
    this.set = set;
    this.totalSubsets = 0;
  }

  _combine(set, subset) {
    for(let i = 0; i &lt; set.length; i++) {
      // 扩大子集的范围，形成 newSubSet
      let newSubset = subset.concat(set[i]);
      // 递归调用 _combine，生成原始集合中所有子集
      this._combine(set.slice(i + 1), newSubset);
      // 查找出所有子集
      this._processSubset(newSubset);
    }
  }

  _processSubset(subset) {
    console.log(&#39;Subset&#39;, ++this.totalSubsets, subset);
    // 化约集合中元素，计算总和
    const res = subset.reduce((prev, item) =&gt; (prev + item), 0);
    if(res == this.sum) {
      // 发送事件
      this.emit(&#39;match&#39;, subset);
    }
  }

  start() {
    // 初始调用combine
    console.time();
    this._combine(this.set, []);
    this.emit(&#39;end&#39;);
    console.timeEnd();
  }
}

module.exports = SubsetSum;
</code></pre>

<p>假设我们以<code>[116,119,101,101,-116,109,101,-105,-102,117,-115,-97,119,-116,-104,-105,115]</code>作为需要计算的集合，并且 sum 为0，最终耗时是 5991.757ms，也就是Nodejs进程接近 6s 的时间内无法响应其他任务，都被阻塞在计算任务这里了。</p>

<h4 id="toc_13">Interleaving with setImmediate</h4>

<p>在单线程情况下，计算的总耗时无法逃避，但是可以利用 <strong>分时分片计算</strong> 策略，减少 <strong>连续阻塞</strong> 的时间，同时利用 Stream 的特性，将已计算完成的部分返回到客户端处。</p>

<p>利用 setImmediate(callback) 将部分计算任务延缓到下一轮的 event loop 中，setImmediate(callback) 会将传入的 callback函数 推入<strong>队列\({^1}\)中</strong> 延缓到 I/O callback 后执行所有在<strong>队列\({^1}\)</strong>中的 callbacks ，如果 callbacks 中调用了 setImmediate(\(callback{}^2\))，<br/>
这些\(callback{}^2\)将会延缓到下一轮 event loop 的 I/O callback 中执行。</p>

<pre><code class="language-js">// subsetSumDefer.js
&quot;use strict&quot;;

const EventEmitter = require(&#39;events&#39;).EventEmitter;

class SubsetSumDefer extends EventEmitter {
  constructor(sum, set) {
    super();
    this.sum = sum;
    this.set = set;
    this.totalSubsets = 0;
  }

  _combineInterleaved(set, subset) {
    // runningCombine 用于记录是否还有计算任务需要执行
    this.runningCombine++;
    setImmediate(() =&gt; {
      // 将 _combine 任务延缓到下一轮事件循环的 I/O callback 中执行
      this._combine(set, subset);
      if(--this.runningCombine === 0) {
        // combine 完成 runningCombine - 1
        // 如果 runningCombine 为 0，通知外部消费者执行结束
        this.emit(&#39;end&#39;);
      }
    });
  }

  _combine(set, subset) {
    for(let i = 0; i &lt; set.length; i++) {
      let newSubset = subset.concat(set[i]);
      // 每次只计算少量的任务
      this._combineInterleaved(set.slice(i + 1), newSubset);
      this._processSubset(newSubset);
    }
  }

  _processSubset(subset) {
    console.log(&#39;Subset&#39;, ++this.totalSubsets, subset);
    const res = subset.reduce((prev, item) =&gt; prev + item, 0);
    if(res == this.sum) {
      // 每发现符合的集合，就像外部消费者发送结果
      // 从而利用 Stream 的特性将部分以计算结果返回到客户端
      this.emit(&#39;match&#39;, subset);
    }
  }

  start() {
    this.runningCombine = 0;
    this._combineInterleaved(this.set, []);
  }
}

module.exports = SubsetSumDefer;
</code></pre>

<p>最后总耗时是在 7129 ms，虽然对于单个连接来说，总计算时间长了，但是以计算数据是实时回显的，并且在计算过程中，Nodejs主循环仍然能处理其他 I/O 时间，总体来说是一个可以接受的方案。</p>

<h4 id="toc_14">Using multiple processes</h4>

<pre><code>本章节中书中实例代码实现并不完全正确，有可能造成错过子进程信息，代码已经过改造
</code></pre>

<p>Defer 的 分时分片计算策略虽然好，但如果同时涌入多个计算请求，每次 setImmediate 叠加的计算任务过多，还是会将当前线程长时间阻塞。</p>

<p>为了解决这个问题，引入进程池，将计算任务分发到别的进程中，从而将处理请求的 I/O 进程从计算任务中解放出来。</p>

<p>要利用进程池解决计算密集型的问题，首先从实现一个 进程池 开始。</p>

<h5 id="toc_15">Implementing a process pool</h5>

<p>进程池有两个接口，一是 acquire(callback)，将空闲 worker 进程通过 callback 传递，二是 release(worker)，将 worker 放回进程池。</p>

<pre><code class="language-js">&quot;use strict&quot;;

const fork = require(&#39;child_process&#39;).fork;

class ProcessPool {
  constructor(file, poolMax) {
    this.file = file;
    this.poolMax = poolMax;
    // pool 队列用于存放空闲的 worker 进程
    this.pool = [];
    // 记录当前正在计算的 worker 进程
    this.active = [];
    // 用于存放计算任务
    this.waiting = [];
  }
  // 用于从 进程池 中获取 worker
  acquire(callback) {
    let worker;
    if (this.pool.length &gt; 0) {
      // 如果进程池中已有可用的 worker
      // 从进程池中获取空闲 worker
      worker = this.pool.pop();
      // 将 worker 推入 active 队列
      this.active.push(worker);
      // 最后通过 callback 传递 worker
      return process.nextTick(callback.bind(null, null, worker));
    }
    // 如果活跃进程已达 进程池上限，将 callback 推入等待队列
    if (this.active.length &gt;= this.poolMax) {
      return this.waiting.push(callback);
    }
    // fork 工作进程
    worker = fork(this.file);
    this.active.push(worker);
    // 保持异步操作特性
    process.nextTick(callback.bind(null, null, worker));
  }
  // 用于释放工作进程，归还至进程池
  release(worker) {
    if (this.waiting.length &gt; 0) {
      // 调用 release 表示该 worker 空闲，
      const waitingCallback = this.waiting.shift();
      // 将 worker 传递到 等待中的 callback
      waitingCallback(null, worker);
    }
    // 将 worker 从 活动队列中删除
    this.active = this.active.filter(w =&gt; worker !== w);
    // 放回空闲队列
    this.pool.push(worker);
  }
}

module.exports = ProcessPool;
</code></pre>

<h5 id="toc_16">Communicating with a child process</h5>

<p>有了 worker 进程，接下来是解决与 worker 进程通信的问题了。</p>

<p>Nodejs 提供的 child_process 模块集成了进程间通信的功能。</p>

<p>对于父进程来说，通过 send() 可以往子进程发送数据，而通过 on() 则可以订阅事件，获取子进程返回的数据。</p>

<p>对于子进程来说，通过 process.send() 则可以向父进程发送数据。</p>

<p>一个用于结合 processPool 与 计算任务的类</p>

<pre><code class="language-js">&quot;use strict&quot;;

const EventEmitter = require(&#39;events&#39;).EventEmitter;
const ProcessPool = require(&#39;./processPool&#39;);
// 生成是 subsetSumWorker.js worker 的 进程池
const workers = new ProcessPool(__dirname + &#39;/subsetSumWorker.js&#39;, 2);

class SubsetSumFork extends EventEmitter {
  constructor(sum, set) {
    super();
    this.sum = sum;
    this.set = set;
  }

  start() {
    // 从进程池中获取 worker
    workers.acquire((err, worker) =&gt; {
      const onMessage = msg =&gt; {
        if (msg.event === &#39;end&#39;) {
          // 如果是 end 事件， 移除 onMessage listener 及 归还 worker
          worker.removeListener(&#39;message&#39;, onMessage);
          workers.release(worker);
        }
        // 透传事件与数据至 消费者处
        this.emit(msg.event, msg.data);
      };
      // 首先订阅 message 事件
      worker.on(&#39;message&#39;, onMessage);
      // 然后发送数据开始计算 
      worker.send({sum: this.sum, set: this.set});
    });
  }
}

module.exports = SubsetSumFork;
</code></pre>

<p>最后是 worker 代码</p>

<pre><code class="language-js">&quot;use strict&quot;;

const SubsetSum = require(&#39;./subsetSum&#39;);

process.on(&#39;message&#39;, msg =&gt; {  // [1]
  const subsetSum = new SubsetSum(msg.sum, msg.set);
  
  subsetSum.on(&#39;match&#39;, data =&gt; {  // [2]
    process.send({event: &#39;match&#39;, data: data});
  });
  
  subsetSum.on(&#39;end&#39;, data =&gt; {
    process.send({event: &#39;end&#39;, data: data});
  });
  
  subsetSum.start();
});
</code></pre>

<p>运行的耗时在 6551.740ms 考虑到 进程间通信 与 进程池初始化时间，这个结果是正常的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL必知必会 1 - 7 章]]></title>
    <link href="zerolocusta.github.io/15124581127035.html"/>
    <updated>2017-12-05T15:15:12+08:00</updated>
    <id>zerolocusta.github.io/15124581127035.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">第1章 了解 SQL</h2>

<h3 id="toc_1">数据库基础</h3>

<ul>
<li>数据库(Database): 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>
</ul>

<h4 id="toc_2">表</h4>

<ul>
<li>表(Table): 某种特定类型数据的结构化清单。 这些特性定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组信息就是所谓的模式(schema)，模式可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系）.</li>
</ul>

<h4 id="toc_3">列和数据类型</h4>

<ul>
<li>列(Column): 指的是表中的一个字段, 并且拥有特定的数据类型.</li>
<li>数据类型(Data Type): 表中的每个列都有特定的数据类型, 指定该列可以存储什么类型的数据.</li>
</ul>

<h4 id="toc_4">行</h4>

<ul>
<li>行(Row): 表中的数据是按行存储的，所保存的每个记录都存储在自己的行内。列是描述表中单个字段的属性，而行是在表中多个字段的数据组成的记录(record)。</li>
</ul>

<h4 id="toc_5">主键</h4>

<ul>
<li>主键(Primary Key): 表中的每一行都<strong>应该有的</strong>唯一标识，用于标识特定的行，表中的满足条件的每一列都可以作为主键：

<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每一行必须都具有一个主键值（即主键不允许为空）</li>
<li>主键列中的值不允许修改或者更新</li>
<li>主键不能重用（不允许删除后回收使用）</li>
</ul></li>
</ul>

<hr/>

<h2 id="toc_6">第2章 检索数据</h2>

<h3 id="toc_7">SELECT 语句</h3>

<p>使用 SELECT 检索表数据，必须至少给出两条信息——想选择什么（检索哪一列），以及从什么地方选择（检索哪个表）</p>

<h3 id="toc_8">检索单个列</h3>

<p>检索单个列的语句格式如下</p>

<pre><code class="language-sql">SELECT field1 FROM table;
</code></pre>

<p>例如</p>

<pre><code class="language-sql">SELECT prod_name FROM Products;
</code></pre>

<p>上述语句利用 SELECT 语句从 Products 表中检索一个名为 prod_name 的列.</p>

<p>并且数据库在处理SQL时，其中所有空格都会被忽略， 例如下面的语句能达到同样的效果，但是可读性更好。</p>

<pre><code class="language-sql">SELECT
    prod_name
FROM
    Products;
</code></pre>

<h3 id="toc_9">检索多个列</h3>

<p>检索多个列的语句格式如下</p>

<pre><code class="language-sql">SELECT field1[,field2[,field3...]] FROM table;
</code></pre>

<p>例如</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_name, 
    prod_price
FROM 
    Products;
</code></pre>

<p>上述语句利用 SELECT 语句从 Products 表中检索三个分别名为 prod_id、prod_name、prod_price 的列.</p>

<h3 id="toc_10">检索所有列</h3>

<pre><code class="language-sql">SELECT * FROM table;
</code></pre>

<h3 id="toc_11">检索不同的值（去重）</h3>

<pre><code class="language-sql">SELECT DISTINCT field FROM table;
</code></pre>

<p>DISTINCT将会把列中重复的值去除。例如</p>

<pre><code class="language-sql">SELECT DISTINCT prod_name FROM Products;
</code></pre>

<p>上述语句会将 prod_name 列中重复的值去除并返回结果。</p>

<p>要注意的是，不能部分使用 DISTINCT ，不仅仅是跟在其后的那一列。</p>

<h3 id="toc_12">限制返回的结果数量</h3>

<p>利用<code>LIMIT</code>可以限制返回的结果数量</p>

<pre><code class="language-sql">SELECT field FROM table LIMIT num;
</code></pre>

<p>例如</p>

<pre><code class="language-sql">SELECT 
    prod_name 
FROM 
    Products 
LIMIT 
    5;
</code></pre>

<p>上述语句表示从 Products 中选出前5条具有 prod_name 的数据。</p>

<p>还可以利用<code>OFFSET</code>指定从哪儿开始检索。</p>

<pre><code class="language-sql">SELECT 
    prod_name 
FROM 
    Products 
LIMIT 
    5
OFFSET
    5;
</code></pre>

<p>上述语句表示从 Products 中的第5行开始，选出前5条具有 prod_name 的数据。</p>

<h3 id="toc_13">使用注释</h3>

<p>行内注释, 利用<code>--</code></p>

<pre><code class="language-sql">SELECT prod_name    -- 这是一条注释  
FROM Products;
</code></pre>

<p>多行注释，从<code>/*</code>开始，到<code>*/</code>结束。<code>/*</code>和<code>*/</code>之间的任何内容都是注释、</p>

<pre><code class="language-sql">/* SELECT 
    prod_name, 
    vend_id  
FROM 
    Products; */
    
SELECT 
    prod_name  
FROM 
    Products;
</code></pre>

<hr/>

<h2 id="toc_14">第3章 排序检索数据</h2>

<p>这一章讲授如何使用 SELECT 语句的 ORDER BY 子句，根据需要排序检索出的数据。</p>

<h3 id="toc_15">排序数据</h3>

<p>通常情况下<code>SELECT</code>获取的数据是未经排序的，利用<code>ORDER BY</code>可以根据某个字段进行排序。</p>

<pre><code class="language-sql">SELECT 
    prod_name 
FROM 
    Products 
ORDER BY 
    prod_name;
</code></pre>

<p>上述语句指示数据库对 prod_name 列以字母顺序排序数据</p>

<h4 id="toc_16">HINTs：</h4>

<ul>
<li>ORDER BY 子句的位置，应该保证它是 SELECT 语句中最后一条子句。</li>
<li>通常，ORDER BY 子句中使用的列将是为显示而选择的列。但是，使用用非检索的列排序数据是完全合法的。</li>
</ul>

<h3 id="toc_17">按多个列排序</h3>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_price, 
    prod_name
FROM
    Products
ORDER BY
    prod_price,
    prod_name;
</code></pre>

<p>上述语句在检索出的结果中，按 prod_price 和 prod_name 排序，在两行 prod_price 相同的时候，再按 prod_name 进行排序。</p>

<h3 id="toc_18">按列位置排序</h3>

<p>除了能用列名指出排序顺序外，<code>ORDER BY</code> 还支持按相对列位置进行排序。</p>

<p>例如</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_price, 
    prod_name
FROM
    Products
ORDER BY
    2,
    3;
</code></pre>

<p>这条语句和前一节中的语句效果相同，<code>SELECT</code>后的选择列的相对位置按照1、2、3对应到<code>ORDER BY</code>中的顺序。</p>

<h3 id="toc_19">指定排序方向</h3>

<p>通过在<code>ORDER BY</code>后添加<code>DESC</code>可以改变排序的方向。</p>

<p>例如在使用<code>DESC</code>之前，选择出来的行是按指定排序字段的从小到大，而指定<code>DESC</code>后， 结果是按照从大到小进行排序。</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_price, 
    prod_name 
FROM 
    Products 
ORDER BY 
    prod_price DESC;
</code></pre>

<p>上述语句将按 prod_price 降序进行排列。</p>

<hr/>

<h2 id="toc_20">第4章 过滤数据</h2>

<h3 id="toc_21">使用 WHERE 子句</h3>

<p>在 SELECT 语句中，数据根据 WHERE 子句中指定的搜索条件进行过滤。 WHERE 子句在表名（ FROM 子句）之后给出，例如</p>

<pre><code class="language-sql">SELECT 
    prod_name, 
    prod_price 
FROM 
    Products 
WHERE 
    prod_price = 3.49;
</code></pre>

<p>这条语会将 Products 表中 prod_price 为 3.49 的结果检索出来。</p>

<h4 id="toc_22"><code>WHERE</code>子句支持的操作符</h4>

<table>
<thead>
<tr>
<th style="text-align: center">操作符</th>
<th style="text-align: center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">=</td>
<td style="text-align: center">等于</td>
</tr>
<tr>
<td style="text-align: center">&lt;&gt;</td>
<td style="text-align: center">不等于</td>
</tr>
<tr>
<td style="text-align: center">!=</td>
<td style="text-align: center">不等于</td>
</tr>
<tr>
<td style="text-align: center">&lt;</td>
<td style="text-align: center">小于</td>
</tr>
<tr>
<td style="text-align: center">&lt;=</td>
<td style="text-align: center">小于或等于</td>
</tr>
<tr>
<td style="text-align: center">!&lt;</td>
<td style="text-align: center">不小于</td>
</tr>
<tr>
<td style="text-align: center">&gt;</td>
<td style="text-align: center">大于</td>
</tr>
<tr>
<td style="text-align: center">&gt;=</td>
<td style="text-align: center">大于或等于</td>
</tr>
<tr>
<td style="text-align: center">!&gt;</td>
<td style="text-align: center">不大于</td>
</tr>
<tr>
<td style="text-align: center">BETWEEN</td>
<td style="text-align: center">是否处于指定的两个值之间</td>
</tr>
<tr>
<td style="text-align: center">LIKE</td>
<td style="text-align: center">搜索相似字符串</td>
</tr>
<tr>
<td style="text-align: center">IN</td>
<td style="text-align: center">判断特定的值是否处于字段中</td>
</tr>
<tr>
<td style="text-align: center">IS NULL</td>
<td style="text-align: center">判断是否为NULL值</td>
</tr>
</tbody>
</table>

<h5 id="toc_23"><code>BETWEEN</code>操作符</h5>

<p>检查某个范围的值，可以使用 BETWEEN 操作符。例如</p>

<pre><code class="language-sql">SELECT 
    prod_name, 
    prod_price 
FROM 
    Products 
WHERE 
    prod_price BETWEEN 5 AND 10;
</code></pre>

<p>这条语句通过<code>BETWEEN ... AND</code>操作符查询 prod_price 在 5 到 10 之间的数据。</p>

<h5 id="toc_24">空值检查</h5>

<p>确定值是否为 NULL，不能简单地检查是否 <code>= NULL</code>, 而是使用<code>IS NULL</code>来检查具有<code>NULL</code>值的列. 例如</p>

<pre><code class="language-sql">SELECT 
    cust_name 
FROM 
    Customers 
WHERE 
    cust_email IS NULL;
</code></pre>

<p>这条语句检查 Customers 表中 cust_email 为空的行。</p>

<hr/>

<h2 id="toc_25">第5章 高级数据过滤</h2>

<p>这一章介绍如何组合 WHERE 子句以建立功能更强、更高级的搜索条件。跀A恀我们还将学习如何使用 NOT 和 IN 操作符</p>

<h3 id="toc_26">组合 WHERE 子句</h3>

<h4 id="toc_27">AND 操作符</h4>

<p>使用 AND 操作符可以给 WHERE 子句附加条件。其效果去逻辑与相似。 例如</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_price, 
    prod_name
FROM 
    Products 
WHERE 
    vend_id = &#39;DLL01&#39; 
    AND 
    prod_price &lt;= 4;
</code></pre>

<p>这条语句从 Products 表中检索出 vend_id 为 DLL01 <strong>并且</strong> prod_price 小于等于4的行。</p>

<h4 id="toc_28">OR 操作符</h4>

<p>OR 操作符效果与逻辑或相似， 同样可以给 WHERE 子句附加条件。 例如</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_price, 
    prod_name
FROM 
    Products 
WHERE 
    vend_id = &#39;DLL01&#39; 
    AND 
    vend_id = &#39;RLL05&#39;;
</code></pre>

<p>这条语句从 Products 表中检索出 vend_id 为 DLL01 <strong>或者</strong> vend_id 为 RLL05 的行。</p>

<h4 id="toc_29">求值顺序</h4>

<p>AND 与 OR 操作符可以随意数量组合使用。但是和大多数语言类似，SQL中的操作符也有优先级顺序，在处理 OR 操作符前，优先处理 AND 操作符。</p>

<p>所以在使用多个 AND 或者 OR 操作符的时候，加上括号就好了。</p>

<h3 id="toc_30">IN 操作符</h3>

<p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN 使用一组由逗号分隔、 括在圆括号中的合法值。 例如</p>

<pre><code class="language-sql">SELECT 
    prod_name, 
    prod_price 
FROM 
    Products 
WHERE 
    vend_id 
        IN ( &#39;DLL01&#39;, &#39;BRS01&#39; ) 
ORDER BY 
    prod_name;
</code></pre>

<p>这条语句表示从 Products 表中筛选出 vend_id 的值为 DLL01 或是 BRS01 的行，并将结果按照 prod_name 排序。与之相对应的使用 OR 操作符的SQL语句：</p>

<pre><code class="language-sql">SELECT 
    prod_name, 
    prod_price 
FROM 
    Products 
WHERE 
    vend_id = &#39;DLL01&#39;
    OR
    vend_id = &#39;BRS01&#39; 
ORDER BY 
    prod_name;
</code></pre>

<p>IN 操作符与 （OR 或 AND）操作符相比</p>

<ul>
<li>IN 操作符的语法更清楚，更直观</li>
<li>与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理</li>
<li>IN 操作符一般比一组 OR 操作符执行得更快</li>
<li>IN 的还可以包含其他 SELECT 语句（子查询），更动态的建立 WHERE 子句。</li>
</ul>

<h3 id="toc_31">NOT 操作符</h3>

<p>WHERE 子句中的 NOT 操作符有且只有一个功能，那就是否定其后所跟的任何条件。与逻辑非功能相似。例如</p>

<pre><code class="language-sql">SELECT 
    prod_name 
FROM 
    Products 
WHERE 
    NOT vend_id = &#39;DLL01&#39;
ORDER BY 
    prod_name;
</code></pre>

<p>这条语句表示从 Products 表中检索出 vend_id <strong>不等于</strong> DLL01 的行。</p>

<p>NOT 操作符的优势在于，与 IN 操作符联合使用时， NOT 可以非常简单地找出与条件列表不匹配的行。</p>

<hr/>

<h2 id="toc_32">第6章 用通配符进行过滤</h2>

<p>这一章介绍什么是通配符、如何使用通配符以及怎样使用 LIKE 操作符进行通配搜索，以便对数据进行复杂过滤。</p>

<h3 id="toc_33">LIKE 操作符</h3>

<p>LIKE 操作符允许使用通配符、字面量来构造查询条件，进行模糊匹配。</p>

<h4 id="toc_34">百分号（%）通配符</h4>

<p>搜索串中，<code>%</code>表示任何字符出现<strong>任意次数</strong>。例如可以使用<code>Fish%</code>作为 LIKE 的查询条件，检索出所有以词 Fish 起头的产品。</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_name  
FROM 
    Products  
WHERE 
    prod_name LIKE &#39;Fish%&#39;;
</code></pre>

<h4 id="toc_35">下划线（_）通配符</h4>

<p>下划线（_）通配符与百分号（%）通配符相似，只不过<code>_</code>表示匹配<strong>单个字符</strong>。</p>

<p>例如一下句子表示匹配出 Products 中 prod_name 为 XX水果 的查询语句。</p>

<pre><code class="language-sql">SELECT 
    prod_id, 
    prod_name  
FROM 
    Products  
WHERE 
    prod_name LIKE &#39;__水果&#39;; -- 注意这里有两个 _ 操作符
</code></pre>

<p>这样的查询条件只会匹配诸如 京东水果、企鹅水果，而不会匹配出 红水果、红红红水果。</p>

<hr/>

<h2 id="toc_36">第7章 创建计算字段</h2>

<p>这一章介绍什么是计算字段，如何创建计算字段，以及如何从应用程序中使用别名引用它们。</p>

<h3 id="toc_37">计算字段</h3>

<p>存储在数据库表中的数据一般不是应用程序所需要的格式，除了可以再应用程序中做数据计算之外，SELECT 也支持进行字段计算。</p>

<h3 id="toc_38">拼接字段</h3>

<p>在 MySQL 中可以使用 Concat 函数拼接字段， 例如</p>

<pre><code class="language-sql">SELECT 
    Concat( vend_name, &#39; (&#39;, vend_country, &#39;)&#39; ) 
FROM 
    Vendors 
ORDER BY vend_name;
</code></pre>

<p>表示从 Vendors 表中获取每行中 vend_name 与 vend_country 的值，并且按 vend_name 进行排序，同时在返回检索结果时将 vend_name 与 vend_country 拼接成 <code>vend_name (vend_country)</code> 的形式。</p>

<h4 id="toc_39">使用别名（alias）</h4>

<p>SELECT 语句可以很好地拼接地址字段。但是，这个新计算列并不像列（column）一样具有名字，从而无法很好地引用它。</p>

<p>为了解决这个问题，SQL 支持列别名。别名（alias）是一个字段或值的替换名，使用 AS 指定。</p>

<pre><code class="language-sql">SELECT 
    Concat( vend_name, &#39; (&#39;, vend_country, &#39;)&#39; ) AS vend_title
FROM 
    Vendors 
ORDER BY vend_name;
</code></pre>

<p>为<code>Concat( vend_name, &#39; (&#39;, vend_country, &#39;)&#39; )</code>的结果创建一个包含指定计算结果的名为vend_title 的计算字段。在检索结果中也会出现 vend_title 这个列，就像它真的存在于表结构中一样。</p>

<h3 id="toc_40">执行算术计算</h3>

<p>SQL允许在语句中通过算术操作符或是数学函数执行算术计算。</p>

<pre><code class="language-sql">SELECT 
    prod_id,
    quantity,        
    item_price,        
    quantity * item_price AS expanded_price 
FROM 
    OrderItems 
WHERE 
    order_num = 20008;
</code></pre>

<p>筛选出 order_num 为 20008 的行，并将行中的 quantity 乘以 item_price 的值，使用别名 expanded_price 指定并返回至客户端。</p>

<h4 id="toc_41">SQL中的算数操作符</h4>

<table>
<thead>
<tr>
<th style="text-align: center">操作符</th>
<th style="text-align: center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">+</td>
<td style="text-align: center">加</td>
</tr>
<tr>
<td style="text-align: center">-</td>
<td style="text-align: center">减</td>
</tr>
<tr>
<td style="text-align: center">*</td>
<td style="text-align: center">乘</td>
</tr>
<tr>
<td style="text-align: center">/</td>
<td style="text-align: center">除</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 Node.js C++ Addon 观察 Js 在 v8 中的表示方式]]></title>
    <link href="zerolocusta.github.io/15116831975159.html"/>
    <updated>2017-11-26T15:59:57+08:00</updated>
    <id>zerolocusta.github.io/15116831975159.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"><a href="https://github.com/nodejs/nan">Native Abstractions for Node.js</a> (nan)</h2>

<blockquote>
<p>A header file filled with macro and utility goodness for making add-on development for Node.js easier</p>
</blockquote>

<p>Nan 是一个具有更丰富的功能封装以方便开发 Node.js C++ 插件的头文件. 跟随 Nan 的 README 文件, 从 v8 引擎开始, 同时结合 libuv , 再到 Node.js 中了解 C++ 插件, 最后观察<code>nan</code>究竟做了哪些封装.</p>

<h3 id="toc_1"><a href="https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding">The V8 Getting Started * Guide</a></h3>

<h6 id="toc_2"><code>v8</code>本来是为<code>Chrome</code>设计的<code>JavaScript</code>解析引擎, 看的时候多从浏览器的角度去考虑.</h6>

<h4 id="toc_3">Hello World</h4>

<p>接下来会给出一个<code>Hello Example</code>, 演示如何使用<code>v8</code>打印出<code>Hello World</code>. 在给出代码之前, 首先简述几个概念:</p>

<ul>
<li><code>Isolate</code>: 表示一个<code>v8</code>虚拟机实例.</li>
<li><code>Local Handle</code>: 指向<code>v8</code>对象的引用对象, 由于<code>v8</code>引擎的垃圾回收机制的工作方式, 所有的<code>v8</code>对象都需要通过<code>handle</code>访问.</li>
<li><code>Handle Scope</code>: 一个或多个<code>Handle</code>的集合. 当我们使用完多个<code>Handle</code>后, 无需通过逐个析构的方式去删除它们, 而是通过析构<code>Handle Scope</code>就可以了.</li>
<li><code>Context</code>: 为<code>JavaScript</code>在同一个<code>v8</code>虚拟机实例中提供<strong>隔离的</strong>执行环境.</li>
</ul>

<p>更详细的解释将会在<a href="https://github.com/v8/v8/wiki/Embedder%27s-Guide">Embedder&#39;s Guide</a>中进行讨论.</p>

<p>将<code>hello-world.cc</code>拆开来看</p>

<p>①  启动<code>v8</code>部分.</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;include/libplatform/libplatform.h&quot;
#include &quot;include/v8.h&quot;
int main(int argc, char* argv[]) {
--// Initialize V8.
--
--// 初始化International Components for Unicode
--// 用于处理Unicode编码
--// 从本地的icudtl.dat读取编解码数据
--v8::V8::InitializeICUDefaultLocation(argv[0]);
--// natives_blob.bin 和 snapshot_blob.bin
--// 用于加速启动V8引擎
--v8::V8::InitializeExternalStartupData(argv[0]);
--// 初始化v8平台
--std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();
--// 初始化v8管理平台
--v8::V8::InitializePlatform(platform.get());
--v8::V8::Initialize();
</code></pre>

<ul>
<li><code>v8::V8::InitializeICUDefaultLocation</code>: <code>v8</code>的<code>Unicode</code>字符处理依赖于<code>icu</code>库, 同时使用该函数从外部的<code>icudtl.dat</code>文件加载<code>Unicode</code>的编解码数据.</li>
<li><code>v8::V8::InitializeExternalStartupData</code>: <code>v8</code>在启动的时候需要预先加载一些<code>JavaScript build-in</code>函数, 例如<code>math</code>、<code>full-featured regular expression engine</code>, 这个启动过程相当缓慢. 而自从<code>4.3</code>版本开始, <code>v8</code>引入了<code>snapshotting</code>快照加载功能用于加速这个过程, 目前依赖两种快照<code>natives_blob.bin</code>和<code>snapshot_blob.bin</code>.

<ul>
<li><code>natives_blob.bin</code>: 存储了<code>JavaScript build-in</code>函数解析执行后的内存布局快照(<code>JavaScript build-in</code>可以在<code>v8/src/objects.h</code>中的<code>FUNCTIONS_WITH_ID_LIST</code>宏中查看.</li>
<li><code>snapshot_blob.bin</code>: 存储了<code>v8</code>启动后的内存布局快照.</li>
</ul></li>
<li><code>v8::platform</code>: 管理<code>v8</code>引擎实例<code>isolate</code>的接口, 保存多个<code>isolate</code>的执行状态和所在线程.</li>
</ul>

<hr/>

<p>②  创建<code>v8</code>引擎实例 </p>

<pre><code class="language-c++">--// Create a new Isolate and make it the current one.
--v8::Isolate::CreateParams create_params;
--create_params.array_buffer_allocator =
--    v8::ArrayBuffer::Allocator::NewDefaultAllocator();
--v8::Isolate* isolate = v8::Isolate::New(create_params);
</code></pre>

<ul>
<li><code>create_params</code>: 存储<code>v8</code>引擎的初始化参数</li>
<li><code>v8::Isolate::New</code>: 实例化<code>v8</code>引擎</li>
</ul>

<hr/>

<p>③  创建<code>JavaScript</code>代码的执行环境</p>

<pre><code class="language-js">// 创建临时作用域用于自动析构 HandleScope
--{
----v8::Isolate::Scope isolate_scope(isolate);
----// Create a stack-allocated handle scope.
----// HandleScope, 之前的概念简要中提到的利用RAII创建和析构Handle
----// HandleScope作用于isolate(v8实例)
----// 表示从此开始在isolate中创建的handle在作用域结束时回收
----v8::HandleScope handle_scope(isolate);
----// Create a new context.
----// 创建隔离的`JavaScript`代码执行环境
----v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);
----// Enter the context for compiling and running the hello world script.
----// Context::Scope 作用于 context
----// 表示从此开始在context中创建的实例在离开作用域时回收
----v8::Context::Scope context_scope(context);
----// Create a string containing the JavaScript source code.
----// 将`JavaScript`代码实例化表示为 v8::String
----// 此处的JavaScript代码为 &#39;Hello&#39; + &#39;, World&#39;
----v8::Local&lt;v8::String&gt; source =
----    v8::String::NewFromUtf8(isolate, &quot;&#39;Hello&#39; + &#39;, World!&#39;&quot;,
----                            v8::NewStringType::kNormal)
----        .ToLocalChecked();
----// Compile the source code.
----// 解析JavaScript代码
----v8::Local&lt;v8::Script&gt; script =
----    v8::Script::Compile(context, source).ToLocalChecked();
----// Run the script to get the result.
----// 执行编译后的`JavaScript`代码, 并且在context中执行
----v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();
----// Convert the result to an UTF8 string and print it.
----// 从v8::Value中提取执行结果, 转换为utf-8字符串
----v8::String::Utf8Value utf8(isolate, result);
----printf(&quot;%s\n&quot;, *utf8);
--}
//↑ 临时作用域结束, 自动析构临时作用域内创建的HandleScope
</code></pre>

<ul>
<li><code>v8::Isolate::Scope</code>: 作用于<code>isolate</code>实例, 利用<code>RAII</code>自动管理此作用域内所有的操作, 在离开作用域时回收.</li>
<li><code>v8::Local&lt;T&gt;</code>: 相当于只能指针, 表示被引用对象, 由<code>HandleScope</code>管理, 离开作用域时析构该引用.</li>
<li><code>v8::Script</code>: 编译后的<code>JavaScript</code>代码的<code>AST</code>抽象表示根节点, 必须在实例化是绑定到<code>v8::Context</code>.</li>
</ul>

<hr/>

<p>④  析构<code>v8</code>实例</p>

<pre><code class="language-c++">--// Dispose the isolate and tear down V8.
--isolate-&gt;Dispose();
--v8::V8::Dispose();
--v8::V8::ShutdownPlatform();
--delete create_params.array_buffer_allocator;
--return 0;
}
</code></pre>

<h4 id="toc_4"><code>Hello World</code>启示</h4>

<ol>
<li><code>v8</code>依赖引用计数进行垃圾回收, 并且在<code>v8</code>提供的<code>API</code>接口中利用<code>Handle</code>进行引用计数.</li>
<li><code>Handle</code>仅仅是对<code>v8</code>引擎实例中<code>v8数据结构</code>的引用, 在解构后仅仅是将其引用计数－1, 何时进行内存回收由<code>垃圾回收实例</code>决定.</li>
<li><code>v8</code>中可以有多个<code>v8</code>引擎实例, 但每个实例中的<code>v8</code>数据结构都是与<code>v8</code>引擎强关联的, 无法跨引擎传递使用.</li>
</ol>

<h3 id="toc_5"><a href="https://github.com/v8/v8/wiki/Embedder%27s-Guide">Embedder&#39;s Guide</a></h3>

<p>解释<code>v8</code>提供的<code>C++ API</code>中的核心概念: </p>

<ul>
<li><code>Handle</code></li>
<li><code>Contexts</code></li>
<li><code>Templates</code></li>
<li><code>Accessors</code></li>
<li><code>Interceptors</code></li>
<li><code>Security Model</code></li>
<li><code>Exceptions</code></li>
<li><code>Inheritance</code></li>
</ul>

<hr/>

<h4 id="toc_6">Handles and Garbage Collection</h4>

<p><code>Handle</code>是<code>v8</code>引擎堆中<code>JavaScript</code>对象的引用. <code>v8</code>垃圾回收器会将<strong>无法访问</strong>的<code>JavaScript</code>对象进行回收. 而在垃圾回收过程中, <code>JavaScript</code>对象在内存中的位置会经常移动, 当一个对象移动完成后, 所有在此对象上的<code>Handle</code>引用也会更新, 重新指向对象的新地址.</p>

<p><code>Handle</code>有几种类型:</p>

<ul>
<li><p><code>Local Handle</code>: <code>Local</code>中对<code>JavaScript</code>对象的引用是基于<code>Handle Stack</code>的. 必须配合<code>HandleScope</code>一起使用. <code>HandleScope</code>在构造时, 会营造出<code>Handle Stack</code>, 在此之后构造的所有<code>Local Handle</code>都由这个<code>HandleScope</code>管理, 并在<code>HandleScope</code>析构后<strong>Clear</strong>, 释放<code>Local Handle</code>对<code>JavaScript</code>对象的引用.</p>

<ul>
<li><code>Local</code>中对<code>JavaScript</code>对象的引用是基于<code>Handle Stack</code>的, 由<code>HandleScope</code>管理.</li>
<li><code>Handle Stack</code>要与<code>C++ Stack</code>区分开, <code>HandleScope</code>是基于<code>C++ Stack</code>的, 在离开作用域时析构, 而<code>Local</code>是基于<code>Handle Stack</code>的, 在<code>Handle Stack</code>删除时解开对<code>JavaScript</code>对象的引用并析构.</li>
<li><code>Local</code>必须执行在<code>HandleScope</code>中, 否则会造成内存泄漏, 还有可能引起<code>v8</code>崩溃.</li>
<li>由于<code>HandleScope</code>是基于<code>C++ Stack</code>的, 如果<code>Local</code>被复制(或别引用)离开了当前作用域(也同时离开了当前<code>HandleScope</code>), 需要使用<code>EscapableHandleScope</code>或者<strong>利用</strong>其中的对象指针生成<code>Persistent</code></li>
<li> <code>Handle</code> is an alias for <code>Local</code> for historical reasons.</li>
</ul></li>
<li><p><code>Persistent Handle</code>: <code>Persistent</code>同样是对于<code>v8</code>引擎中<code>JavaScript</code>对象的引用, 与<code>Local</code>不同的是<code>Persistent</code>并不由<code>HandleScope</code>管理, 而是需要调用<code>Persistent Handle::Reset()</code>进行其对<code>JavaScript</code>对象的解引用.</p></li>
</ul>

<p><img src="media/15116831975159/local_persist_handles_review.png" alt="local_persist_handles_revie"/></p>

<hr/>

<h4 id="toc_7">Contexts</h4>

<p><code>Context</code>是在<code>v8</code>引擎实例<code>Isolate</code>内部的一个独立地<code>JavaScript</code>执行环境. 在执行<code>JavaScript</code>代码时, 必须指定其<code>Context</code>.</p>

<p><code>Context</code>的存在是由于<code>JavaScript</code>的内置函数与对象(<code>build-in functions and objects</code>), 全局运行环境(<code>global</code>)都是可以被用户代码改变的. 如果两份不相关的代码在没有<code>Context</code>的情况下运行, 那么其中一份代码改变了全局相关属性后, 另一份<code>JavaScript</code>代码也会受到影响.</p>

<h5 id="toc_8">Contexts Extensive Caching</h5>

<p><code>Context</code>中有独立的<code>build-in functions and objects</code>、<code>global</code>, 而<code>build-in</code>里有不少是由<code>JavaScript</code>低等级代码(<code>低级胶水JavaScript</code>, <code>JavaScript</code>中通过<code>%</code>调用<code>C++</code>函数), 这意味着每次新建<code>Context</code>的时候都需要解析并生成一份<code>build-in</code>.</p>

<p>不过<code>v8</code>提供了对<code>build-in</code>的缓存, 在第一份<code>Context</code>初始化完成后, 后续生成的<code>Context</code>只需沿用已经初始化完成的<code>build-in</code>就可以了.</p>

<p>而且<code>v8</code>提供快照功能, 在<code>v8</code>进程初始化的时候可以通过编译时提前准备好的<code>snapshot_blob.bin</code>快照, 初始化第一个<code>Context</code>堆内存空间并将<code>build-in</code>缓存起来.</p>

<p><img src="media/15116831975159/intro_contexts.png" alt="intro_contexts"/></p>

<p><strong>即使是使用了缓存技术, 每个<code>Context</code>仍然是独立的, 只是他们的对全局对象和<code>build-in</code>的修改记录在自己的内存空间里, 而不会影响缓存数据.</strong></p>

<hr/>

<h4 id="toc_9">Templates</h4>

<p><code>v8</code>语义下的<code>template</code>指的是<code>JavaScript</code>函数和对象在<code>C++</code>与之对应的抽象. 通过<code>template</code>可以在<code>JavaScript</code>中访问被<code>template</code><strong>封装后</strong>的<code>C++</code>函数和对象.</p>

<p>在<code>JavaScript</code>语义下, <code>Function</code>和<code>Object</code>具有很多相似的地方, 但是在<code>C++</code>语义下, 这两种是完全不一样的东西. 为了将<code>C++</code>语义下的<code>Function</code>与<code>Object</code>映射到<code>v8</code>引擎中, <code>v8</code>提供了两种<code>Template</code></p>

<ul>
<li><p><code>Function Template</code>: 提供了<code>C++</code>中对<code>JavaScript</code>函数的抽象, 可以在<code>C++</code>中创建<code>JavaScript</code>函数. 也可以包裹单个<code>C++</code>函数, 并抽象成<code>JavaScript</code>函数.</p></li>
<li><p><code>Object Template</code>: 提供了<code>C++</code>中对<code>JavaScript</code>中对象<strong>实例</strong>的抽象.</p></li>
</ul>

<p>重申一下, <code>Function Template</code>是用于在<code>C++</code>中(描述)创建<code>JavaScript</code>中的函数的, 而<code>Object Template</code>是用于在<code>C++</code>中(描述)创建并返回<code>JavaScript</code><strong>对象实例</strong>的. </p>

<p>在<code>C++</code>中<strong>可以</strong>通过<code>Function Template</code>来模拟<code>JavaScript</code>中的类, 而<code>Object Template</code>用于创建<code>JavaScript</code>对象<strong>实例</strong>.</p>

<pre><code class="language-c++">// Create a template for the global object and set the
// built-in global functions.
Local&lt;ObjectTemplate&gt; global = ObjectTemplate::New(isolate);
global-&gt;Set(String::NewFromUtf8(isolate, &quot;log&quot;), FunctionTemplate::New(isolate, LogCallback));

// Each processor gets its own context so different processors
// do not affect each other.
Persistent&lt;Context&gt; context = Context::New(isolate, NULL, global);
</code></pre>

<hr/>

<h4 id="toc_10">Accessors</h4>

<p><code>v8</code>中提供的<code>Accessors</code>与<code>JavaScript</code>中的访问器概念一样, 提供控制<strong>对象</strong>中属性的访问行为.</p>

<p>通过对象中的<code>SetAccessor</code>方法可以对<strong>对象</strong>添加访问器属性, 并且通过<code>AccessorGetterCallback</code>、<code>AccessorSetterCallback</code>添加<strong>对象</strong>的<code>[Getter|Setter]</code>, 以及<code>AccessControl</code>控制访问器权限.</p>

<pre><code class="language-c++">enum AccessControl {
  DEFAULT = 0,
  ALL_CAN_READ = 1,
  ALL_CAN_WRITE = 1 &lt;&lt; 1,
  PROHIBITS_OVERWRITING = 1 &lt;&lt; 2
};

typedef void (*AccessorGetterCallback)(Local&lt;String&gt; property,
                                       const PropertyCallbackInfo&lt;Value&gt;&amp; info);
                                       
typedef void (*AccessorSetterCallback)(Local&lt;String&gt; property,
                                       Local&lt;Value&gt; value,
                                       const PropertyCallbackInfo&lt;void&gt;&amp; info);
</code></pre>

<hr/>

<h4 id="toc_11">Interceptors</h4>

<blockquote>
<p>访问对象前插一脚</p>
</blockquote>

<p><code>Interceptors</code>提供了<strong>访问对象前</strong>调用自定义函数的机会. <code>Interceptors</code>分为两种</p>

<ul>
<li><code>named property interceptors</code>: 在通过字符串名字(<code>string name</code>)访问对象前调用的, 例如<code>document.theFormName.elementName</code>.</li>
<li><code>indexed property interceptors</code>: 通过索引访问对象前调用. 例如<code>document.forms.elements[0]</code>.</li>
</ul>

<p>在目前的<code>[Embedder&#39;s Guide](https://github.com/v8/v8/wiki/Embedder%27s-Guide)</code>中, 使用的分别是</p>

<pre><code class="language-c++">void ObjectTemplate::SetNamedPropertyHandler(
    IndexedPropertyGetterCallback getter,
    IndexedPropertySetterCallback setter = 0,
    IndexedPropertyQueryCallback query = 0,
    IndexedPropertyDeleterCallback deleter = 0,
    IndexedPropertyEnumeratorCallback enumerator = 0,
    Local&lt;Value&gt; data = Local&lt;Value&gt;());

void ObjectTemplate::SetIndexedPropertyHandler(
    NamedPropertyGetterCallback getter,
    NamedPropertySetterCallback setter = 0,
    NamedPropertyQueryCallback query = 0,
    NamedPropertyDeleterCallback deleter = 0,
    NamedPropertyEnumeratorCallback enumerator = 0,
    Local&lt;Value&gt; data = Local&lt;Value&gt;());
</code></pre>

<p>但是以上两个函数都已经在最新的<code>v8</code>源码中被标记为<code>deprecate</code>, 取而代之的是</p>

<pre><code class="language-c++">void SetHandler(const NamedPropertyHandlerConfiguration&amp; configuration);

void SetHandler(const IndexedPropertyHandlerConfiguration&amp; configuration);
</code></pre>

<h5 id="toc_12">Different between Interceptors And Accessor</h5>

<p><code>Interceptors</code>会影响对象所有属性的访问行为, 而<code>Accessor</code>只会针对单个属性.</p>

<h4 id="toc_13">Exceptions</h4>

<p><code>v8</code>在运行时发生错误会抛出异常, 而在<code>C++</code>中可以利用<code>TryCatch</code>类作用域<code>Isolate</code>, 捕获<code>v8</code>运行过程中抛出的异常.</p>

<pre><code class="language-js">TryCatch trycatch(isolate);
Local&lt;Value&gt; v = script-&gt;Run();
// 当发生异常时, `v8`会返回一个空的`Value`实例
if (v.IsEmpty()) {
  Local&lt;Value&gt; exception = trycatch.Exception();
  String::Utf8Value exception_str(exception);
  printf(&quot;Exception: %s\n&quot;, *exception_str);
  // ...
}
</code></pre>

<h4 id="toc_14">Inheritance</h4>

<blockquote>
<p>  在<code>C++</code>中利用<code>Function Template</code>模拟<code>JavaScript</code>中的类.</p>
</blockquote>

<p><code>JavaScript</code>本来是没有类的, 但是可以利用<code>function</code>去模拟类的行为.</p>

<pre><code class="language-js">// Create an object &quot;bicycle&quot; 
function bicycle(){ 
} 
// Create an instance of bicycle called roadbike
var roadbike = new bicycle()
// Define a custom property, wheels, on roadbike 
roadbike.wheels = 2
</code></pre>

<p>以及利用<code>prototype</code>去模拟类的实例方法和属性</p>

<pre><code class="language-js">// First, create the &quot;bicycle&quot; object
function bicycle(){ 
}
// Assign the wheels property to the object&#39;s prototype
bicycle.prototype.wheels = 2
</code></pre>

<p>而<code>v8 C++ API</code>也提供了设置<code>Function prototype</code>的方法.</p>

<pre><code class="language-c++">// function biketemplate() { }
Local&lt;FunctionTemplate&gt; biketemplate = FunctionTemplate::New(isolate);
// biketemplate.prototype.wheels = MyWheelsMethodCallback;
biketemplate-&gt;PrototypeTemplate().Set(
    String::NewFromUtf8(isolate, &quot;wheels&quot;),
    FunctionTemplate::New(isolate, MyWheelsMethodCallback)-&gt;GetFunction();
)
</code></pre>

<p>同时也提供了<code>inherit</code>方法</p>

<pre><code class="language-c++">void Inherit(Local&lt;FunctionTemplate&gt; parent);
</code></pre>

<hr/>

<h3 id="toc_15">v8中的<code>Maybe type</code></h3>

<blockquote>
<p><code>Maybe type</code>参考了具有强类型系统的严格函数式语言<code>Haskell</code>.</p>
</blockquote>

<h5 id="toc_16">From Haskell</h5>

<p>It allows the programmer to specify something may not be there.</p>

<pre><code class="language-haskell">data Maybe a = Just a | Nothing
</code></pre>

<h5 id="toc_17">To v8</h5>

<p><code>v8</code>中提供<code>Maybe&lt;T&gt;</code>和<code>MaybeLocal&lt;T&gt;</code>用于在获取对象中实际的值时, 先检查所获得的值是否为空. 如果为空则抛出异常, 不为空则返回<code>&lt;T&gt;</code>或<code>Local&lt;T&gt;</code>.</p>

<p>例如<code>MaybeLocal</code>中</p>

<pre><code class="language-c++">template &lt;class T&gt;
Local&lt;T&gt; MaybeLocal&lt;T&gt;::ToLocalChecked() {
  if (V8_UNLIKELY(val_ == nullptr)) V8::ToLocalEmpty();
  return Local&lt;T&gt;(val_);
}
</code></pre>

<pre><code class="language-c++">void V8::ToLocalEmpty() {
  Utils::ApiCheck(false, &quot;v8::ToLocalChecked&quot;, &quot;Empty MaybeLocal.&quot;);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript高级程序设计 · 7、22 章]]></title>
    <link href="zerolocusta.github.io/15114266480360.html"/>
    <updated>2017-11-23T16:44:08+08:00</updated>
    <id>zerolocusta.github.io/15114266480360.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">第七章 函数表达式</h2>

<h4 id="toc_1">摘要</h4>

<ol>
<li>什么函数表达式</li>
<li>使用函数实现递归</li>
<li>使用闭包定义私有变量</li>
</ol>

<h3 id="toc_2">函数声明与函数表达式</h3>

<ul>
<li>函数声明:</li>
</ul>

<pre><code class="language-js">function foo(arg0, arg1, arg2) {
    console.log(&#39;hello wrold&#39;);
}
</code></pre>

<ul>
<li>函数表达式:</li>
</ul>

<pre><code class="language-js">let foo = function(arg0, arg1, arg2) {
    console.log(&#39;hello world&#39;);
}
</code></pre>

<p>而<code>函数声明</code>和<code>函数表达式</code>的区别在于, <code>函数声明</code>在解析的时候会进行<strong>函数声明提升</strong>, 这意味着函数在声明之前就可以使用, 不依赖函数的声明顺序(例如在<code>c语言</code>中,函数在使用前必须先声明, 否则找不到<code>Symbol</code>.)</p>

<p>而<code>函数表达式</code>则按照变量的解析规则进行解析.</p>

<p>基于这一特性, 以下的代码极有可能出现问题</p>

<pre><code class="language-js">if (condition) {
    function sayHello() {
        console.log(&#39;Hello&#39;);
    };
} else {
    function sayHello() {
        console.log(&#39;Yoooo&#39;);
    };
}
</code></pre>

<p>实际上这是在<code>ECMAScript</code>中属于无效语法, 大部分<code>JavaScript</code>引擎都会尝试修正错误, 但问题在于修正问题的方式不一致, 也就说这是一个UB.</p>

<p>正确的使用方式应该是</p>

<pre><code class="language-js">let sayHello = null;

if (condition) {
    sayHello = function() {
        console.log(&#39;hello&#39;);
    };
} else {
    sayHello = function() {
        console.log(&#39;Yoooo&#39;);
    };
}
</code></pre>

<h4 id="toc_3">递归</h4>

<p>常规递归代码</p>

<pre><code class="language-js">function fac(num) {
    if (num &lt;= 1)
        return 1;
    return num * fac(num - 1);
}
</code></pre>

<p>然而由于<code>JavaScript</code>中, 常规函数在声明后仍然可以修改他的值,  例如</p>

<pre><code class="language-js">let anotherFac = fac;
fac = null;
anotherFac(10);
</code></pre>

<p><code>fac</code>在被置为<code>null</code>之后, 原有的<code>fac</code>函数内部在通过<code>fac</code>函数进行调用已经失效, 从而造成函数调用失败.<br/>
(在<code>Chrome</code>中运行的结果)<br/>
<img src="media/15114266480360/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-23%20%E4%B8%8B%E5%8D%889.31.13.png" alt="屏幕快照 2017-11-23 下午9.31.13"/></p>

<p>书中给出的解决方式是利用<code>arguments.callee</code>去代替通过函数名递归</p>

<pre><code class="language-js">function fac(num) {
    if (num &lt;= 1)
        return num;
    return num * arguments.callee(num - 1);
}
</code></pre>

<p>不过<code>arguments.callee</code>在严格模式下并不允许使用并且抛出<code>TypeError</code>, 根据<code>JavaScript MDN</code>的解释</p>

<blockquote>
<p>不再支持 arguments.callee。正常模式下，arguments.callee 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了！此外，arguments.callee 十分不利于优化，例如内联函数，因为arguments.callee 会依赖对非内联函数的引用。</p>
</blockquote>

<p>更好的方法是将具名函数赋予变量, 成为函数表达式</p>

<pre><code class="language-js">let fac = function f(num) {
    if (num &lt;= 1)
        return num;
    return num * f(num - 1);
}
</code></pre>

<h4 id="toc_4">闭包</h4>

<p>闭包是指有权访问另一个函数作用域中的变量的函数, 更通俗的将, 是能通过引用或值捕获函数外部的变量, 从而延长变量的生命周期.</p>

<pre><code class="language-js">function createClosure() {
    let num = 1;
     
    return function() {
        console.log(num);
    }
}
</code></pre>

<p>在<code>createClosure</code>函数中创建变量<code>num</code>, 返回一个匿名函数, 而匿名函数内部仍然能访问<code>num</code>.</p>

<h5 id="toc_5"><code>ECMAScript</code>中的闭包原理</h5>

<p>当某个函数首次被调用时, 会创建一个<strong>执行环境</strong>以及相应的<strong>作用域链</strong>,并且吧作用域链赋予特殊的内部属性<code>[[Scope]]</code>, 然后使用<code>this</code>, <code>arguments</code>来初始化函数活动对象.</p>

<p>而在作用域链中, 外部函数的活动对象处于第二位, 外部函数的外部函数活动对象处于第三位, 以此类推, 直到作用域链的终点: 全局执行环境.</p>

<p>例如,在全局环境中声明与执行函数</p>

<pre><code class="language-js">function compare(value1, value2) {
    if (value1 &lt; value2)
        return -1;
    if (value1 &gt; value2)
        return 1;
    return 0
}

let result = compare(5, 10);
</code></pre>

<p>以上代码首先定义了<code>compare</code>函数, 随后调用<code>compare</code>, 在第一次调用<code>compare</code>函数前, 会先创建一个包含<code>this</code>, <code>arguments</code>, <code>value1</code>和<code>value2</code>的活动对象(<code>activation object</code>). 全局执行环境的变量对象<code>(variable object)</code>在<code>compare</code>函数的作用域链中则处于第二位.<br/>
<img src="media/15114266480360/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-26%20%E4%B8%8A%E5%8D%889.47.06.png" alt="屏幕快照 2017-11-26 上午9.47.06"/></p>

<blockquote>
<p>上图中出现了四种对象</p>

<ul>
<li>(compare execution context) : compare函数的执行环境</li>
<li>(Scope Chain) : compare函数的作用域链</li>
<li>(Global variable object): 全局执行环境的变量对象(variable Object)</li>
<li>(compare() activation object): compare函数的活动对象(activation object)</li>
</ul>
</blockquote>

<p>每个执行环境都有一个<code>variable object</code>. 全局环境的<code>variable object</code>始终存在.而像<code>compare</code>函数的<code>variable object</code>只有在函数执行过程中存在, 函数执行完毕就会被销毁.</p>

<p>在创建和调用函数式, 各种内部对象的创建顺序:</p>

<ol>
<li>创建函数时, 会<strong>预先</strong>创建一个包含全局变量对象(<code>Global variable object</code>)的作用域链(<code>Scope chain</code>), 这个作用域链被保存在<code>[[Scope]]</code>中.</li>
<li>当执行函数时, 会为函数创建一个<code>execution context</code>, 然后通过<strong>复制</strong>函数的<code>[[Scope]]</code>属性中的对象构建起<code>execution context</code>中的<code>scope chain</code>.</li>
<li>创建一个该函数的活动对象(这个对象被当作该函数的<code>变量对象</code>), 随后被推入作用域链中.</li>
</ol>

<p>作用域链的本质是一个变量对象的指针链表, 它只引用而不包含实际的变量对象.</p>

<p>一般来说, 当函数执行完毕后, 它的局部活动对象就会被销毁, 内存中紧保存全局环境的活动对象.<br/>
但是, 闭包的情况又不一样.</p>

<h5 id="toc_6">闭包时的  函数局部活动对象 生命周期</h5>

<p>考虑一下闭包函数</p>

<pre><code class="language-js">function createComparisonFunction(propertyName) {
    
    return function(object1, object2) {
        let value1 = object1[propertyName];
        let value2 = object2[propertyName];
        
        if (value1 &lt; value2)
            return -1;
        if (value 1 &gt; value2)
            return 1;
        return 0
    };
}

let compareName = createComparisonFunction(&#39;name&#39;);

let result = compareName({ name: &#39;locust&#39; }, { name: &#39;chen&#39; });
</code></pre>

<p>由于<code>createComparisonFunction</code>返回了一个闭包函数, 而该函数内部引用了<code>createComparisonFunction</code>的形参<code>propertyName</code>, 这个<code>propertyName</code>存在于<code>createComparisonFunction</code>的<code>active object(活动对象)</code>中, 即使<code>createComparisonFunction</code>执行完毕, 但由于匿名函数的<code>作用域链</code>仍然引用这它的活动对象, 即使它执行完毕后仍然不会被销毁. 而是直到匿名函数也执行完毕后才会被销毁.<br/>
<img src="media/15114266480360/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-26%20%E4%B8%8A%E5%8D%8811.42.25.png" alt="屏幕快照 2017-11-26 上午11.42.25"/></p>

<h5 id="toc_7">闭包与变量</h5>

<p>从上一节可以看出, 闭包保存下的是整个活动对象, 而不是仅仅某个特殊的变量. 也就是说, 当我们创建闭包后, 改变被保存的变量的值时, 也会引起闭包中那个变量值得改变.</p>

<pre><code class="language-js">function createFunctions() {
    let result = [];
    for(var i = 0; i &lt; 10; i++) {
        result.push(function () {
            console.log(i);
        });
    }
    return result;
}
</code></pre>

<p>一种方法是创建另一个匿名函数强制让闭包的行为符合预期</p>

<pre><code class="language-js">function createFunctions() {
    let result = [];
    for(var i = 0; i &lt; 10; i++) {
        // 通过形参 num 捕抓循环不变量 i
        result.push( function(num) {
            return function() {
                // 闭包捕获 num
                console.log(num);
            }
        }(i));
    }
    return result;
}
</code></pre>

<p>另外一种方式是使用<code>let</code>或<code>const</code>来自动为变量创建不用的作用域</p>

<pre><code class="language-js">function createFunctions() {
    let result = [];
    for(let i = 0; i &lt; 10; i++) {
        result.push(function () {
            console.log(i);
        });
    }
    return result;
}
</code></pre>

<h5 id="toc_8">内存泄漏</h5>

<p>由于Js引擎大多采用引用计数作为垃圾回收的策略, 在某些实现中, 闭包会导致内存泄漏的问题, 例如在IE中运行下列代码</p>

<pre><code class="language-js">function assignHandler() {
    let element = document.getElementById(&quot;someElement&quot;);
    
    element.onclick = function() {
        alert(element.id);
    }
}
</code></pre>

<p>上述这段代码在匿名函数中保存了<code>assignHandler()</code>函数的活动对象, 只要匿名函数仍然存在, <code>element</code>的引用计数至少为1, 从而无法它的回收内存</p>

<p>正确的方法是将<code>element</code>置为null以解除它的引用计数.</p>

<pre><code class="language-js">function assignHandler() {
    let element = document.getElementById(&quot;someElement&quot;);
    let id = element.id;
    element.onclick = function() {
        alert(id);
    }
    element = null;
}
</code></pre>

<h4 id="toc_9">模仿块级作用域</h4>

<blockquote>
<p>在<code>ES6</code>之前, 变量生命的关键字只有<code>var</code>, <code>var</code>会导致提升, 所以在那时候<code>JavaScript</code>没有块级作用域概念</p>
</blockquote>

<pre><code class="language-js">function outputNumbers() {
    for(var i = 0; i &lt; 10; i++) {
        alert(i);
    }
    // 由于变量提升, 在作用域外仍能访问i
    alert(i);
}
</code></pre>

<p>但是, <strong>变量提升的终点是函数</strong>, 利用嵌套函数去限制变量提升的范围, 就能达到模拟块级作用域的效果了.</p>

<pre><code class="language-js">function outputNumbers() {
    
    (function () {
        for(var i = 0; i &lt; 10; i++) {
            alert(i);
        }
    })();
    
    alert(i);   // 抛出错误
}
</code></pre>

<p>当然在<code>ES6</code>后, 使用<code>let</code>和<code>const</code>就不会出现这样的问题了.</p>

<pre><code class="language-js">function outputNumbers() {
    for(let i = 0; i &lt; 10; i++) {
        alert(i);
    }

    alert(i);   // 抛出错误
}
</code></pre>

<h4 id="toc_10">私有变量</h4>

<p>利用闭包捕获私有变量, 从而使得只有闭包函数内部才能访问私有变量, 而无法从外部访问这个变量.</p>

<p>在<code>面向对象编程</code>中已经阐述过利用函数去模拟对象.</p>

<pre><code class="language-js">function MyObject() {
    // 创建私有变量
    let privateVariable = 10;
    
    // 创建私有方法
    function privateFunction() {
        return false;
    }
    
    // 创建公有方法
    this.publicFunction = function() {
        // 闭包捕获 privateVariable 与 privateFunction
        privateVariable++;
        return privateFunction();
    }
}

let myObject = new MyObject();
myObject.publicFunction();
</code></pre>

<h5 id="toc_11">静态私有变量</h5>

<p>当我们希望创建静态私有变量时, 同样可以使用上一节的方法, 但是<code>静态私有变量</code>特性一般是多个实例共享. 这样一来, 利用上一节的方法创建静态私有变量的方法就会造成不必要的内存浪费(每个实例都有一个静态私有变量的副本).</p>

<p>利用闭包解决这个问题.</p>

<pre><code class="language-js">let Person;
(function () {
    let name = &quot;locust&quot;;
    
    Person = function() {}
    
    Person.prototype.printName = function() { 
        // 多个实例共用的静态私有变量
        console.log(name);
    };  
})();

let p = new Person();
</code></pre>

<h5 id="toc_12">模块模式</h5>

<p><code>JavaScript</code>中没有模块的概念, 但我们可以利用函数去模拟模块的行为</p>

<pre><code class="language-js">let application = function() {
    
    // 私有变量和私有方法
    let components = [];
    
    // 初始化
    components.push(new components());
    
    // 返回公共函数
    return {
    
        getComponentCount: function() {
            return components.length;
        }
        
        registerComponent: function(component) {
            components.push(component);
        }
        
    }
}
</code></pre>

<h2 id="toc_13">第二十二章 高级技巧</h2>

<p><code>JavaScript</code>是一门及其灵活的语言, 也由于它是动态语言的属性, 为了更好、更安全地编写<code>JavaScript</code>代码, 我们还需要利用<code>ECMAScript</code>的特点编写更多的复杂和有趣的模式.</p>

<h3 id="toc_14">高级函数</h3>

<h4 id="toc_15">安全的类型检测</h4>

<p>JavaScript内置的类型检测机制并不靠谱, 例如<code>typeof</code>操作符在<code>safari</code>中对正则表达式使用会返回<code>function</code>, 又比如<code>instanceof</code>操作符, 对于某些对象来说, 必须是在同一全局作用域中生成的对象才能返回<code>true</code>.</p>

<p>由此, 我们需要更完善的类型检测机制: <code>Object.prototype.toString.call()</code>, 在任何值上调用这个方法, 都会返回类似于<code>[object NativeContructorName]</code>. 而每个类内部都会有一个特殊属性<code>[[Class]]</code>, 这个属性指定了<code>[object NativeContructorName]</code>中的<code>NativeContructorName</code>.</p>

<pre><code class="language-js">console.log(Object.prototype.toString.call([])) // 打印出&quot;[object Array]&quot;
</code></pre>

<p>由此可以实现一些根据构造函数判断变量类型的方法</p>

<pre><code class="language-js">isRegExp(value) {
    return Object.prototype.toString.call(value) === &#39;[object RegExp]&#39;;
}
</code></pre>

<h4 id="toc_16">作用域安全的构造函数</h4>

<p>JavaScript中的, 对构造函数使用<code>new</code>的时候, 会经历以下步骤</p>

<ol>
<li>创建一个新的对象</li>
<li>将构造函数的作用域赋给新的对象(也就是<code>this</code>指向了新的对象)</li>
<li>执行构造函数中的代码(给新对象添加属性和方法)</li>
<li>返回新对象</li>
</ol>

<p>正常情况下不会出现什么奇怪的问题</p>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
}

let person = new Person(&#39;locust&#39;, 22, &#39;coder&#39;);
</code></pre>

<p>然而, 当我们错误地编写代码, 漏掉了<code>new</code>操作符的话</p>

<pre><code class="language-js">let person = Person(&#39;locust&#39;, 22, &#39;coder&#39;);

console.log(window.name) // &#39;locust&#39;
console.log(window.age)  // 22 
console.log(window.job) // &#39;coder&#39;
</code></pre>

<p>不小心污染了<strong>全局作用域!</strong>, 而此时<code>person</code>对象也能正常读取, 在出现这种问题后会非常难以debug.</p>

<p>但是我们可以使用一种技巧构建<strong>作用域安全的构造函数</strong>, 判断当前环境是否为<code>构造函数所在环境</code></p>

<pre><code class="language-js">function Person(name, age, job) {
    if (this instanceof Person) {
        this.name = name;
        this.age  = age;
        this.job  = job;    
    } else {
        return new Person(name, age, job);
    }
}
</code></pre>

<h4 id="toc_17">惰性载入函数</h4>

<p>考虑以下情况的代码</p>

<pre><code class="language-js">window.name = &#39;firefox&#39;;
 
function foo() {
    if (window.name === &#39;firefox&#39;) {
        console.log(&#39;hello&#39;);
    } else if (window.name === &#39;chrome&#39;)
        console.log(&#39;world&#39;);
}

foo();
</code></pre>

<p><code>foo</code>函数在根据<code>window.name</code>属性打印出不同的字符. 假设我们的<code>window.name</code>属性一直都不变, 而每次执行<code>foo</code>函数式都要检测一边<code>window.name</code>就很浪费了.</p>

<p>我们可以利用<strong>惰性载入函数</strong>技巧, 只在第一次调用函数是判断条件, 并改变函数的内部语句.</p>

<pre><code class="language-js">let window = {};
window.name = &#39;firefox&#39;;
 
function foo() {
    if (window.name === &#39;firefox&#39;) {
        // 改变foo函数的值
        foo = function() {
            console.log(&#39;hello&#39;);
        }
    } else if (window.name === &#39;chrome&#39;){
        foo = function() {
            console.log(&#39;world&#39;);
        }
    }
    return foo();
}

foo(); // 打印出hello 
</code></pre>

<p>而这种方法在函数第一次被调用时仍然会有一次的性能损失, 更好的方法是, 利用函数表达式在声明函数式就指定适当的函数</p>

<pre><code class="language-js">let window = {};
window.name = &#39;firefox&#39;;

let foo = (function (){
    if (window.name === &#39;firefox&#39;) {
        return function() {
            console.log(&#39;hello&#39;);
        }
    } else if (window.name === &#39;chrome&#39;) {
        return function() {
            console.log(&#39;world&#39;);
        }
    }   
})();

foo(); // 打印出hello
</code></pre>

<h4 id="toc_18">函数绑定</h4>

<p>这一节展示的是ES5中<code>bind()</code>出现前是如何利用函数模拟函数绑定的.</p>

<pre><code class="language-js">let handler = {
    message: &#39;Event Handler&#39;,
    
    handleClick: function(event) {
        console.log(this.message);
    }
};
</code></pre>

<p>上面这段代码中的<code>handleClick</code>函数中输出<code>this.message</code>依赖于其所在的环境, 例如</p>

<pre><code class="language-js">let btn = document.getElementById(&#39;my-btn&#39;);
EventUtil.addHandler(btn, &#39;click&#39;, handler.handleClick);
</code></pre>

<p>上面这段代码的目的是在<code>my-btn</code>中添加点击事件监听器, 当<code>my-btn</code>被点击时触发<code>handler.handleClick</code>, 输出<code>Event Handler</code>这个信息. 然而实际输出的是<code>undefined</code>,原因是由于<code>handler.handleClick</code>所在的环境并不是<code>handler</code>, 此时他的<code>this</code>并不指向<code>handler</code>.</p>

<p>可以尝试用闭包去解决这个问题</p>

<pre><code class="language-js">let btn = document.getElementById(&#39;my-btn&#39;);
EventUtil.addHandler(btn, &#39;click&#39;, function(event) { 
    // 闭包捕获 handler 的作用域
    handler.handleClick(event);
});
</code></pre>

<p>也可以利用<code>Function.prototype.apply</code>这个函数去讲环境应用在函数上</p>

<pre><code class="language-js">function bind(fn, context) {
    return function() {
        return fn.apply(context, arguments);
    };
}

let btn = document.getElementById(&#39;my-btn&#39;);
EventUtil.addHandler(btn, &#39;click&#39;, bind(handler.handleClick, handler));
</code></pre>

<p>在<code>ES5</code>中增加的<code>Function.prototype.bind</code>方法也可以达到相同的效果</p>

<pre><code class="language-js">let btn = document.getElementById(&#39;my-btn&#39;);
EventUtil.addHandler(btn, &#39;click&#39;, handler.handleClick.bind(handler)));
</code></pre>

<h4 id="toc_19">函数柯里化</h4>

<p>函数柯里化技术是将原有函数的部分形参固定下来, 形成新的形参数量减少的函数.</p>

<pre><code class="language-js">function add(num1, num2) {
    return num1 + num2;
}

function curriedAdd(num) {
    return add(5, num);
}
</code></pre>

<p><code>curriedAdd</code>将<code>add</code>函数的形参1<code>num1</code>固定为5. 虽然<code>curriedAdd</code>并不是真正意义上的柯里化(它并没有返回一个新的函数), 但是这很好地阐述柯里化的概念.</p>

<p>创建一个用于柯里化函数的方法<code>curry</code></p>

<pre><code class="language-js">function curry(fn) {
    // 将 fn 以外的 形参列表保存在 args 中 
    let args = Array.prototype.slice.call(arguments, 1);
    return function() {
        // 获取内部匿名函数的形参列表
        let innerArgs = Array.prototype.slice.call(arguments);
        // 将余下的参数与之前保存的参数 args 结合起来
        let finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    };
}

function add(num1, num2) {
    return num1 + num2;
}

let curriedAdd = curry(add, 5);
</code></pre>

<p>也可以利用ES5中的<code>bind</code>函数实现柯里化, 根据<code>JavaScript MDN</code>的说法:</p>

<blockquote>
<ul>
<li><code>Function.prototype.bind(thisArg, [, arg1[, arg2[, ...]]])</code>:

<ul>
<li><code>thisArg</code>: The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.</li>
<li><code>arg1, arg2, ...</code>: Arguments to <strong>prepend(前置于)</strong> to arguments provided to the bound function when invoking the target function.</li>
</ul></li>
</ul>
</blockquote>

<p><code>bind</code>的柯里化用法:</p>

<pre><code class="language-js">function add(num1, num2) {
    return num1 + num2;
}

let curriedAdd = add.bind(null, 5);

curriedAdd(1) // 6
</code></pre>

<h3 id="toc_20">防篡改对象</h3>

<p>JavaScript中对于对象的封装性并没有原生保留字的支持(<code>final</code>, <code>private</code>)之类. 但是<code>EcmaScript</code>也定义了多个方法去封装我们的对象, 以实现<code>防篡改对象</code>.</p>

<h4 id="toc_21">不可扩展对象</h4>

<p>默认的对象都是可扩展的, 即是在对象定义好之后, 再去给他动态的添加属性, 例如</p>

<pre><code class="language-js">let person = { name: &#39;locust&#39; };
person.age = 21;
alert(person.age) // 21
</code></pre>

<p>有的时候并不希望对象是可以被扩展的, 这时可以使用<code>Ojbect.preventExtensions()</code>方法去将一个对象修改为不可扩展;</p>

<pre><code class="language-js">let person = { name: &#39;locust&#39; };
Ojbect.preventExtensions(person);

person.age = 21;
alert(person.age); // undefined
</code></pre>

<p>在非严格模式下, 给不可扩展添加属性会<strong>静默失败</strong>, 而在严格模式下则会抛出异常.<br/>
(要注意虽然对象是不可扩展的, 但是仍然可以对已有的属性进行修改和删除)</p>

<h4 id="toc_22">密封的对象</h4>

<p>密封对象通过<code>Object.seal()</code>将对象变为密封对象, <strong>密封对象</strong>比<strong>不可扩展对象</strong>有着更高的防篡改级别, 它并不允许删除属性.</p>

<pre><code class="language-js">let p = { name: &#39;locust&#39; };
Object.seal(p);

p.age = 1;
alert(p.age) // undefined

delete p.name;
alert(p.name); // &#39;locust&#39;
</code></pre>

<p>同样的, 在严格模式下会抛出异常.</p>

<h4 id="toc_23">冻结的对象</h4>

<p><code>frozen object</code>是最严格的防纂改级别, 完全不允许任何对对象(包括内部属性)的修改.</p>

<pre><code class="language-js">let p = { name: &#39;locust&#39; };

Object.freeze(p);

p.age = 21;
alert(p.age); // undefined

p.name = &#39;nico&#39;;
alert(p.name); // locust
</code></pre>

<h3 id="toc_24">高级定时器</h3>

<p><code>JavaScript</code>代码的解释与执行都是单线程的, 而其中定时器的执行也不例外, 它只是将代码延缓特定的时间后再执行, 并不是在另外的线程中执行它, 并且执行的时机也只能保证在定时到期后执行.</p>

<h4 id="toc_25">定时器特性</h4>

<pre><code class="language-js">let btn = document.getElementById(&quot;my-btn&quot;);
btn.onclick = function() {
    setTimeout(function() { alert(&#39;hello&#39;); }, 250);
}
</code></pre>

<p>上面的这段代码<code>my-btn</code>点击的时候往队列中添加一个250ms的定时器, 但要注意的是定时器不一定在250ms后运行, 而是至少在250ms后才运行.</p>

<p>假如<code>onclick</code>事件运行的300ms, 那么定时器代码也至少在300ms后才会被执行<img src="media/15114266480360/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-03%20%E4%B8%8A%E5%8D%8811.28.00.png" alt="屏幕快照 2017-12-03 上午11.28.00"/></p>

<h4 id="toc_26">重复的定时器</h4>

<p><code>setInterval</code>用于以指定的时间为间隔循环执行代码, 然而由于<code>JavaScript</code>中的定时器执行时机并不严格, 有可能由于之前添加的定时器仍未执行, 此时再添加新的定时器, 最后导致定时器重复执行好几次.</p>

<p>幸运的是<code>JavaScript</code>引擎在添加循环执行的定时器之前, 会检查定时器队列中是否仍然存在该定时器的其他代码实例, 不存在时才会将定时器添加进队列中.</p>

<p>这种策略也是存在两点问题: </p>

<ul>
<li>某些时间间隔可能会被跳过</li>
<li>多个定时器的时间间隔可能会比预期要小</li>
</ul>

<p>要解决这些问题, 使用嵌套的<code>setTimeout</code>就可以了</p>

<pre><code class="language-js">setTimeout(function onTimeout() {
    alert(&#39;timeout&#39;);
    setTimeout(onTimeout, 250);
    }, 250);
</code></pre>

<h4 id="toc_27">Yielding Processes</h4>

<p>在浏览器中<code>JavaScript</code>能获得的运算资源是有限的, 如果<code>JavaScript</code>在进行了长时间运算, 那么用户就会无法与浏览器进行交互, 在编写长时间运行的代码时, 先思考两个问题</p>

<ul>
<li>该处理是否需要同步完成?</li>
<li>数据是否必须按顺序处理?</li>
</ul>

<p>如果以上两个答案都是否, 那么可以尝试一种<code>数据分块</code>技术, 将数据分为多个块, 并利用定时器将其各个块在不同的事件内处理.</p>

<p>分块处理基本模式</p>

<pre><code class="language-js">setTimeout(function handler(){
    // pop出任务队列元素
    let item = array.shift();
    process(item);
    
    // 如果仍然有元素
    if (array.length !== 0)
        setTimeout(handler, 300);
}, 300);
</code></pre>

<h4 id="toc_28">函数节流</h4>

<p>浏览器中的某些计算要比其他计算耗时多很多, 例如<code>DOM</code>操作比起非<code>DOM</code>操作交互需要更多的CPU时间和内存. 在连续的进行过多的<code>DOM</code>相关操作可能会导致浏览器挂起甚至崩溃.</p>

<p>为了避免这种情况, 可以使用<code>函数节流</code>技术. 其基本思想是指: 某些代码不可以在没有间断的情况下重复执行.</p>

<pre><code class="language-js">let processer = {
    // 存储超时事件Id
    timeoutId: null;
    
    // 实际任务处理函数
    performProcessing: function() {
        ...
    }
    
    // 触发任务的函数
    process: function() {
        // 运行前先通过timeoutId, 清除上一个任务
        clearTimeout(this.timeoutId);
        // 存储定时器Id
        this.timeoutId = setTimeout(() =&gt; {
            // 100ms后执行performProcessing()
            this.performProcessing()
        }, 100);
    }
};
</code></pre>

<h4 id="toc_29">自定义事件</h4>

<p>这一节利用<code>JavaScript</code>实现观察者模式, 相当于<code>Node.js</code>中的<code>EventEmitter</code></p>

<pre><code class="language-js">let EventTarget = function(){
    this.handlers = {};
};

EventTarget.prototype = {
    // 指定构造函数
    contructor: EventTarget,
    
    // 添加事件监听函数
    addHandler: function(type, handler) {
        
        if (typeof this.handlers[type] === undefined)
            this.handlers[type] = [];
        
        this.handlers[type].push(handler);
    }
    
    
    // 生产者触发事件
    fire: function(event) {
        if (!event.target)
            event.target = this;
            
        if (Array.isArray(this.handlers[event.type])) { 
            const handlers = this.handlers[event.type];
            // 遍历订阅了该事件的处理函数
            for(let handler of handlers) {
                handler(event);
            }
        }
    }
    
    // 移除事件监听器
    removeHandler: function(type, handler) {
        if (Array.isArray(this.handlers[type]) &amp;&amp; this.handlers[type].length !== 0) {
            const handlers = this.handlers[type]
            let i = 0;
            // 查找出handler所在索引
            for(; i &lt; handlers.length; i++) {
                if (handler === handlers[i])
                    break;
            }
            
            // 利用splite函数删除对应索引上的元素
            handlers.splite(i, 1);
        }
    }
}
</code></pre>

<h4 id="toc_30">小结</h4>

<ul>
<li>可以使惰性载入函数, 将对于<strong>不变量</strong>的任何代码分支推迟到第一次函数调用时.</li>
<li>利用<code>bind</code>可以指定函数运行环境中的<code>this</code>, 也可以用于柯里化</li>
<li>不可扩展对象: 不允许给对象添加新的属性和方法</li>
<li>密封的对象: 也是不可扩展对象, 并且不允许删除对象的方法和属性</li>
<li>冻结的对象: 也是密封的对象, 并且完全不允许改变对象.</li>
<li>定时器的执行并没有严格的执行时机</li>
<li>遇到需要长时间计算的任务时, 可以考虑使用<code>数据分块</code>技术处理</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第八章]]></title>
    <link href="zerolocusta.github.io/15107096826964.html"/>
    <updated>2017-11-15T09:34:42+08:00</updated>
    <id>zerolocusta.github.io/15107096826964.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Universal JavaScript for Web Applications</h2>

<p>这一章主要讲述了如何在前后端同时使用JavaScript进行编程.</p>

<h3 id="toc_1">Sharing code with the browser</h3>

<p>由于Node.js与Chrome都是利用V8引擎进行JavaScript的代码解析与执行, 由此可以想象或许能在Node.js与浏览器之间共享同一份代码.</p>

<p>然而实际中并不可行, Node.js中在JavaScript的基础上针对服务器开发做了非常多的扩展, 例如<code>require</code>模块系统, <code>HTTP</code>、<code>fs</code>模块等, 而浏览器上也在JavaScript上增加了对<code>DOM</code>、<code>BOM</code>等操作</p>

<p>幸运的是, 越来越多的库同时支持了<code>Node.js</code>环境与浏览器环境.</p>

<h4 id="toc_2">Sharing modules</h4>

<p>首先要解决的是前后端中的模块系统问题, 浏览器环境中没有<code>require()</code>函数与文件系统的操作, 对于在<code>Node.js</code>中开发的代码来说, 首先需要对模块系统进行抽象, 然后才能让其正常运行在浏览器环境中.</p>

<h4 id="toc_3">Universal Module Definition</h4>

<p>对于浏览器环境, 可能会遇到下列情况:</p>

<ul>
<li>完全没有使用模块系统, 意味着只使用<code>script</code>标签引入, 并且将所有函数都加载在globle环境中.</li>
<li>使用了某种异步模块定义及加载系统(<code>Asynchronous Module Definition</code>), 例如<code>RequireJS</code></li>
<li>已经有了基于<code>Commonjs</code>的模块系统(也就是Node.js的模块系统)抽象</li>
</ul>

<p>由此引出统一模块定义<code>Universal Module Definition (UMD)</code>, 使用这种技巧在编写模块时去抽象统一多种状况中的模块系统问题.</p>

<h4 id="toc_4">Creating an UMD module</h4>

<p><code>UMD</code>模块将会检测当前运行环境, 并选择合适的函数去执行功能.</p>

<pre><code class="language-js">// umdModule.js

&quot;use strict&quot;;

(function (root, factory) {
  // 检查环境中是否存在 名为define的函数
  // define 函数是 AMD(Asynchronous Module Definition)标准
  // 中的API
  if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
    // 如果当前环境中使用了 AMD, 则利用define系统网factory函数中注入
    // mustache模块
    define([&#39;mustache&#39;], factory);
  } else if (typeof module === &#39;object&#39; &amp;&amp; // 检测当前环境是否为CommonJS标准
    typeof module.exports === &#39;object&#39;) {
    // 利用require函数引入 mustache 模块
    var mustache = require(&#39;mustache&#39;);
    module.exports = factory(mustache);
  } else {
    // 以上都不是, 在全局对象中导出模块
    root.UmdModule = factory(root.Mustache);
  }
}(this, function (mustache) {
  var template = &#39;&lt;h1&gt;Hello &lt;i&gt;{{name}}&lt;/i&gt;&lt;/h1&gt;&#39;;
  mustache.parse(template);

  return {
    sayHello: function (toWhom) {
      return mustache.render(template, {
        name: toWhom
      });
    }
  };
}));
</code></pre>

<p>在<code>Node.js</code>中的运行<code>umdModule.js</code></p>

<pre><code class="language-js">&quot;use strict&quot;;

const umdModule = require(&#39;./umdModule&#39;);

console.log(umdModule.sayHello(&#39;Server!&#39;));
</code></pre>

<p>运行结果<br/>
![](<img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-17%20%E4%B8%8B%E5%8D%885.24.39.png" alt="屏幕快照 2017-11-17 下午5.24.39"/></p>

<p>在浏览器中</p>

<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;script src=&quot;node_modules/mustache/mustache.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;umdModule.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        document.getElementById(&#39;main&#39;).innerHTML = UmdModule.sayHello(&#39;Browser!&#39;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>运行结果</p>

<p><img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-17%20%E4%B8%8B%E5%8D%885.26.20.png" alt="屏幕快照 2017-11-17 下午5.26.20"/></p>

<p>在AMD模型中运行</p>

<pre><code class="language-html">&lt;html&gt;

&lt;head&gt;
  &lt;title&gt;Load UMD module from AMD&lt;/title&gt;
  &lt;script src=&quot;node_modules/requirejs/require.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    window.addEventListener(&#39;load&#39;, function () {
      requirejs.config({
        baseUrl: &#39;node_modules&#39;,
        paths: {
          // 设置需要用到的库的路径
          mustache: &#39;./mustache/mustache&#39;,
          umdModule: &#39;../umdModule&#39;
        }
      });
      // 当`umdModule`加载完毕, 调用function
      require([&#39;umdModule&#39;], function (umdModule) {
        var hello = umdModule.sayHello(&#39;Browser!&#39;);
        var body = document.getElementsByTagName(&quot;body&quot;)[0];
        body.innerHTML = hello;
      });
    });
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>

<p>运行结果</p>

<p><img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-18%20%E4%B8%8A%E5%8D%889.33.05.png" alt="屏幕快照 2017-11-18 上午9.33.05"/></p>

<h4 id="toc_5">Considerations on the UMD pattern</h4>

<p>利用<code>UMD</code>模式去屏蔽各环境中模块差异非常简单且有效, 但是却造成难以测试, 并且对于各个环境中不同的异常处理也没解决, 而且JavaScript中也不知这三种模块管理系统, 如果需要手动匹配所有有可能出现的模块管理系统是非常麻烦的.</p>

<h3 id="toc_6">Introducing Webpack</h3>

<p>比起在代码中手动编写多种模块加载机制, 更好的方法是保持<code>Node.js</code>代码风格, 并利用第三方工具将代码编译至其他模块系统能识别的代码.</p>

<p><code>webpack</code>将所有应用需要用到的模块打包成单个JavaScript文件, 这样在浏览器中引用的时候只需将其引入即可.</p>

<h4 id="toc_7">Exploring the magic of Webpack</h4>

<blockquote>
<p>Webpack实战</p>
</blockquote>

<p>将上一节中的<code>umdModule.js</code>中的<code>UMD</code>模块适配部分去掉, 并将文件改名为<code>sayHello.js</code></p>

<pre><code class="language-js">// sayHello.js
&quot;use strict&quot;;

let mustache = require(&#39;mustache&#39;);
let template = &#39;&lt;h1&gt;Hello &lt;i&gt;{{name}}&lt;/i&gt;&lt;/h1&gt;&#39;;
mustache.parse(template);
module.exports.sayHello = function(toWhom) {
  return mustache.render(template, {name: toWhom});
};
</code></pre>

<p>在<code>main.js</code>中使用<code>sayHello</code>模块</p>

<pre><code class="language-js">&quot;use strict&quot;;

window.addEventListener(&#39;load&#39;, function() {
  // 利用`Node.js`的模块机制
  var sayHello = require(&#39;./sayHello&#39;).sayHello;
  var hello = sayHello(&#39;Browser!&#39;);
  var body = document.getElementsByTagName(&quot;body&quot;)[0];
  body.innerHTML = hello;
});
</code></pre>

<p>然后运行<code>webpsck main.js bundle.js</code>, 将<code>main.js</code>中的代码及依赖生成到<code>bundle.js</code>中, 最后在<code>HTML</code>代码中引入<code>bundle.js</code>即可.</p>

<p>(webpsck 生成的<code>bundle.js</code>将分析所有用到的函数, 并组合到单个文件中, 代码较庞大)</p>

<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Webpack magic&lt;/title&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>运行结果</p>

<p><img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-18%20%E4%B8%8A%E5%8D%889.33.05.png" alt="屏幕快照 2017-11-18 上午9.33.05"/></p>

<h4 id="toc_8">The advantages of using Webpack</h4>

<ul>
<li><code>webpack</code>提供了许多<code>Nodejs</code>中的核心模块(<code>fs</code>、<code>http</code>等)能运行在浏览器中的版本, 可以无所顾虑地使用.</li>
<li>对于某些无法被转换至浏览器环境中使用的代码, <code>webpack</code>支持使用其他模块去替换掉.</li>
<li>可以为不同模块生成不同的<code>bundle</code></li>
<li>可以使用不同的模块加载系统</li>
<li>可以通过配置, 处理<code>JavaScript</code>以外的代码, 例如css, html等</li>
<li>除了通过<code>webpack</code>生成单个文件, 也可以将app生成多个不同的文件.</li>
</ul>

<h3 id="toc_9">Fundamentals of cross-platform development</h3>

<blockquote>
<p>跨平台开发的基本技巧</p>
</blockquote>

<h4 id="toc_10">Runtime code branching</h4>

<blockquote>
<p>运行时代码分支切换</p>
</blockquote>

<p>通过检测特性环境中的特性对象及方法, 例如浏览器中的<code>window</code>与<code>window.document</code>对象.</p>

<pre><code class="language-js">&quot;use strict&quot;;
// 检测当前环境中的 window 对象
// 选择不同的分支
if (typeof window !== &quot;undefined&quot; &amp;&amp; window.document) {
  console.log(&#39;Hey browser!&#39;);
} else {
  console.log(&#39;Hey Node.js!&#39;);
}
</code></pre>

<p>不难看出这是一种非常简陋的处理方式, 实际中非常不建议这样做.</p>

<h4 id="toc_11">Build-time code branching</h4>

<blockquote>
<p>编译时代码分支切换</p>
</blockquote>

<p>这一节同样是使用<code>webpack</code>, 但通过配置文件和<code>webpack</code>模块提供的方法, 改变<code>webpack</code>在编译时的行为.</p>

<p>通过配置<code>webpack.config.js</code>进行对<code>webpack</code>编译行为的修改</p>

<p><code>webpack</code>提供了几个插件用于修改编译行为, 其中</p>

<ul>
<li><code>DefinePlugin</code>: 用于定义预编译变量, 也可以修改源文件中的某个值, 与宏定义相似</li>
<li><code>UglifyJsPlugin</code>: 指定如何压缩编译后的源码, 例如移除不可达的代码</li>
</ul>

<pre><code class="language-js">// webpack.config.js
&quot;use strict&quot;;

const path = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);

const definePlugin = new webpack.DefinePlugin({
  // 定义预编译变量 __BROWSER__
  &quot;__BROWSER__&quot;: &quot;true&quot;
});

const uglify = new webpack.optimize.UglifyJsPlugin({
  // 设置美化输出
  beautify: true,
  // 移除不可达代码
  dead_code: true
});

module.exports = {
  entry:  path.join(__dirname, &quot;src&quot;, &quot;main.js&quot;),
  output: {
    path: path.join(__dirname, &quot;dist&quot;),
    filename: &quot;bundle.js&quot;
  },
  plugins: [definePlugin, uglify]
};
</code></pre>

<p><code>main.js</code></p>

<pre><code class="language-js">&quot;use strict&quot;;

if (typeof __BROWSER__ !== &quot;undefined&quot;) {
  console.log(&#39;Hey browser!&#39;);
} else {
  console.log(&#39;Hey Node.js!&#39;);
}
</code></pre>

<p>最后生成的代码</p>

<pre><code class="language-js">!function(r) {
    function e(t) {
        if (o[t]) return o[t].exports;
        var n = o[t] = {
            exports: {},
            id: t,
            loaded: !1
        };
        return r[t].call(n.exports, n, n.exports, e), n.loaded = !0, n.exports;
    }
    var o = {};
    return e.m = r, e.c = o, e.p = &quot;&quot;, e(0);
}([ function(r, e, o) {
    &quot;use strict&quot;;
    console.log(&quot;Hey browser!&quot;);
} ]);
</code></pre>

<p>由于<code>__BROWSER__</code>条件为<code>true</code>, <code>main.js</code>中的<code>if...else</code>语句直接被简化了.</p>

<h4 id="toc_12">Module swapping</h4>

<p>利用<code>webpack</code>实现两种模块替换技术:</p>

<ul>
<li>引用模块时通过变量名而不是<code>require</code>, 利用<code>DefinePlugin</code>根据不同环境定义该变量的值.</li>
</ul>

<pre><code class="language-js">// main.js
&quot;use strict&quot;;
// 这段代码无法在使用webpack编译前无法正常运行
const now = __NOW__;
const platform = __PLATFORM__;
const host = __HOST__;

console.log(`Bundle compiled on &quot;${now}&quot; on &quot;${platform}&quot; by &quot;${host}&quot;`);
</code></pre>

<p>配置<code>webpack.config.js</code></p>

<pre><code class="language-js">&quot;use strict&quot;;

const path = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);
const os = require(&#39;os&#39;);

let definePlugin = new webpack.DefinePlugin({
  &quot;__NOW__&quot;: JSON.stringify((new Date()).toString()),
  &quot;__PLATFORM__&quot;: JSON.stringify(os.platform()),
  &quot;__HOST__&quot;: JSON.stringify(os.hostname())
});

module.exports = {
  entry:  path.join(__dirname, &quot;src&quot;, &quot;main.js&quot;),
  output: {
    path: path.join(__dirname, &quot;dist&quot;),
    filename: &quot;bundle.js&quot;
  },
  plugins: [definePlugin]
};
</code></pre>

<p>编译后运行结果:</p>

<p><img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-18%20%E4%B8%8B%E5%8D%889.32.29.png" alt="屏幕快照 2017-11-18 下午9.32.29"/></p>

<ul>
<li>通过搜索替换<code>require</code>函数中引入的模块名</li>
</ul>

<p><code>webpack</code>提供了<code>NormalModuleReplacementPlugin</code>的插件, 用于搜索特定模块名并替换</p>

<pre><code class="language-js">// alertServer.js
&quot;use strict&quot;;

module.exports = console.log;
</code></pre>

<pre><code class="language-js">// alertBrowser.js
&quot;use strict&quot;;

module.exports = alert;
</code></pre>

<pre><code class="language-js">// main.js
&quot;use strict&quot;;

const alert = require(&#39;./alertServer&#39;);
alert(&#39;Morning comes whether you set the alarm or not!&#39;);
</code></pre>

<p>通过<code>NormalModuleReplacementPlugin</code>搜索<code>alertServer.js</code>模块名, 并替换为<code>alertBrowser.js</code></p>

<pre><code class="language-js">// webpack.config.js
&quot;use strict&quot;;

const path = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);

let moduleReplacementPlugin =
  // 搜索 alertServer.js 替换为 alertBrowser.js
  new webpack.NormalModuleReplacementPlugin(/alertServer.js$/, &#39;./alertBrowser.js&#39;);

module.exports = {
  entry:  path.join(__dirname, &quot;src&quot;, &quot;main.js&quot;),
  output: {
    path: path.join(__dirname, &quot;dist&quot;),
    filename: &quot;bundle.js&quot;
  },
  // 引入插件
  plugins: [moduleReplacementPlugin]
};
</code></pre>

<p>编译后文件的主要部分</p>

<pre><code class="language-js">([
    (function (module, exports, __webpack_require__) {
        &quot;use strict&quot;;
        const alert = __webpack_require__(1);
        alert(&#39;Morning comes whether you set the alarm or not!&#39;);
    }), 
    
    (function (module, exports) {
        &quot;use strict&quot;;
        // 模块已经从 console.log 转换为 alert
        module.exports = alert;
    })
]);
</code></pre>

<h4 id="toc_13">Design patterns for cross-platform development</h4>

<blockquote>
<p>利用设计模式进行跨平台开发</p>
</blockquote>

<ul>
<li>策略模式: 根据不同的运行环境使用不同的策略, 与根据<code>window</code>对象选择不同执行代码类似</li>
<li>模板模式: 无论是<code>node.js</code>平台或是浏览器环境, 分别针对两个环境做出不同的实现, 同时对外提供相同的接口.</li>
<li>适配器模式: 对于浏览器环境不支持的模块, 例如<code>fs</code>, <code>timer</code>等, 可以利用适配器模式创建新的同名模块并模拟他们的行为</li>
<li>代理模式: 对于浏览器不支持的环境, 可以利用<code>Proxy</code>通过<code>Ajax</code>或<code>websocket</code>与服务器进行通讯, 模拟远程模块的行为.</li>
<li>观察者模式: 生产者与消费者之间天然是解耦的, 在编写消费者时要注意尽量不适用平台Nodejs特有代码, 而只需在编写生产者时准备两种运行环境的代码即可</li>
<li>依赖注入模式: 对于不同运行环境注入不同的模块</li>
</ul>

<h3 id="toc_14">Introducing React</h3>

<p><code>React</code>支持使用<code>Node.js</code>风格进行前端开发, 利用模块化, <code>npm</code>进行项目管理和开发</p>

<h4 id="toc_15">First React component</h4>

<blockquote>
<p>创建一个用于显示书籍列表的前端页面</p>
</blockquote>

<pre><code class="language-js">// joyceBooks.js
&quot;use strict&quot;;

const React = require(&#39;react&#39;);

const books = [
  &#39;Dubliners&#39;,
  &#39;A Portrait of the Artist as a Young Man&#39;,
  &#39;Exiles and poetry&#39;,
  &#39;Ulysses&#39;,
  &#39;Finnegans Wake&#39;
];

class JoyceBooks extends React.Component {
  render() {
    return (
      // JSX 代码, 在HTML中嵌入JS-like代码
      &lt;div&gt;
        &lt;h2&gt;James Joyce&#39;s major works&lt;/h2&gt;
        &lt;ul className=&quot;books&quot;&gt;{
          books.map( (book, key) =&gt;
              &lt;li key={key} className=&quot;book&quot;&gt;{book}&lt;/li&gt;
          )
        }&lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

module.exports = JoyceBooks;
</code></pre>

<p>JSX代码并不能在浏览器或<code>Nodejs</code>平台中正常解析, 同样需要通过<code>webpack</code>进行编译</p>

<p>编译后的代码类似于</p>

<pre><code class="language-js function">  return React.createElement(
    &#39;div&#39;,
    null,
    React.createElement(&#39;h2&#39;, null, &#39;James Joyce\&#39;s major works&#39;),
    React.createElement(&#39;ul&#39;, {
      className: &#39;books&#39;
    }, books.map(function (book) {
      return React.createElement(&#39;li&#39;, {
        className: &#39;book&#39;
      }, book);
    })));
}
</code></pre>

<p>上面的代码创建了一个用于显示<code>JoyceBooks</code>的组件, 但还未创建将它显示在浏览器中的代码</p>

<pre><code class="language-js">// main.js
&quot;use strict&quot;;

const React = require(&#39;react&#39;);
const ReactDOM = require(&#39;react-dom&#39;);
const JoyceBooks = require(&#39;./joyceBooks&#39;);

window.onload = () =&gt; {
  // 当前页面加载完成时, 将 JoyceBooks DOM显示值id为 main 的元素中
  ReactDOM.render(&lt;JoyceBooks/&gt;, document.getElementById(&#39;main&#39;))
};
</code></pre>

<p>使用<code>webpack</code>进行编译, 最后在浏览器输出的结果</p>

<p><img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-19%20%E4%B8%8A%E5%8D%8810.43.05.png" alt="屏幕快照 2017-11-19 上午10.43.05"/></p>

<pre><code class="language-html">&lt;ul class=&quot;books&quot;&gt;
    &lt;li class=&quot;book&quot;&gt;Dubliners&lt;/li&gt;
    &lt;li class=&quot;book&quot;&gt;A Portrait of the Artist as a Young Man&lt;/li&gt;
    &lt;li class=&quot;book&quot;&gt;Exiles and poetry&lt;/li&gt;
    &lt;li class=&quot;book&quot;&gt;Ulysses&lt;/li&gt;
    &lt;li class=&quot;book&quot;&gt;Finnegans Wake&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h3 id="toc_16">Creating a Universal JavaScript app</h3>

<blockquote>
<p>编写一个前后端都为JS栈的app</p>
</blockquote>

<p>编写一个前端显示书本列表并从后台拉取数据的Js应用</p>

<h4 id="toc_17">Creating reusable components</h4>

<p>首先利用虚拟数据模拟后端返回的数据</p>

<pre><code class="language-js">// authors.js
&quot;use strict&quot;;

module.exports = {

  &#39;joyce&#39;: {
    &#39;name&#39;: &#39;James Joyce&#39;,
    &#39;books&#39;: [
      &#39;Dubliners&#39;,
      &#39;A Portrait of the Artist as a Young Man&#39;,
      &#39;Exiles and poetry&#39;,
      &#39;Ulysses&#39;,
      &#39;Finnegans Wake&#39;
    ]
  },

  &#39;h-g-wells&#39;: {
    &#39;name&#39;: &#39;Herbert George Wells&#39;,
    &#39;books&#39;: [
      &#39;The Time Machine&#39;,
      &#39;The War of the Worlds&#39;,
      &#39;The First Men in the Moon&#39;,
      &#39;The Invisible Man&#39;
    ]
  }
};
</code></pre>

<ul>
<li>编写用于显示书本列表的<code>React</code>组件</li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const React = require(&#39;react&#39;);
const Link = require(&#39;react-router&#39;).Link;
// 从 authors 模块获取所有作者及其著作信息
const AUTHORS = require(&#39;../authors&#39;);

class AuthorPage extends React.Component {
  render() {
    // 根据id获取
    const author = AUTHORS[this.props.params.id];
    return (
      &lt;div&gt;
        // 显示作者名称
        &lt;h2&gt;{author.name}&#39;s major works&lt;/h2&gt;
        &lt;ul className=&quot;books&quot;&gt;{
          // 遍历生成著作列表
          author.books.map( (book, key) =&gt;
            &lt;li key={key} className=&quot;book&quot;&gt;{book}&lt;/li&gt;
          )
        }&lt;/ul&gt;
        // 提供跳转回index的链接
        &lt;Link to=&quot;/&quot;&gt;Go back to index&lt;/Link&gt;
      &lt;/div&gt;
    );
  }
}

module.exports = AuthorPage;
</code></pre>

<ul>
<li>作者列表组件</li>
</ul>

<pre><code class="language-js">// authorsIndex.js
&quot;use strict&quot;;

const React = require(&#39;react&#39;);
const Link = require(&#39;react-router&#39;).Link;
const AUTHORS = require(&#39;../authors&#39;);

class AuthorsIndex extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;List of authors&lt;/h1&gt;
        &lt;ul&gt;{
          // 遍历作者名称, 生成列表
          Object.keys(AUTHORS).map(id =&gt;
            &lt;li key={id}&gt;&lt;Link to={`/author/${id}`}&gt;{AUTHORS[id].name}&lt;/Link&gt;&lt;/li&gt;
          )
        }&lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}

module.exports = AuthorsIndex;
</code></pre>

<p>由于这是一个SPA, 还需要模拟路由的组件</p>

<pre><code class="language-js">&quot;use strict&quot;;

const React = require(&#39;react&#39;);
const ReactRouter = require(&#39;react-router&#39;);
const Router = ReactRouter.Router;
const hashHistory = ReactRouter.hashHistory;
const AuthorsIndex = require(&#39;./components/authorsIndex&#39;);
const AuthorPage = require(&#39;./components/authorPage&#39;);
const NotFound = require(&#39;./components/notFound&#39;);

const routesConfig = [
  // &#39;/&#39; 根目录重定向为 AuthorsIndex
  {path: &#39;/&#39;, component: AuthorsIndex},
  // &#39;/author/:id&#39; 路径重定向为 AuthorsIndex
  {path: &#39;/author/:id&#39;, component: AuthorPage},
  // &#39;*&#39; 其他路径重定向到NotFound
  {path: &#39;*&#39;, component: NotFound}
];

class Routes extends React.Component {
  render() {
    return &lt;Router history={hashHistory} routes={routesConfig}/&gt;;
  }
}

module.exports = Routes;
</code></pre>

<p>利用<code>webpack</code>编译后的运行结果</p>

<p><img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-19%20%E4%B8%8A%E5%8D%8811.30.45.png" alt="屏幕快照 2017-11-19 上午11.30.45"/><br/>
<img src="media/15107096826964/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-19%20%E4%B8%8A%E5%8D%8811.30.51.png" alt="屏幕快照 2017-11-19 上午11.30.51"/></p>

<h4 id="toc_18">Server-side rendering</h4>

<p>这一节使用的是采用MVC模式, 从后台利用<code>Express</code>与<code>ejs</code>模板引擎发送<code>HTML</code>代码.</p>

<ul>
<li><code>view/index.ejs</code></li>
</ul>

<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;React Example - Authors archive&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;
        // markup 标记
        // 利用ejs进行替换
        &lt;%- markup -%&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<ul>
<li><code>server.js</code></li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const http = require(&#39;http&#39;);
const Express = require(&#39;express&#39;);
const React = require(&#39;react&#39;);
const ReactDom = require(&#39;react-dom/server&#39;);
const Router = require(&#39;react-router&#39;);
const routesConfig = require(&#39;./src/routesConfig&#39;);

const app = new Express();
const server = new http.Server(app);

app.set(&#39;view engine&#39;, &#39;ejs&#39;);

app.get(&#39;*&#39;, (req, res) =&gt; {
  Router.match(
    // 传入 路由设置 与 请求url
    {routes: routesConfig, location: req.url},
    (error, redirectLocation, renderProps) =&gt; {
      if (error) {
        res.status(500).send(error.message)
      } else if (redirectLocation) {
        // 检测是否需要重定向
        res.redirect(302, redirectLocation.pathname + redirectLocation.search)
      } else if (renderProps) {
        // 根据路径生成对应HTML文本
        let markup = ReactDom.renderToString(&lt;Router.RouterContext {...renderProps} /&gt;);
        // 将文本发送至浏览器
        res.render(&#39;index&#39;, {markup});
      } else {
        res.status(404).send(&#39;Not found&#39;)
      }
    });
});

server.listen(3000, (err) =&gt; {
  if (err) {
    return console.error(err);
  }
  console.info(&#39;Server running on http://localhost:3000&#39;);
});&quot;use strict&quot;;

const http = require(&#39;http&#39;);
const Express = require(&#39;express&#39;);
const React = require(&#39;react&#39;);
const ReactDom = require(&#39;react-dom/server&#39;);
const Router = require(&#39;react-router&#39;);
const routesConfig = require(&#39;./src/routesConfig&#39;);

const app = new Express();
const server = new http.Server(app);

app.set(&#39;view engine&#39;, &#39;ejs&#39;);

// 将所有GET请求路由到该函数
app.get(&#39;*&#39;, (req, res) =&gt; {
  Router.match(
    // 传入 路由设置 与 请求url
    {routes: routesConfig, location: req.url},
    (error, redirectLocation, renderProps) =&gt; {
      if (error) {
        res.status(500).send(error.message)
      } else if (redirectLocation) {
        // 检测是否需要重定向
        res.redirect(302, redirectLocation.pathname + redirectLocation.search)
      } else if (renderProps) {
        // 根据路径生成对应HTML文本
        let markup = ReactDom.renderToString(&lt;Router.RouterContext {...renderProps} /&gt;);
        // 将文本发送至浏览器
        res.render(&#39;index&#39;, {markup});
      } else {
        res.status(404).send(&#39;Not found&#39;)
      }
    });
});

server.listen(3000, (err) =&gt; {
  if (err) {
    return console.error(err);
  }
  console.info(&#39;Server running on http://localhost:3000&#39;);
});
</code></pre>

<p>由此一来, 这个APP从 SPA 转换成了普通的 Server-Base APP</p>

<p><img src="media/15107096826964/spa.png" alt="spa"/></p>

<p>转变为</p>

<p><img src="media/15107096826964/server-side.png" alt="server-side"/></p>

<h3 id="toc_19">Universal data retrieval</h3>

<p>根据<code>SPA</code>风格的APP可以看出, 前端需要的只是作者及其著作的数据<br/>
因此完全可以转换为 前端通过<code>AJAX</code>获取数据并改变<code>DOM</code>, 后端通过<code>API</code>接口返回数据即可</p>

<h4 id="toc_20">The API server</h4>

<p>后台通过提供HTTP API的形式返回作者数据.</p>

<pre><code class="language-js">&quot;use strict&quot;;

const http = require(&#39;http&#39;);
const Express = require(&#39;express&#39;);

const app = new Express();
const server = new http.Server(app);
// authors数据源
const AUTHORS = require(&#39;./src/authors&#39;);
// logger组件
app.use((req, res, next) =&gt; {
  console.log(`Received request: ${req.method} ${req.url} from ${req.headers[&#39;user-agent&#39;]}`);
  next();
});
// 
app.get(&#39;/authors&#39;, (req, res, next) =&gt; {
  const data = Object.keys(AUTHORS).map(id =&gt; {
    // 以JSON的形式返回id与作者名称
    return {
      &#39;id&#39;: id,
      &#39;name&#39;: AUTHORS[id].name
    };
  });
  res.json(data);
});

app.get(&#39;/authors/:id&#39;, (req, res, next) =&gt; {
  if (!AUTHORS.hasOwnProperty(req.params.id)) {
    // id不存在即返回
    return next();
  }
  // 根据id获取作者详细
  const data = AUTHORS[req.params.id];
  res.json(data);
});

server.listen(3001, (err) =&gt; {
  if (err) {
    return console.error(err);
  }
  console.info(&#39;API Server running on http://localhost:3001&#39;);
});
</code></pre>

<h4 id="toc_21">Asynchronous React components</h4>

<p>前端改为异步从后台拉取数据, 并将数据渲染至HTML中</p>

<p>这里用到了<code>axios</code>的库, <code>axios</code>用于对Ajax进行抽象并返回一个<code>promise</code></p>

<ul>
<li>作者信息索引 <code>authorIndex.js</code></li>
</ul>

<pre><code class="language-js">// authorIndex.js

const Axios = require(&#39;axios&#39;);

const React = require(&#39;react&#39;);
const Link = require(&#39;react-router&#39;).Link;
const xhrClient = Axios.create({ &#39;http://localhost:3001&#39; });

class AuthorsIndex extends React.Component {
  // 组件载入时通过ajax获取后台信息
  static loadProps(context, cb) {
    xhrClient.get(&#39;authors&#39;)
      .then(response =&gt; {
        const authors = response.data;
        cb(null, {authors});
      })
      .catch(error =&gt; cb(error))
    ;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;List of authors&lt;/h1&gt;
        &lt;ul&gt;{
          // this.props.authors在页面加载前就已经通过 loadProps 从服务器获取了
          this.props.authors.map(author =&gt;
            &lt;li key={author.id}&gt;
              &lt;Link to={`/author/${author.id}`}&gt;{author.name}&lt;/Link&gt;
            &lt;/li&gt;
          )
        }&lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}

module.exports = AuthorsIndex;
</code></pre>

<ul>
<li>作者详细著作信息 <code>authorPage.js</code></li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const Axios = require(&#39;axios&#39;);

const React = require(&#39;react&#39;);
const Link = require(&#39;react-router&#39;).Link;
const xhrClient = Axios.create({ &#39;http://localhost:3001&#39; });

class AuthorPage extends React.Component {
  static loadProps(context, cb) {
    xhrClient.get(`authors/${context.params.id}`)
      .then(response =&gt; {
        const author = response.data;
        cb(null, {author});
      })
      .catch(error =&gt; cb(error))
    ;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;{this.props.author.name}&#39;s major works&lt;/h2&gt;
        &lt;ul className=&quot;books&quot;&gt;{
          this.props.author.books.map( (book, key) =&gt;
            &lt;li key={key} className=&quot;book&quot;&gt;{book}&lt;/li&gt;
          )
        }&lt;/ul&gt;
        &lt;Link to=&quot;/&quot;&gt;Go back to index&lt;/Link&gt;
      &lt;/div&gt;
    );
  }
}

module.exports = AuthorPage;
</code></pre>

<ul>
<li>最后是前端路由<code>route.js</code>, 已完成SPA特性</li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const React = require(&#39;react&#39;);
const AsyncProps = require(&#39;async-props&#39;).default;
const ReactRouter = require(&#39;react-router&#39;);
const Router = ReactRouter.Router;
const browserHistory = ReactRouter.browserHistory;
const routesConfig = require(&#39;./routesConfig&#39;);

class Routes extends React.Component {
  render() {
    return &lt;Router
      history={browserHistory}
      routes={routesConfig}
      render={(props) =&gt; &lt;AsyncProps {...props}/&gt;}
    /&gt;;
  }
}

module.exports = Routes;
</code></pre>

<p>最后模型转变为<br/>
<img src="media/15107096826964/123.png" alt="123"/></p>

<h3 id="toc_22">总结</h3>

<p>浏览器和<code>Node.js</code>的<code>JavaScript</code>运行环境在标准库, 编写风格和函数行为上的表现都大不相同.即使如此, 利用<code>Node.js</code>的模块管理与<code>npm</code>包管理系统编写前端代码, 然后利用<code>webpack</code>之类的编译工具编译到符合浏览器标准的代码, 构成了完整的<code>JavaScript</code>生态, 前后端web开发减少了思维切换的难度, 非常不错.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript高级程序设计 · 4、5、6 章]]></title>
    <link href="zerolocusta.github.io/15101331051720.html"/>
    <updated>2017-11-08T17:25:05+08:00</updated>
    <id>zerolocusta.github.io/15101331051720.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">第四章 变量、作用域和内存问题</h2>

<p>本章将探讨</p>

<ul>
<li>基本类型和引用类型的值</li>
<li>执行环境</li>
<li>垃圾回收</li>
</ul>

<h3 id="toc_1">基本类型和引用类型的值</h3>

<ul>
<li>基本类型包括<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>. 这五种基本数据类型是按值传递.</li>
<li>引用类型的值是保存在内存中的对象.由于JavaScript不允许直接操作内存, 在操作对象时, 实际上是在操作对象的引用.</li>
</ul>

<h4 id="toc_2">动态属性</h4>

<p>可以再对象创建后给对象添加新的属性</p>

<pre><code class="language-js">let person = new Object();
person.name = &#39;locust&#39;;
console.log(person.name) // &#39;locust&#39;
</code></pre>

<p>但无法给基础类型添加新的属性</p>

<pre><code class="language-js">let name = &#39;locust&#39;;
name.age = 21;
console.log(name.age) // undefined
</code></pre>

<h4 id="toc_3">复制变量值</h4>

<p>对于基本类型, 从一个变量复制另一个基本变量的值时, 会在变量对象上创建新的值<br/>
<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%888.49.58.png" alt="屏幕快照 2017-11-08 下午8.49.58"/></p>

<p>对于引用类型, 当一个变量复制另一个变量的值时, 会将引用复制一份到新的变量中, 并且指向相同的对象</p>

<pre><code class="language-js let">let obj2 = obj1;
obj2.name = &#39;locust&#39;;
console.log(obj.name) // locust
</code></pre>

<p><img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%889.46.10.png" alt="屏幕快照 2017-11-08 下午9.46.10"/></p>

<h4 id="toc_4">传递参数</h4>

<p>无论是基本类型或是引用类型, 对于函数传参都是按值传递的.</p>

<p>对于基本类型很容易理解</p>

<pre><code class="language-js">function addOne(num) {
    num += 1;
    return num;
}
let ten = 10;
console.log(addOne(ten)) // 11
console.log(ten) // 10
</code></pre>

<p>而对于引用类型, 是将<strong>引用</strong>复制到形参中, 形参和实参都同时指向内存中的对象.</p>

<pre><code class="language-js">function setName(obj) {
    obj.name = &#39;locust&#39;;
}

let person = new Object();
setName(person);
console.log(person.name) // locust
</code></pre>

<p>上面这段代码看似是按引用传递的, 但其实是将引用的值复制并传递<br/>
以下代码可以验证</p>

<pre><code class="language-js">function setName(obj) {
    obj = new Object();
    obj.name = &#39;locust&#39;;
}

let person = new Object();
person.name = &#39;Jason&#39;;
setName(person);
console.log(person.name) // Jason
</code></pre>

<h4 id="toc_5">检测类型</h4>

<ul>
<li><code>typeof</code>操作符: 对于基本类型, 能给出详细的类型信息, 但对于引用类型, 只能给出<code>object</code></li>
<li><code>instanceof</code> 用于检测一个变量中的值是否是某个类的实例</li>
</ul>

<h4 id="toc_6">执行环境和作用域</h4>

<ul>
<li><code>执行环境(execution context)</code>, 定义了变量或函数有权访问的其他数据.每个执行环境都有一个与之关联的<code>变量对象(variable object)</code>, 环境中定义的所有变量和函数都保存在这个对象中.</li>
<li><code>作用域链</code>, 当代码在一个环境中执行时, 会创建<code>变量对象(variable object)</code>的作用域链.</li>
<li><strong>标识符的搜索是沿着作用域链一级一级往上搜索</strong>.</li>
</ul>

<pre><code class="language-js">let color = &#39;blue&#39;;
  
function changeColor() {
    let anotherColor = &#39;red&#39;;
    
    function swapColors() {
        let tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
    }
    
    swapColors();
}
changeColor();

// 作用域链示例
window
├── color
└── changeColor()
    ├── anotherColor
    └── swapColor()
        └── tempColor
</code></pre>

<h4 id="toc_7">块级作用域</h4>

<ul>
<li><code>var</code>会导致<strong>提升(hoisting)</strong></li>
<li>ES6后建议使用<code>let</code>与<code>const</code></li>
</ul>

<h3 id="toc_8">垃圾收集</h3>

<p>JavaScript具有自动垃圾回收机制, 无需手动申请及释放内存空间.</p>

<h4 id="toc_9">标记请除(mark-and-sweep)</h4>

<p>当变量进入环境时,就将这个变量标记为<code>进入环境</code>, 不允许释放进入环境的变量.<br/>
当变量离开环境时,将其标记为<code>离开环境</code>.<br/>
垃圾收集器会根据标记找出无法再访问的变量并清除.</p>

<h4 id="toc_10">引用计数</h4>

<p>当引用类型被赋予某个变量时, 那么引用的对象引用计数将会加1. 当引用计数变成0时, 表示没有办法再次访问该对象, 将会被垃圾收集器清除.</p>

<h5 id="toc_11">循环引用</h5>

<p>两个对象互相包含对方的引用将会导致循环引用问题, 此时引用计数永远不会为0, 无法被回收.</p>

<pre><code class="language-js">let objA = new Object();
let objB = new Object();
 
objA.foo = objB;
objB.bar = objA;
</code></pre>

<p>想要解决循环引用问题, 需要手动<code>解除引用(dereferencing)</code></p>

<pre><code class="language-js">objA.foo = null;
objB.bar = null;
</code></pre>

<h2 id="toc_12">第五章 引用类型</h2>

<h3 id="toc_13"><code>Object</code>类型</h3>

<p>对象类型的行为与字典相似, 它的键全部都会被转换成字符串</p>

<pre><code class="language-js">let person = {
    hello : &#39;world&#39;,
    42: true
}
console.log(person.hello) // wrold
console.log(person[&#39;hello&#39;]) // wrold
console.log(person[&#39;42&#39;]) // true;
</code></pre>

<h3 id="toc_14"><code>Array</code>类型</h3>

<ul>
<li>创建数组的两种方法.</li>
</ul>

<pre><code class="language-js">// 通过构造函数
let foo = new Array();
// 通过数组字面量
let bar = [];
</code></pre>

<ul>
<li><p><code>length</code>属性</p>

<ul>
<li><code>length</code>属性用于指示数组长度, 并且它不是只读的.增加<code>length</code>属性会增加数组长度, 多出的部分为<code>undefined</code></li>
<li>当将一个值放在超出数组长度的位置上, <code>length</code>将会被重新计算, 为最后一个元素的索引位置加一.</li>
</ul></li>
<li><p>检测数组的方法: <code>Array.isArray()</code></p></li>
<li><p>栈方法: 支持<code>pop</code>和<code>push</code>方法</p></li>
<li><p>队列方法: 支持<code>shifg</code>和<code>push</code>方法</p></li>
<li><p>重排序方法: <code>sort</code>对数组排序, <code>reverse</code>翻转数组项.</p></li>
<li><p>迭代方法</p>

<ul>
<li><code>every()</code>:对数组每一项运行一个函数, 若该函数对所有项返回<code>true</code>, 则返回<code>true</code></li>
<li><code>some()</code>:对数组每一项运行一个函数, 若该函数对其中一项返回<code>true</code>, 则返回<code>true</code></li>
<li><code>filter()</code>:对数组每一项运行一个函数, 返回该函数返回true的项组成的数组.</li>
<li><code>map()</code>:对数组每一项运行一个函数, 返回每次函数调用结果组成的数组.</li>
<li><code>forEach()</code>:对数组每一项运行一个函数, 没有返回值.</li>
</ul></li>
</ul>

<h3 id="toc_15"><code>Date</code>类型</h3>

<pre><code class="language-js">let now = new Date();
</code></pre>

<h3 id="toc_16"><code>RegExp</code>类型</h3>

<p>正则表达式类型, 形如</p>

<pre><code class="language-js">let expression = / pattern / flag;
</code></pre>

<p>其中<code>pattern</code>是正则表达式, <code>flag</code>有下列三个标志</p>

<ul>
<li><code>g</code>: 表示全局模式, 即将模式应用于全部字符串,而非遇到第一个匹配项时即停止</li>
<li><code>i</code>: 忽略大小写</li>
<li><code>m</code>: 表示多行模式.</li>
</ul>

<h4 id="toc_17"><code>RegExp</code>的实例属性</h4>

<ul>
<li><code>global</code>: 布尔值, 表示是否设置了全局标志</li>
<li><code>ignoreCase</code>: 布尔值, 表示是否设置了忽略大小写标志.</li>
<li><code>multiline</code>: 布尔值, 表示是否开启了多行模式</li>
<li><code>lastIndex</code>: 整数, 表示开始搜索下一个匹配项的字符位置</li>
<li><code>source</code>: 正则表达式的字面量</li>
</ul>

<h4 id="toc_18"><code>RegExp</code>的实例方法</h4>

<ul>
<li><code>exec()</code>: 主要方法, 接收参数为需要应用模式的字符串, 返回包含第一个匹配项的数组, 匹配失败返回<code>null</code></li>
</ul>

<h3 id="toc_19"><code>Function</code>类型</h3>

<p>ECMAScript中的函数实际上是<code>Function</code>类型的实例. 函数名实际上是指向函数对象的引用</p>

<pre><code class="language-js">let sum = function(num1, num2) {
    return num1 + num2;
}
// 等价于

function sum(num1, num2) {
    return num1 + num2;
}
</code></pre>

<h4 id="toc_20">为何没有重载</h4>

<p>由于函数名实际上是指向函数对象的引用, 所以当尝试重载函数时, 是修改了变量上引用的值, 覆盖了之前声明的函数.</p>

<h4 id="toc_21">函数内部属性</h4>

<p>函数内部两个属性</p>

<ul>
<li><code>arguments</code>: 数组, 保存了函数的参数.</li>
<li><code>this</code>: 引用当前函数内部的执行环境.</li>
</ul>

<h4 id="toc_22">函数的属性和方法</h4>

<p>两个属性:</p>

<ul>
<li><p><code>length</code>: 表示函数希望接收形参的数量.</p></li>
<li><p><code>prototype</code>: 每个引用类型都拥有<code>prototype</code>属性,在第六章中将会深入分析.</p></li>
</ul>

<p>三个方法:</p>

<ul>
<li><code>apply</code>: 接收一个作用域引用和参数数组.</li>
</ul>

<pre><code class="language-js">function sum(num1, num2) {
    return num1 + num2;
}

function applySum(num1, num2) {
    return sum.apply(this, [num1, num2]);
}
</code></pre>

<ul>
<li><code>call</code>: 接收一个作用域引用和多个参数.</li>
</ul>

<pre><code class="language-js">function sum(num1, num2) {
    return num1 + num2;
}

function callSum(num1, num2) {
    return sum.call(this, num1, num2);
}
</code></pre>

<ul>
<li><code>bind</code>方法: 改变函数运行的环境</li>
</ul>

<pre><code class="language-js">let o = {
    color: &#39;blue&#39;
}

function printColor() {
    console.log(this.color);
}

let foo = printColor.bind(o);
foo() // &#39;blue&#39;
</code></pre>

<h4 id="toc_23">基本包装类型</h4>

<p>基本包装类型有三个: <code>String</code>, <code>Number</code>, <code>Boolean</code>, 用于方便开发者以对象的方式创建和操作基本类型.但要注意的是, 基本类型与基本类型对象是不一样的.<br/>
在使用时, 解释器会自动读取和写入对象的值</p>

<h5 id="toc_24"><code>Boolean</code>对象(<strong>不建议使用</strong>)</h5>

<pre><code class="language-js">// 利用 Boolean 对象创建布尔值
let falseObject = new Boolean(false)
// 与布尔值进行布尔操作
console.log(falseObject &amp;&amp; true) // true
</code></pre>

<p>由于所有对象在布尔表达式中都是<code>true</code>, 所以布尔对象当然也为<code>true</code></p>

<h5 id="toc_25"><code>Number</code>对象</h5>

<p><code>Number</code>对象时数字值对应的引用类型,创建其实例</p>

<pre><code class="language-js">let num = new Number(19);
</code></pre>

<p><code>Number</code>有几个值得注意的实例方法</p>

<ul>
<li><code>toFixed()</code>: 按照指定的小数位<strong>四舍五入</strong>返回数值的字符串表示.</li>
<li><code>toExponential()</code>: 按照指定的小数位<strong>四舍五入</strong>返回数值的字符串的科学计数法表示</li>
</ul>

<p>以及<code>Number</code>对象与<code>Number</code>基本类型在<code>typeof</code>操作符上的不同表象</p>

<pre><code class="language-js">let num1 = new Number(19);
alert(typeof num1) // &#39;object&#39;
let num2 = 19;
alert(typeof num2) // &#39;number&#39;
</code></pre>

<h5 id="toc_26"><code>String</code>对象</h5>

<p><code>String</code>类型是字符串类型的对象包装类型.<br/>
<code>String</code>的某些属性与实例方法:</p>

<ul>
<li><code>charAt()</code>: 接收一个参数, 返回字符串对应位置的字符(也可以通过<code>[]</code>操作符完成).</li>
<li><code>concat()</code>: 接收任意多个字符串参数, 返回拼接后的字符串.</li>
<li><code>slice()</code>: 对字符串进行切片</li>
<li><code>indexOf()</code>: 接收一个字符串参数, 返回该字符串在被搜索串中的第一次出现的索引, 不存在返回-1.</li>
<li><code>trim()</code>方法, 创建一个字符串副本, 删除前置及后缀的空格, 并返回结果.</li>
<li><code>replace()</code>: 用于根据正则表达式替换字符串</li>
</ul>

<h4 id="toc_27">单体内置对象</h4>

<p><code>单体内置对象</code>指由<code>ECMAScript</code>实现提供的, 不依赖宿主环境的. 这些对象在<code>ECMAScript</code>执行前就已经存在.</p>

<h5 id="toc_28"><code>Global</code>对象</h5>

<p><code>Global</code>对象处于所有作用域链的顶端, 在<code>ECMAScript</code>执行点就已经载入, 除了拥有之前提到的诸如<code>isNaN()</code>, <code>isFinite()</code>,<code>parseInt()</code>等都是<code>Global</code>对象的方法.<br/>
除此之外, 它还包含一些其他方法.</p>

<ul>
<li><p><code>URL编解码方法</code></p>

<ul>
<li><code>encodeURIComponent()</code>: 是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码.</li>
<li><code>encodeURI()</code>: 会替换所有的字符，但不包括以下字符<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-09%20%E4%B8%8B%E5%8D%888.56.13.png" alt="屏幕快照 2017-11-09 下午8.56.13"/></li>
<li><code>decodeURIComponent()</code>: 将已编码 URI 中所有能识别的转义序列转换成原字符</li>
<li><code>decodeURI()</code>: 将已编码 URI 中所有能识别的转义序列转换成原字符，但不能解码那些不会被 <code>encodeURI()</code>编码的内容</li>
</ul></li>
<li><p><code>eval()</code>方法: 将会解析传入的<code>JavaScript</code>脚本字符串并执行.</p></li>
<li><p><code>Global</code>对象的属性<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-09%20%E4%B8%8B%E5%8D%889.00.56.png" alt="屏幕快照 2017-11-09 下午9.00.56"/></p></li>
<li><p><code>window</code>对象: 在浏览器中, <code>window</code>对象扩展了<code>Global</code>对象, 并成为新的全局对象.</p></li>
</ul>

<hr/>

<h2 id="toc_29">第六章 面向对象的程序设计</h2>

<h3 id="toc_30">原始时期创建对象的方法</h3>

<pre><code class="language-js">let person = new Object();
person.name = &#39;locust&#39;;
person.sayName = function() {
    alert(this.name);
}
</code></pre>

<p>这个对象中添加了<code>name</code>属性和<code>sayName()</code>方法.</p>

<h3 id="toc_31">属性类型</h3>

<p>在<code>ES5</code>中定义了两种属性: 数据属性和访问器属性. 为了表示属性是内部值, 该规范将它们放在两对方括号中, 例如<code>[[Enumerable]]</code>.</p>

<h4 id="toc_32">数据属性</h4>

<ul>
<li><code>[[Configuralbe]]</code>: 表示能否通过<code>delete</code>删除属性从而重新定义属性, 能否修改属性的特性, 或者能否将属性修改为访问器属性.</li>
<li><code>[[Enumerable]]</code>: 表示能否通过<code>for-in</code>遍历.</li>
<li><code>[[Value]]</code>: 表示这个属性的值, 当修改当前属性时, 需要从这个位置修改.</li>
<li><code>[[Writable]]</code>: 表示该属性是否可写.</li>
</ul>

<p>例如:</p>

<pre><code class="language-js">let person = {
    name: &#39;locust&#39;
};
</code></pre>

<p>对于<code>person</code>对象中的<code>name</code>属性, <code>[[Value]]</code>被设置为<code>locust</code></p>

<h5 id="toc_33">修改属性默认特性的方法</h5>

<p><code>ES5</code>提供了修改默认属性特性的方法<code>Object.defineProperty(obj, prop, descriptor)</code>, 其中</p>

<ul>
<li><code>obj</code>: 表示属性所在的对象.</li>
<li><code>prop</code>: 表示属性的名字.</li>
<li><code>descriptor</code>: 用于描述属性对象特性的对象.</li>
</ul>

<p>例如</p>

<pre><code class="language-js">let person = new Object();
Object.defineProperty(person, &#39;name&#39;, {
    writalbe: false,
    value: &#39;locust&#39;
}
alert(person.name); // locust
// (在严格模式下, 向不可写属性复制会抛出异常)
person.name = &#39;jason&#39;;
alert(person.name); // locust
</code></pre>

<h4 id="toc_34">访问器属性</h4>

<ul>
<li><code>[[Configuralbe]]</code>: 表示能否通过<code>delete</code>删除属性从而重新定义属性, 能否修改属性的特性, 或者能否将属性修改为访问器属性.</li>
<li><code>[[Enumerable]]</code>: 表示能否通过<code>for-in</code>遍历.</li>
<li><code>[[Get]]</code>: 在读取属性时调用的函数, 默认值为<code>undefined</code></li>
<li><code>[[Set]]</code>: 在写入属性时调用的函数, 默认值为<code>undefined</code></li>
</ul>

<p>同样可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>修改访问器属性.</p>

<p>例如</p>

<pre><code class="language-js">let person = {
  _age: 21
}
Object.defineProperty(person, &#39;age&#39;, {
  set: function (newValue) {
    if (newValue &lt; 0) {
      this._age = 0;
      return;
    }
    this._age = newValue;
  }
});
</code></pre>

<h3 id="toc_35">创建对象</h3>

<h4 id="toc_36">工厂模式</h4>

<pre><code class="language-js">function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age  = age;
    o.job  = job;
    o.sayName = function() {
        alert(this.name);
    }
    return o;   
}
</code></pre>

<p>工厂模式可以解决创建对象的代码冗余问题, 但是仍然无法解决对象识别问题(<code>instanceof</code>)</p>

<h4 id="toc_37">构造函数模式</h4>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
    this.sayName = function() {
        alert(this.name);
    }
}

let person = new Person(&#39;locust&#39;, 21, &#39;Doctor&#39;);
</code></pre>

<p>这里使用了<code>new</code>操作符, 通过<code>new</code>调用构造函数会经历以下步骤:</p>

<ol>
<li>创建一个新的对象</li>
<li>将构造函数的作用域赋给新的对象(也就是<code>this</code>指向了新的对象)</li>
<li>执行构造函数中的代码(给新对象添加属性和方法)</li>
<li>返回新对象</li>
</ol>

<p>通过<code>new</code>操作符生成的实例还会拥有<code>constructor</code>属性, 该属性指向<code>Person</code>构造函数</p>

<pre><code class="language-js">alert(person.constructor === Person) // true
</code></pre>

<p>同时也可以使用<code>instanceof</code>操作符去识别对象</p>

<pre><code class="language-js">alert(person instanceof Object)  // true
alert(person instanceof Person); // true
</code></pre>

<h5 id="toc_38">构造函数的问题</h5>

<p>在通过构造函数实例化对象时, 其中的属性会创建新的副本, 然而多个相同方法的副本(<code>Function对象</code>)是没有必要的(例如<code>Person</code>中的<code>sayName()</code>), 如此一来就会造成内存浪费.</p>

<p>其中一个不太好的解决方法</p>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
    this.sayName = sayName;
}

function sayName() {
    alert(this.name);
}
</code></pre>

<h4 id="toc_39">原型模式</h4>

<p> 每一个函数都有一个名为<code>prototype(原型)</code>属性, 这个属性指向<strong>一个对象</strong>, <strong>而这个对象是包含由特定类型的所有实例共享的属性和方法</strong></p>

<pre><code class="language-js">function Person() {}

Person.prototype.name = &#39;locust&#39;;
Person.prototype.age  = 21;
Person.prototype.job  = &#39;Doctor&#39;;
Person.prototype.sayName = function() {
    alert(this.name);
}

let person = new Person();
</code></pre>

<h5 id="toc_40">理解原型对象</h5>

<p>每创建一个新函数,都会为该函数创建一个<code>prototype</code>属性,并且指向函数的原型对象.</p>

<p>默认情况下, 所有原型对象都会获得<code>constructor</code>属性, 其指向<code>prototype</code>属性所在的函数.</p>

<p>在通过构造函数实例化对象后, 该对象会包含一个内部属性<code>[[Prototype]]</code>, 该属性指向构造函数的原型对象.在某些实现中, 可以通过<code>__proto__</code>访问它</p>

<p>以<code>Person</code>为例<br/>
<img src="media/15101331051720/person.png" alt="person"/></p>

<h5 id="toc_41">对象中属性的搜索顺序</h5>

<p>每当代码读取对象中的属性时, 都会执行一次搜索, 首先从对象实例开始.如果找到了改名字对应的属性, 则返回该属性的值. 如果未找到, 则搜索实例的原型对象.</p>

<p>所以当我们的实例需要给属性赋予自己的值时</p>

<pre><code class="language-js">function Person() {}

Person.prototype.name = &#39;locust&#39;;
Person.prototype.age  = 21;
Person.prototype.job  = &#39;Doctor&#39;;
Person.prototype.sayName = function() {
    alert(this.name);
}

let person = new Person();
person.name = &#39;jason&#39;;
</code></pre>

<p>此时对象内部图示<br/>
<img src="media/15101331051720/pp.png" alt="pp"/></p>

<p>当我们需要判断某个实例的属性是来自原型对象, 还是来自对象自身, 可以使用<code>hasOwnProperty()</code>判断</p>

<pre><code class="language-js">let person = new Person();
alert(person.hasOwnProperty(&#39;name&#39;)); // false

person.name = &#39;jason&#39;;
alert(person.hasOwnProperty(&#39;name&#39;)); // true

delete person.name;
alert(person.hasOwnProperty(&#39;name&#39;)); // false
</code></pre>

<p>当我们需要判断某个实例的属性是否存在于原型对象中时, 可以使用<code>in</code>操作符</p>

<pre><code class="language-js">let person = new Person();
alert(&#39;name&#39; in person); // true
</code></pre>

<h5 id="toc_42">原型对象的问题</h5>

<ol>
<li>原型对象没有构造函数.</li>
<li>由于原型对象中的属性由所有实例共享, 当我们对原型对象中的引用类型实例进行操作时, 会影响到其他的实例.</li>
</ol>

<h4 id="toc_43">组合使用构造函数与原型对象</h4>

<p>对于面向对象编程来说, 多个实例中方法可以共享, 但属性应该是每个实例独有的. 由此我们可以利用构造函数的<code>this</code>引用存储属性, 利用<code>prototype</code>存放方法.</p>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
}

Person.prototype.sayName = function() {
    alert(this.name);
}
</code></pre>

<p>完美~</p>

<h3 id="toc_44">继承</h3>

<h4 id="toc_45">原型链</h4>

<p>利用原型让一个引用类型继承另一个引用类型的属性和方法.</p>

<p>根据<code>对象中属性的搜索顺序</code>, 只需要令子类的原型对象执行父类的实例, 就可以完成继承了</p>

<pre><code class="language-js">function SuperType() { 
    this.property = true;
}

SuperType.prototype.getSuperValue = function()   {
    return this.property;
};

function SubType() {
    this.subProperty = false;
}
// 继承 SuperType
SubType.property = new SuperType();

SubType.property.getSubValue = function() {
    return this.subProperty;
};

let subInstance = new SubType();
alert(subInstance.getSuberValue()); // true
</code></pre>

<p><img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-10%20%E4%B8%8B%E5%8D%8810.35.48.png" alt="屏幕快照 2017-11-10 下午10.35.48"/></p>

<h5 id="toc_46">原型链的顶端</h5>

<p>所有引用类型默认都继承了<code>Object</code>, 所以所有引用类型的原型链顶端均是<code>Object.prototype</code><br/>
<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-10%20%E4%B8%8B%E5%8D%8810.36.36.png" alt="屏幕快照 2017-11-10 下午10.36.36"/></p>

<h5 id="toc_47">原型链继承的问题</h5>

<ol>
<li>父类的实例属性变成了子类的原型, 所有的子类实例都共享了父类的实力属性.</li>
<li>无法向父类构造函数传递参数.</li>
</ol>

<h4 id="toc_48">借用构造函数</h4>

<p>通过调用父类构造函数, 将父类的属性赋予到子类中,</p>

<pre><code class="language-js">function SuperType(name) {
    this.name = name;
}

function SubType(age) {
    // 调用父类构造函数, 将父类属性赋予子类
    SuperType.call(this, &#39;locust&#39;);
    this.age = age;
}

let subInstance = new SubType(21)
alert(subInstance.name); // locust
alert(subInstance.age); // 21
</code></pre>

<h5 id="toc_49">借用构造函数的问题</h5>

<p>只继承了父类的属性, 并未继承父类的方法</p>

<h4 id="toc_50">组合继承</h4>

<p>组合继承融合了原型链继承和借用构造函数继承的方法, <code>原型链继承</code>用于继承父类<strong>方法</strong>, <code>借用构造函数继承</code>用于继承父类<strong>属性</strong>.</p>

<pre><code class="language-js">function SuperType(name) {
    this.name = name;
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    // 继承父类属性
    SuperType.call(this, name);
    this.age = age;
}
// 继承父类方法
SubType.prototype = new SuperType();

SubType.prototype.sayAge = function() {
    alert(this.age);
}
</code></pre>

<h4 id="toc_51">ES5中的<code>Object.create</code>继承</h4>

<p><code>Object.create(proto[, propertiesObject])</code>方法以<code>proto</code>和<code>propertiesObject</code>创建新的对象;</p>

<p>继承实例</p>

<pre><code class="language-js">function SuperType(name) {
    this.name = name;
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    // 继承父类属性
    SuperType.call(this, name);
    this.age = age;
}

// 继承父类方法
SubType.prototype = Object.create(SuperType.prototype);

// 重定向构造函数
SubType.prototype.constructor = SubType
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第七章]]></title>
    <link href="zerolocusta.github.io/15096777193883.html"/>
    <updated>2017-11-03T10:55:19+08:00</updated>
    <id>zerolocusta.github.io/15096777193883.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Wiring Modules</h2>

<blockquote>
<p>模块之间的编排设计</p>
</blockquote>

<h3 id="toc_1">Modules and dependencies</h3>

<p>大多数项目中都是多个模块聚合而成的,随着版本迭代,模块的依赖会越来越多,程序越发复杂.如果前期没规划好,那么项目的技术债就会马曼出现,从而变得难以维护和改动.</p>

<p>Node.js模块系统的特性提供了非常优秀的模块组织功能, 将模块作为对象导入的特性很方便将两个相互依赖的模块通过<code>DI</code>, <code>Locator</code>之类的技术进行解耦</p>

<h4 id="toc_2">Cohesion and coupling</h4>

<ul>
<li><code>Cohesion(内聚)</code>: 指机能相关的程序组合成一模块的程度, 或是各机能凝聚的状态或程度</li>
<li><code>Coupling(耦合)</code>: 指组件与组件之间的相互依赖程度.</li>
</ul>

<p>一般来说, 一个组件应该拥有高内聚低耦合的特性.</p>

<h4 id="toc_3">Stateful modules</h4>

<blockquote>
<p>拥有状态的模块</p>
</blockquote>

<p>由于<code>JavaScript</code>中所有元素,包括模块也是对象, 所以创建带有状态的对象也非常简单</p>

<h5 id="toc_4">The Singleton pattern in Node.js</h5>

<blockquote>
<p>单例模式</p>
</blockquote>

<p>得益于<code>Node.js</code>中的模块加载系统, 相同的模块只会加载并缓存一次的特性, 只需要通过<code>module.exports</code>导出对象实例就可以满足单例模式的需求.</p>

<p>例如在<code>db.js</code>中导出</p>

<pre><code class="language-js">// db.js
module.exports = new Database(&#39;mydb&#39;);
</code></pre>

<p>然后在其他模块中只需<code>require(&#39;db.js&#39;)</code>, 就可以获得<code>new Database(&#39;mydb&#39;)</code>的单例.</p>

<p>然而, 并不是所有情况下在整个项目中都能获取到同一个实例, 考虑如下项目目录结构<br/>
<img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-05%20%E4%B8%8A%E5%8D%8811.03.03.png" alt="屏幕快照 2017-11-05 上午11.03.03"/><br/>
在<code>packageA</code>和<code>packageB</code>中, 他们各自的<code>node_modules</code>中都存在<code>mydb</code>模块,根据<code>require.resolve算法</code>的特点, 两个<code>package</code>中的文件分别会说获取到各自<code>node_modules</code>中的不同实例,从而导致整个应用中出现了两个单例, 破坏了单例模式的特性.</p>

<blockquote>
<p>引用第二章中模块引入方法的查找特性.</p>

<h4 id="toc_5">The resolving algorithm</h4>

<p><code>require.resolve算法的实现功能点</code><br/>
resolve算法主要解决三种模块引入的路径问题<br/>
        * 文件模块 <br/>
            * 如果模块名由<code>/</code>开头的话, 那么几乎说明这是模块的绝对路径, 直接返回即可. 如果模块名以<code>./</code>或是<code>../</code>那么就认为是相对路径, 开始查找模块<br/>
        * 核心模块<br/>
            * 如果模块名无法标识这是一个核心模块, 那么就会去Node的内嵌核心模块中找, 例如<code>fs</code><br/>
        * 包模块<br/>
            * 如果上述两种方式都找不到该模块, 那么Node会从最相近的目录中查找<code>node_modules</code>这个目录, 如果找不到, 那么继续往上级目录查找, 直到操作系统的根目录.</p>

<p>而文件模块和包模块又有一个模块查找顺序:<br/>
        1. 查找<code>&lt;moduleName&gt;.js</code><br/>
        2. 查找<code>&lt;moduleName&gt;/index.js</code><br/>
        3. 从<code>&lt;moduleName&gt;/package.json</code>中的<code>main</code>属性中指定的文件中查找</p>
</blockquote>

<p>解决这个问题的方法之一, 可以使用<code>global</code>变量去存放单例例如</p>

<pre><code class="language-js">global.db = new Database(&#39;mydb&#39;)
</code></pre>

<p>然而除非必要, 完全不建议修改<code>global</code>变量, 况且很多应用中严格的单例模式不是必须, 在之后的<code>Patterns for wiring modules</code>会介绍另一种模式用于实现严格的单例模式</p>

<h3 id="toc_6">Patterns for wiring modules</h3>

<blockquote>
<p>模块结构的设计模式</p>
</blockquote>

<p>这一节将会通过建立一个HTTP认证服务, 并以此为蓝本将详述各种模块设计模式.</p>

<h4 id="toc_7">Hardcoded dependency</h4>

<p><code>Hardcoded dependency</code>是最常用的模块依赖解决方式, 各模块的状态在模块编写时已经被硬编码.</p>

<h5 id="toc_8">Building an authentication server using hardcoded dependencies</h5>

<p>本节建立的HTTP认证服务以<code>Express</code>作为Http框架, <code>levelup</code>用于存储信息, 并通过<code>JWT</code>生成用户登录态token.</p>

<p>认证服务的模块依赖:<br/>
<img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-05%20%E4%B8%8B%E5%8D%8811.03.44.png" alt="屏幕快照 2017-11-05 下午11.03.44"/></p>

<p>并且通过两个<code>HTTP</code>接口进行用户认证:</p>

<ul>
<li><code>POST /login</code>: <code>/login</code>接口通过<code>POST</code>方法接收一个带有<code>username</code>和<code>password</code>的JSON结构, 通过查询<code>leveldb</code>验证用户合法性, 最后将信息用户态以JWT加密返回.</li>
<li><code>GET /checklogin</code>: 从url参数中获取记录用户登录态的<code>token</code>, 验证用户信息.</li>
</ul>

<h6 id="toc_9">The db module</h6>

<p>首先建立从`存储用户信息的数据库接口</p>

<pre><code class="language-js">// db.js
const level = require(&#39;level&#39;);
const sublevel = require(&#39;level-sublevel&#39;);

module.exports = sublevel(
  level(&#39;example-db&#39;, {valueEncoding: &#39;json&#39;})
);
</code></pre>

<p><code>db.js</code>模块导出了一个<code>leveldb</code>实例.</p>

<h6 id="toc_10">The authService module</h6>

<p><code>authService</code>建立用户密码认证与数据之间的连接服务</p>

<pre><code class="language-js const">const bcrypt = require(&#39;bcrypt&#39;);

const db = require(&#39;./db&#39;);
// 从db中获取users集合
const users = db.sublevel(&#39;users&#39;);
// salt
const tokenSecret = &#39;SHHH!&#39;;

exports.login = (username, password, callback) =&gt; {
  // 尝试从数据库中获取用户信息
  users.get(username, (err, user) =&gt; {
    if(err) return callback(err);
    // 将加密后的password与数据库中加密后的密码进行比对
    bcrypt.compare(password, user.hash, (err, res) =&gt; {
      if(err) return callback(err);
      if(!res) return callback(new Error(&#39;Invalid password&#39;));
      // 登陆成功生成登陆态token
      let token = jwt.encode({
        username: username,
        expire: Date.now() + (1000 * 60 * 60) //1 hour
      }, tokenSecret);
      // 回传token
      callback(null, token);
    });
  });
};

exports.checkToken = (token, callback) =&gt; {
  let userData;
  try {
    //利用密钥解开token
    userData = jwt.decode(token, tokenSecret);
    if (userData.expire &lt;= Date.now()) {
      // 检查token是否超时
      throw new Error(&#39;Token expired&#39;);
    }
  } catch(err) {
    return process.nextTick(callback.bind(null, err));
  }
  // 检查username是否存在
  users.get(userData.username, (err, user) =&gt; {
    if (err) return callback(err);
    callback(null, {username: userData.username});
  });
};
</code></pre>

<h6 id="toc_11">The authController module</h6>

<p>最后是将HTTP请求中的用户参数提取, 并调用<code>authService</code>验证用户.</p>

<pre><code class="language-js">const authService = require(&#39;./authService&#39;);

exports.login = (req, res, next) =&gt; {
  // 从Http Request 中获取username和password
  // 通过authService验证用户
  authService.login(req.body.username, req.body.password,
    (err, result) =&gt; {
      if (err) {
        // 登陆失败, 返回异常
        return res.status(401).send({
          ok: false,
          error: &#39;Invalid username/password&#39;
        });
      }
      // 验证成功返回用户登录态token
      res.status(200).send({ok: true, token: result});
    }
  );
};

exports.checkToken = (req, res, next) =&gt; {
  // 从 HTTP Request 的 URL 参数中获取token
  // 通过authService检测token
  authService.checkToken(req.query.token,
    (err, result) =&gt; {
      if (err) {
        return res.status(401).send({
          ok: false,
          error: &#39;Token is invalid or expired&#39;  
        });
      }
      res.status(200).send({ok: &#39;true&#39;, user: result});
    }
  );
};
</code></pre>

<h6 id="toc_12">The app module</h6>

<p>三个用于支撑用户验证逻辑的模块已经就绪了, 接下来是用于支撑HTTP服务的app模块</p>

<pre><code class="language-js">const Express = require(&#39;express&#39;);
const bodyParser = require(&#39;body-parser&#39;);
const errorHandler = require(&#39;errorhandler&#39;);
const http = require(&#39;http&#39;);

const authController = require(&#39;./lib/authController&#39;);

// 初始化Express实例
let app = module.exports = new Express();
// 添加bodyParser中间件
app.use(bodyParser.json());
// 对接http接口与认证控制器
app.post(&#39;/login&#39;, authController.login);
app.get(&#39;/checkToken&#39;, authController.checkToken);

app.use(errorHandler());
http.createServer(app).listen(3000, () =&gt; {
  console.log(&#39;Express server started&#39;);
});

</code></pre>

<p>至此, HTTP认证服务基本完成, 抽离出<code>Hardcoded dependency</code>的部分</p>

<pre><code class="language-js">// db.js 中
module.exports = sublevel(
  // 数据库文件名被硬编码在此 
  level(&#39;example-db&#39;, {valueEncoding: &#39;json&#39;})
);

// authService.js 中
const db = require(&#39;./db&#39;);
const tokenSecret = &#39;SHHH!&#39;; // token被写死

// authController.js 中
const authService = require(&#39;./authService&#39;); // authService 模块被写死
</code></pre>

<p>目前的模块间依赖<br/>
<img src="media/15096777193883/untitled1.png" alt="untitled1"/></p>

<p>硬编码模式优势在于清晰, 模块之间的关系更容易理解, 也是最直观的, 但是考虑以下问题</p>

<ul>
<li>用于存放用户数据的数据库被局限为<code>example-db</code></li>
<li><code>authService</code>使用的数据库局限在<code>level-db</code>, 同时<code>token</code>被写在代码中</li>
<li><code>authController</code>的逻辑也被局限于<code>authService</code>模块</li>
</ul>

<p>实际项目开发中, 测试是很重要的一环, 但是测试和实际生产环境的数据要分开, 当我们要替换数据库进行测试, 或是希望分离并单独测试<code>authService</code>或是<code>authController</code>时, 就需要重新修改代码了.</p>

<h4 id="toc_13">Dependency Injection</h4>

<p>为了解决相关模块之间强依赖性问题, 引入依赖注入作为设计模块的模式.</p>

<p>将上面的三个用于认证服务的<code>db.js</code>, <code>authService.js</code>及<code>authController</code>稍作修改</p>

<ul>
<li><code>db.js</code></li>
</ul>

<pre><code class="language-js">// dbName 从硬编码 转换成通过外部注入
module.exports = function (dbName) {
  return sublevel(
    level(dbName, {
      valueEncoding: &#39;json&#39;
    })
  );
};
</code></pre>

<ul>
<li><code>authService.js</code></li>
</ul>

<pre><code class="language-js">// 数据库与密钥均由外部注入 
module.exports = (db, tokenSecret) =&gt; {
  const users = db.sublevel(&#39;users&#39;);
  const authService = {};
  
  authService.login = ...

  authService.checkToken = ...
  
  return authService;
};
</code></pre>

<ul>
<li><code>authController.js</code> </li>
</ul>

<pre><code class="language-js">// authService 由外部注入
module.exports = (authService) =&gt; {
  const authController = {};
  
  authController.login = ...

  authController.checkToken = ...
  
  return authController;
};
</code></pre>

<p>最后在<code>app.js</code>中整合多个组件</p>

<pre><code>const dbFactory = require(&#39;./lib/db&#39;);
const authServiceFactory = require(&#39;./lib/authService&#39;);
const authControllerFactory = require(&#39;./lib/authController&#39;);

const db = dbFactory(&#39;example-db&#39;);
const authService = authServiceFactory(db, &#39;SHHH!&#39;);
const authController = authControllerFactory(authService);
</code></pre>

<p>将<code>db</code>, <code>authService</code>, <code>authController</code>改为依赖注入后, 解决了原来各模块之间强耦合的问题, 同时也能替换三个模块中的组件, 从而进行分离测试.</p>

<p>目前的模块间依赖(由自底向上组织变为自顶向下聚合)<br/>
<img src="media/15096777193883/untitled0.png" alt="untitled0"/></p>

<h4 id="toc_14">Service locator</h4>

<p><code>Service locator</code>类似于桩服务, 各模块通过<code>Service locator</code>以名字为索引将所有相关模块连接起来, </p>

<p><code>Service locator</code>有几种类型, 分别是</p>

<ul>
<li>基于硬编码的服务定位器: 直接在定位器编写时将依赖名与依赖对象硬编码进去, 每次增删依赖时都会直接操作底层, 非常不推荐使用这类<code>Service locator</code>.</li>
<li>基于依赖注入的服务定位器: 各个模块预留注入接口, 最后在应用入口处填充<code>Servic locator</code>, 并注入到各个模块中.</li>
<li>全局服务定位器: 不通过依赖注入的方法注入<code>Service locator</code>, 而是全局引用一个单例, <code>require</code>当然也是一个全局服务定位器.</li>
</ul>

<h5 id="toc_15">Refactoring the authentication server to use a service locator</h5>

<blockquote>
<p>通过<code>service locator</code>改造HTTP认证服务器</p>
</blockquote>

<p>在改造各个模块之前, 首先要编写用于定位和发现服务的中心模块</p>

<ul>
<li><code>serviceLocator.js</code>(这里的实现使用了惰性初始化的模式, 在获取依赖时才生成实例)</li>
</ul>

<pre><code class="language-js">module.exports = () =&gt; {
  // 用于存放依赖名与依赖实例
  const dependencies = {};
  // 存放依赖名和生成依赖实例的工厂函数
  const factories = {};
  const serviceLocator = {};
  
  serviceLocator.factory = (name, factory) =&gt; {
    // 注册工厂函数
    factories[name] = factory;
  };
  
  serviceLocator.register = (name, instance) =&gt; {
    // 注册依赖实例
    dependencies[name] = instance;
  };
  // 用于获取依赖实例
  serviceLocator.get = (name) =&gt; {
    if (!dependencies[name]) {
      // 假如所需依赖未初始化
      const factory = factories[name];
      // 通过工厂函数初始化实例
      dependencies[name] = factory &amp;&amp; factory(serviceLocator);
      if (!dependencies[name]) {
        throw new Error(&#39;Cannot find module: &#39; + name);
      }
    }
    return dependencies[name];
  };

  return serviceLocator;
};
</code></pre>

<p>随后分别改动<code>db</code>, <code>authService</code>和<code>authController</code></p>

<ul>
<li><code>db.js</code></li>
</ul>

<pre><code class="language-js">module.exports = (serviceLocator) =&gt; {
  // 通过serviceLocator.get获取数据库文件名
  const dbName = serviceLocator.get(&#39;dbName&#39;);

  return sublevel(
    level(dbName, {valueEncoding: &#39;json&#39;})
  );
};

</code></pre>

<ul>
<li><code>authService</code></li>
</ul>

<pre><code class="language-js">module.exports = (serviceLocator) =&gt; {
  // 通过serviceLocator获取数据库实例及salt
  const db = serviceLocator.get(&#39;db&#39;);
  const tokenSecret = serviceLocator.get(&#39;tokenSecret&#39;);
  
  const users = db.sublevel(&#39;users&#39;);
  const authService = {};
  
  authService.login = ...

  authService.checkToken = ...
  
  return authService;
};
</code></pre>

<ul>
<li><code>authController</code></li>
</ul>

<pre><code class="language-js">module.exports = (serviceLocator) =&gt; {
  const authService = serviceLocator.get(&#39;authService&#39;);
  const authController = {};
  
  authController.login = ...

  authController.checkToken = ...
  
  return authController;
};
</code></pre>

<ul>
<li>最后在<code>app.js</code>出聚合多个模块</li>
</ul>

<pre><code class="language-js">const svcLoc = require(&#39;./lib/serviceLocator&#39;)();

svcLoc.register(&#39;dbName&#39;, &#39;example-db&#39;);
svcLoc.register(&#39;tokenSecret&#39;, &#39;SHHH!&#39;);
svcLoc.factory(&#39;db&#39;, require(&#39;./lib/db&#39;));
svcLoc.factory(&#39;authService&#39;, require(&#39;./lib/authService&#39;));
svcLoc.factory(&#39;authController&#39;, require(&#39;./lib/authController&#39;));

const authController = svcLoc.get(&#39;authController&#39;);
</code></pre>

<p>目前的项目结构变成了<br/>
<img src="media/15096777193883/untitled3.png" alt="untitled3"/></p>

<h4 id="toc_16">Dependency Injection container</h4>

<p>在<code>Dependency Injection</code>与<code>Service locator</code>两种模式中, 都要手动将多个模块关联起来, <code>Service locator</code>模式还需要给多个模块注入<code>Service locator</code><br/>
本节利用<code>Dependency Injection</code>模式并添加依赖注入容器, 根据参数名自动注入依赖</p>

<p><code>db</code>, <code>authService</code>, <code>authController</code>三个模块的代码与<code>Dependency Injection</code>章节的代码一模一样.</p>

<p>需要编写新的<code>diContainer</code>模块</p>

<ul>
<li><code>diContainer.js</code></li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;
// fnArgs 模块用于解析参数的名称
const fnArgs = require(&#39;parse-fn-args&#39;);

module.exports = () =&gt; {
  // 存放依赖实例
  const dependencies = {};
  const factories = {};
  const diContainer = {};

  diContainer.factory = (name, factory) =&gt; {
    factories[name] = factory;
  };

  diContainer.register = (name, dep) =&gt; {
    dependencies[name] = dep;
  };

  diContainer.get = (name) =&gt; {
    if (!dependencies[name]) {
      const factory = factories[name];
      // 利用inject函数生成模块实例
      dependencies[name] = factory &amp;&amp;
        diContainer.inject(factory);
      if (!dependencies[name]) {
        throw new Error(&#39;Cannot find module: &#39; + name);
      }
    }
    return dependencies[name];
  };
  // 自动依赖注入函数
  diContainer.inject = (factory) =&gt; {
    // fnArgs(factory) 返回一个参数名称列表
    const args = fnArgs(factory)
      .map(function (dependency) {
        // 根据参数名获取依赖实例
        return diContainer.get(dependency);
      });
    return factory.apply(null, args);
  };

  return diContainer;
};
</code></pre>

<h4 id="toc_17">小结</h4>

<ul>
<li>Hardcoded dependency

<ul>
<li>优点: 直观, 容易编写</li>
<li>缺点: 不便于分离测试, 模块间相互依赖强</li>
</ul></li>
<li>Dependency Injection

<ul>
<li>优点: 模块之间松耦合</li>
<li>缺点: 不够直观, 增加了复杂度, 需要手动注入依赖</li>
</ul></li>
<li>Service Locator

<ul>
<li>优点: 模块间通过Locator解耦合</li>
<li>缺点: 过度依赖Service Locator, 随时需要确保可用性, 模块间关系不清晰</li>
</ul></li>
<li>Dependency Injection Container

<ul>
<li>优点: 松耦合, 自动注入</li>
<li>缺点: 不够直观<br/></li>
</ul></li>
</ul>

<h3 id="toc_18">Wiring plugins</h3>

<p>插件是一种非常完美的模块组织方法, 拥有最小化的功能和最自由的可组合性<br/>
本节将探讨</p>

<ul>
<li>以插件的形式提供<code>service</code></li>
<li>如何将<code>plugin</code>插入到应用的工作流中</li>
</ul>

<h4 id="toc_19">Plugins as packages</h4>

<p>将插件作为npm package发布到npm上, 并利用npm进行插件版本管理和分发, 像<code>Express</code>和它的中间件使用的就是这种模式.这样做有几点好处</p>

<ul>
<li>npm包能很好管理插件的版本和依赖</li>
<li>每个插件都能有自己的私有的包</li>
<li>在插件中使用其他插件式依赖结构清晰

<ul>
<li>试想在没有使用package管理插件的情况下, 项目结构如下<img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%884.19.56.png" alt="屏幕快照 2017-11-08 下午4.19.56"/>
当<code>moduleA</code>需要使用<code>moduleB</code>时, <code>require(&#39;../../componentB/moduleB&#39;);</code>, 而当<code>component</code>作为<code>npm package</code>发布时, 只需要使用<code>require(&#39;componentB/module&#39;);</code>即可.</li>
</ul></li>
</ul>

<h4 id="toc_20">Plugin-controlled vs application-controlled extension</h4>

<p>插件的使用方法设计也有两种不同的方法, </p>

<ul>
<li>Explicit extension(显式扩展)</li>
<li>Extension through Inversion of Control (控制反转)</li>
</ul>

<blockquote>
<p><img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%885.04.54.png" alt="屏幕快照 2017-11-08 下午5.04.54"/><br/>
通过插件(组件)接受者和提供者的关系区分显示扩展还是控制反转</p>
</blockquote>

<p>1.<code>Explicit extension</code>对应的是<code>Plugin-controlled</code><br/>
2.<code>Extension through Inversion of Control</code>对应的是<code>application-controlled extension</code></p>

<p>两段代码展示这两种概念:</p>

<ul>
<li><code>Plugin-controlled</code></li>
</ul>

<pre><code class="language-js">//在 app.js 中
const app = express();
const plugin = require(&#39;thePlugin&#39;);
plugin(app);

//在 thePlugin.js 中
module.exports = function plugin(app) {
  app.get(&#39;/newRoute&#39;, function (req, res) { ...
  })
};
</code></pre>

<ul>
<li><code>Application-controlled extension</code></li>
</ul>

<pre><code class="language-js">//在 app.js 中的代码
const app = express();
const plugin = require(&#39;thePlugin&#39;)();
app[plugin.method](plugin.route, plugin.handler); 

//在 thePlugin.js 中的代码
module.exports = function plugin() {
  return {
    method: &#39;get&#39;,
    route: &#39;/newRoute&#39;,
    handler: function (req, res) { ...
    }
  }
}
</code></pre>

<p><code>Plugin-controlled</code> 与 <code>Application-controlled extension</code>的区别:</p>

<ul>
<li><code>Plugin-controlled</code>模式的设计更直观, 而且能更好地扩展插件的功能</li>
<li><code>Application-controlled extension</code>模式依赖于主框架提供能添加插件的API</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript高级程序设计 · 1、2、3、20章]]></title>
    <link href="zerolocusta.github.io/15093607735574.html"/>
    <updated>2017-10-30T18:52:53+08:00</updated>
    <id>zerolocusta.github.io/15093607735574.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">第一章 JavaScript简介</h2>

<p>JavaScript 与 ECMAScript 的关系<br/>
<img src="media/15093607735574/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%888.13.13.png" alt="屏幕快照 2017-10-30 下午8.13.13"/></p>

<p>完整的<code>JavaScript</code>标准由一下三部分组成</p>

<ul>
<li>核心(<code>ECMAScript</code>)</li>
<li>文档对象模型(<code>DOM</code>)</li>
<li>浏览器对象模型(<code>BOM</code>)</li>
</ul>

<h3 id="toc_1">ECMAScript</h3>

<p><code>ECMAScript</code>是一门语言, 由<code>ECMA-262</code>标准定义, ECMA-262标准规定了这门语言的以下组成部分:</p>

<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象</li>
</ul>

<p>而<code>JavaScript</code>实现并扩展了<code>ECMAScript</code></p>

<h5 id="toc_2">ECMAScript兼容</h5>

<p><code>ECMA-262</code>标准给出了<code>ECMAScript</code>兼容的定义</p>

<ol>
<li>支持<code>ECMA-262</code>描述的所有<strong>类型</strong>, <strong>值</strong>, <strong>对象</strong>, <strong>属性</strong>, <strong>函数</strong>以及<strong>程序句法</strong>和<strong>语义</strong></li>
<li>支持<code>Unicode</code>字符标准</li>
</ol>

<h3 id="toc_3">文档对象模型(DOM)</h3>

<p><code>DOM</code>是针对<code>XML</code>或<code>HTML</code>的应用程序编程接口, <code>DOM</code>把文档中各个节点映射成树形对象.</p>

<h4 id="toc_4">DOM级别</h4>

<h5 id="toc_5">DOM1级</h5>

<ul>
<li><code>DOM核心</code>: 规定如<strong>映射</strong>何基于<code>XML</code>的文档结构, 以便简化对文档中任意部分的访问和操作</li>
<li><code>DOM HTML</code>: 在<code>DOM核心</code>基础上加以扩展, 添加了针对<code>HTML</code>的对象和方法</li>
</ul>

<h5 id="toc_6">DOM2级</h5>

<ul>
<li><code>DOM视图</code>: 定义了跟踪不同文档(如,应用CSS之前和之后的文档)视图的接口.</li>
<li><code>DOM事件</code>: 定义了事件和事件处理的接口</li>
<li><code>DOM样式</code>: 定义了基于CSS为元素应用样式的接口</li>
<li><code>DOM遍历和范围</code>: 定义了遍历和操作文档树的接口</li>
</ul>

<h5 id="toc_7">DOM3级</h5>

<ul>
<li><code>DOM加载和保存</code>: 引入统一方式加载和保存文档的方式</li>
<li><code>DOM验证</code>: 定义了验证文档的方法</li>
</ul>

<h3 id="toc_8">浏览器对象模型(BOM)</h3>

<p>由于不存在BOM标准, 习惯上将所有针对浏览器的JavaScript扩展算作BOM的一部分</p>

<ul>
<li>弹出新浏览器窗口的功能</li>
<li>移动、缩放和关闭浏览器窗口的功能</li>
<li>提供浏览器详细信息的<code>navigator</code>对象</li>
<li>提供浏览器所加载页面的详细信息的<code>location</code>对象</li>
<li>提供用户显示器分辨率详细信息的<code>screen</code>对象</li>
<li>对<code>cookies</code>的支持</li>
<li>像<code>XMLHttpRequest</code>和IE的<code>ActiveXObject</code>这样的自定义对象</li>
</ul>

<h3 id="toc_9">总结</h3>

<p>JavaScript由下列三个不同的部分组成</p>

<ul>
<li><code>ECMAScript</code>, 有<code>ECMA-262</code>定义, 提供核心语言功能</li>
<li>文档对象模型(DOM), 提供访问和操作网页内容的方式和接口</li>
<li>浏览器对象模型(BOM), 提供与浏览器交互的方法和接口</li>
</ul>

<hr/>

<h2 id="toc_10">第二章 在HTML中使用JavaScript</h2>

<h3 id="toc_11"><code>&lt;script&gt;</code>元素</h3>

<p>向<code>HTML</code>页面插入<code>JavaScript</code>的主要方法是使用<code>&lt;script&gt;</code>元素, <code>HTML 4.01</code>规范为其定义了下列6个属性</p>

<ul>
<li><code>async</code>:可选. 表示应该立即下载脚本, 但不应在下载期间阻塞其他操作</li>
<li><code>charset</code>:可选. 表示通过<code>src</code>属性指定的代码的字符集.</li>
<li><code>defer</code>:可选. 表示脚本可以延迟到文档完全被解析和显示之后再执行.只对外部脚本文件有效</li>
<li><code>src</code>: 可选. 表示包含要执行代码的外部文件</li>
<li><code>language</code>: 已废弃.</li>
<li><code>type</code>: 可选. 表示编写代码使用的脚本语言和内容类型.默认值为<code>type/javascript</code></li>
</ul>

<p>使用<code>&lt;script&gt;</code>的两种方式:</p>

<p>1.直接在<code>&lt;script&gt;</code>元素嵌入JavaScript代码</p>

<pre><code class="language-js">&lt;script&gt;
    function sayHi() {
        alert(&quot;Hi!&quot;);
    }
&lt;/script&gt;
</code></pre>

<p>2.通过<code>src</code>属性引入外部<code>JavaScript</code>文件</p>

<pre><code class="language-js">&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
或者
&lt;script src=&quot;example.js&quot; /&gt;
</code></pre>

<p>需要注意的是, 带有<code>src</code>属性的<code>&lt;script&gt;</code>元素不应在其<code>&lt;script&gt;</code>he<code>&lt;/script&gt;</code>之前再嵌入额外的代码.如果包含了额外的代码, 那么只会下载执行外部文件, 嵌入的代码会被忽略.</p>

<h4 id="toc_12">放置<code>&lt;script&gt;</code>标签的位置</h4>

<ul>
<li>放置于<code>&lt;head&gt;</code>元素中, 例如</li>
</ul>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example&lt;/title&gt;
        &lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p>这种做法是吧所有外部文件的引用都放在<code>&lt;head&gt;</code>元素中, 但是在<code>&lt;head&gt;</code>元素中包含所有<code>JavaScript</code>文件, 意味着必须等到全部<code>JavaScript</code>代码都被下载、解析和执行完成后, 才能开始呈现页面的内容. 从而导致可能出现明显的延迟.</p>

<ul>
<li>放置在<code>&lt;body&gt;</code>元素中</li>
</ul>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这样, 在解析包含的<code>JavaScript</code>代码之前, 页面内容将完全呈现在浏览器中.</p>

<h4 id="toc_13">延迟脚本(<code>defer</code>属性)</h4>

<p>当<code>&lt;script&gt;</code>中定义了<code>defer</code>属性后, 脚本在执行时不会影响页面的构造, 也就是说, 脚本会被延迟到整个页面都解析完毕后在运行.</p>

<p>在<code>HTML5</code>规范中, 要求脚本按照它们出现的先后顺序执行, 而这些延迟执行脚本会先于<code>DOMContentLoaded</code>事件执行. 但在实际实现中, 延迟脚本不一定会完全遵从此标准, 因此最好只包含一个延迟脚本.</p>

<p>并且, 延迟脚本只适用于外部脚本.</p>

<h4 id="toc_14">异步脚本(<code>async</code>属性)</h4>

<p><code>async</code>属性与<code>defer</code>属性类似, 旨在改变处理脚本的行为, 目的是为了不让页面脚本的下载和执行, 但<code>async</code>属性不确保多个脚本文件之间的执行顺序.</p>

<h4 id="toc_15">嵌入代码与外部文件</h4>

<p>在使用<code>&lt;script&gt;</code>标签时, 应该倾向于使用外部文件, 使用外部文件由如下优点</p>

<ul>
<li><strong>可维护性</strong> : 使用嵌入代码时, <code>JavaScript</code>代码分散在多个<code>HTML</code>页面中, 容易造成维护困难. 而使用外键可以将所有<code>JavaScript</code>文件都放在用一个文件夹中.</li>
<li><strong>可缓存</strong> : 浏览器能够跟去外部脚本文件的位置, 将相同的文件缓存下来, 从而加快未来页面的加载速度.</li>
</ul>

<hr/>

<h2 id="toc_16">第三章 基本概念</h2>

<h3 id="toc_17">语法</h3>

<ul>
<li>区分大小写</li>
<li>标识符

<ul>
<li>第一个字符必须是一个字母、下划线(<code>_</code>)或是美元符号(<code>$</code>)</li>
<li>其他字符可以是字母、下划线、美元符号或数字</li>
<li>建议使用驼峰命名法</li>
</ul></li>
<li>注释</li>
</ul>

<pre><code class="language-js">// 单行注释

/*
 * 这是一个多行
 * 注释
 */
</code></pre>

<ul>
<li>严格模式: ES5中引入了严格模式的概念, 在该模式下, ES3中一些不确定的行为将得到处理, 尔对于某系不安全的操作也会抛出错误. 使用严格模式只需在脚本文件顶部加入<code>&quot;use strict&quot;;</code></li>
</ul>

<h3 id="toc_18">数据类型</h3>

<h4 id="toc_19"><code>typeof</code>操作符</h4>

<p><code>typeof</code>操作符用于检测变量的数据类型, 对一个值使用<code>typeof</code>操作符可能返回下列某个字符串</p>

<ul>
<li><code>undefined</code>, 表示这个值未定义</li>
<li><code>boolean</code>, 表示这是个布尔值</li>
<li><code>string</code>, 字符串</li>
<li><code>number</code>, 数值</li>
<li><code>object</code>, 对象或<code>null</code></li>
<li><code>function</code>, 函数</li>
</ul>

<h4 id="toc_20">Undefined 类型</h4>

<p>已声明但未对其初始化的值为<code>undefined</code></p>

<pre><code class="language-js">let msg;
console.log(msg) // undefined
console.log(msg === undefined); // true
</code></pre>

<p>对未声明的变量使用<code>typeof</code>也会返回<code>undefined</code></p>

<pre><code class="language-js">console.log(typeof age) // undefined
</code></pre>

<h4 id="toc_21">Null 类型</h4>

<p><code>null</code>表示一个空对象指针, 所以对其使用<code>typeof</code>操作符时会返回<code>object</code>.<br/>
由于<code>undefined</code>派生自<code>null</code>值, <code>ECMA-262</code>规定对他们的相等性测试要返回<code>true</code></p>

<pre><code class="language-js">console.log(null == undefined); // true
</code></pre>

<h4 id="toc_22">Boolean 类型</h4>

<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为<code>true</code>的值</th>
<th>转换为<code>false</code>的值</th>
</tr>
</thead>

<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>&quot;&quot;(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>/</td>
<td>undefined</td>
</tr>
</tbody>
</table>

<h4 id="toc_23">Number 类型</h4>

<ul>
<li>进制表示</li>
</ul>

<pre><code class="language-js">let intNum   = 35;    十进制整数
let octalNum = 070;   八进制整数
let hexNum   = 0x1f;  十六进制整数
</code></pre>

<ul>
<li>浮点数</li>
</ul>

<pre><code class="language-js">let floatNum1 = 1.1;
let floatNum2 = .1; // 表示0.1, 但不推荐

let floatNum3 = 1.; // 小数点后没有数字, 解析为整数1
let floatNum4 = 10.0; // 整数, 解析为10

Number.isInteger(1.) // true
Number.isInteger(10.0) // true

// 科学计数法
let floatNum5 = 3.14e2 // 整数, 3.14乘以10的平方, 314
</code></pre>

<p>由于浮点数值的最高进度是17位小数, 在进行算数计算时会出现精度问题, 例如, <code>0.1 + 0.2</code>答案并不是<code>0.3</code>, 而是<code>0.30000000000000004</code>, 所以, <strong>不要对特定的浮点数值进行测试</strong></p>

<ul>
<li>数值范围</li>
</ul>

<p><code>ECMAScript</code>能表示的数值范围在<code>Number.MIN_VALUE</code>与<code>Number.MAX_VALUE</code>之间, 在Chrome中, <code>Number.MIN_VALUE = 5e-324</code>, 而<code>Number.MAX_VALUE = 1.7976931348623157e+308</code>, 超出这个范围的数值会被转化成特殊的<code>Infinity</code>值, 如果这个数是负数,则会被转换成<code>-Infinity</code>.<br/>
要确定一个数是不是<strong>有穷</strong>的, 可以使用<code>isFinite()</code>函数</p>

<pre><code class="language-js">isFinite(Number.MAX_VALUE + Number.MAX_VALUE) // false
</code></pre>

<ul>
<li><code>NaN(Not a Number)</code></li>
</ul>

<p>用于表示要返回数值的操作数未返回数值的情况, 任何涉及<code>NaN</code>的算数操作都会返回<code>NaN</code>, 其次<code>NaN</code>与任何数值都不相等, 包括<code>NaN</code>本身</p>

<pre><code class="language-js">NaN ==  NaN // false
NaN === NaN // false
</code></pre>

<p>可以使用<code>isNaN()</code>函数判断一个参数是否&quot;不是数值&quot;</p>

<pre><code class="language-js">isNaN(NaN)    // true
isNaN(10)     // false
isNaN(&quot;10&quot;)   // false, &quot;10&quot;可被转换成数值10
isNaN(&quot;blue&quot;) // true, 不能被转换成数值
isNaN(true)   // false 可被转换成数值1
</code></pre>

<ul>
<li>数值转换</li>
</ul>

<p>将非数值转换为数值有三个函数:</p>

<ul>
<li><code>Number()</code>, 可用于任何数据类型, 转换规则如下

<ul>
<li>如果是<code>Boolean</code>值, <code>true</code>和<code>false</code>将分别被转换为<code>1</code>和<code>0</code><br/></li>
<li>如果是数字值, 简单的传入和返回</li>
<li>如果是<code>null</code>值, 返回0</li>
<li>如果是<code>undefined</code>, 返回<code>NaN</code></li>
<li>如果是字符串, 则遵循下列规则

<ul>
<li>如果字符串中只包含数字, 则直接转换为十进制数, 并忽略前导0</li>
<li>如果字符串包含有成效的浮点格式, 则转换为对应的浮点数值</li>
<li>如果字符串中包含有效的十六进制格式, 则将其转换为相同大小的十进制数值</li>
<li>对于空字符串, 转换为0</li>
<li>包含上述格式以外的字符, 转换为<code>NaN</code></li>
</ul></li>
<li>如果是对象, 则调用对象的<code>valueOf()</code>方法, 并将返回值按照前面的规则转换.如果转换的结果是<code>NaN</code>, 则调用对象的<code>toString()</code>方法, 然后再依照前面的规则返回转换的字符串值.</li>
</ul></li>
<li><code>parseInt()</code>, 将字符串转换为整数.</li>
<li><code>parseFloat()</code> , 将字符串转换为浮点数.</li>
</ul>

<h4 id="toc_24">String 类型</h4>

<ol>
<li><code>EMCAScript</code>支持使用双引号和单引号表示字符串.</li>
<li>字符串不可变</li>
<li>通过调用对象的<code>toString()</code>方法获得对象的字符串表示.</li>
<li><code>null</code>和<code>undefined</code>没有<code>toString()</code>方法</li>
</ol>

<p><code>String()</code>函数也能用于将变量转换为字符串,并遵从下列转换规则</p>

<ul>
<li>如果值有<code>toString()</code>方法, 则调用该方法并返回相应结果</li>
<li>如果值是<code>null</code>, 则返回<code>&quot;null&quot;</code></li>
<li>如果值是<code>undefined</code>, 则返回<code>&quot;undefined&quot;</code></li>
</ul>

<h4 id="toc_25">Object 类型</h4>

<p>每个<code>Object</code>都有下列属性和方法:</p>

<ul>
<li><code>Constructor</code>, 构造函数</li>
<li><code>hasOwnProperty(propertyName)</code>, 用于检查给定对象实例中是否存在<code>propertyName</code>的属性.</li>
<li><code>isPrototypeOf(object)</code>, 用于检测传入的对象是否是另一个对象的原型.</li>
<li><code>propertIsEnumerable(propertyName)</code>, 用于检查给定的属性是否能够使用<code>for-in</code>语句来枚举.</li>
<li><code>toString()</code>, 返回对象的字符串表示.</li>
<li><code>valueOf()</code>, 返回对象的字符串,数值,或布尔值表示.</li>
</ul>

<h3 id="toc_26">操作符</h3>

<p>需要注意的几种操作符</p>

<ul>
<li><p>位操作符, <code>ECMAScript</code>中所有数值都已<code>IEEE-756 64位</code>格式存储, 但位操作符并不直接操作64位的值.而是先将<strong>64位的值转换为32位的整数, 然后执行操作, 最后将结果转换回64位的值</strong></p></li>
<li><p>相等操作符</p>

<ul>
<li>全等操作符(<code>===</code>), 只在两个操作数在<strong>未经转换</strong>就相等的情况下返回<code>true</code></li>
<li>不全等操作符(<code>==</code>), 会对操作数进行转换后比较.</li>
</ul></li>
</ul>

<h3 id="toc_27">函数</h3>

<ol>
<li>参数, ES中并不在乎函数的参数个数和参数列表, 即使函数定义了两个参数, 也未必一定要传入两个参数, 因为参数在内部是用<strong>一个数组</strong>来表示的, 函数接收到的始终都是这个数组(<code>arguments</code>)</li>
<li>重载, 由于ES中并不在意函数的参数类型和葛叔, ES中没有重载的概念, 如果同时定义了两个名字相同的函数, 则改名字只属于后定义的函数.</li>
</ol>

<hr/>

<h2 id="toc_28">第二十章 JSON</h2>

<p>JSON语法可以表示一下三种类型:</p>

<ul>
<li><code>简单值</code>: 适用于JavaScript相同的语法, 可以在JSON中表示字符串、数值、布尔值和<code>null</code>. 但不支持<code>undefined</code>.</li>
<li><code>对象</code>: 一组有序的键值对, 每个键值对的值可以简单值, 也可以是复杂数据类型的值.</li>
<li><code>数组</code>: 表示一组有序的值的列表.</li>
</ul>

<h3 id="toc_29">序列化</h3>

<p>在序列化JavaScript对象时, 所有的函数及原型成员都会被忽略, 并且值为<code>undefined</code>的属性也会被跳过.</p>

<h4 id="toc_30">序列化选项</h4>

<ul>
<li>过滤结果</li>
</ul>

<p>如果过滤器参数是数组, 那么 <code>JSON.stringify()</code>的结果中将只包含数组中列出的属性, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    }
JSON.stringify(book, [&quot;title&quot;])
// 输出结果: &#39;{&quot;title&quot;:&quot;hello world&quot;}&#39;
</code></pre>

<p>如果过滤器参数是函数, 那么会讲对象中属性和值传入签名为<code>function (key, value)</code>的函数, 并且将函数的返回值作为相对应键的值, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    }
JSON.stringify(book, function(key, value) {
    if (key === &quot;year&quot;)
        return 5000;
    return value;    
})
// 输出结果:&#39;{&quot;title&quot;:&quot;hello world&quot;,&quot;edition&quot;:3,&quot;year&quot;:5000}&#39;
</code></pre>

<ul>
<li>字符串缩进与空白符</li>
</ul>

<p><code>JSON.stringify()</code>函数的第三个参数用于控制结果中的缩进和空白符, 例如</p>

<pre><code class="language-js">console.log(JSON.stringify(book, null, 4))
/* 打印出结果
 * {
 * &quot;title&quot;: &quot;hello world&quot;,
 * &quot;edition&quot;: 3,
 * &quot;year&quot;: 2011
 * }
 */
 console.log(JSON.stringify(book, null, &quot;--&quot;))
/* 打印出结果
 * {
 * --&quot;title&quot;: &quot;hello world&quot;,
 * --&quot;edition&quot;: 3,
 * --&quot;year&quot;: 2011
 * }
 */
 
</code></pre>

<ul>
<li><code>toJSON()</code>方法</li>
</ul>

<p><code>JSON.stringify()</code>会调用对象上的<code>toJSON()</code>方法, 从而可以满足对某些对象的自定义序列化需求, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    toJSON: function(){
        return this.title
        }
    }
JSON.stringify(book) // &quot;hello world&quot;
</code></pre>

<h4 id="toc_31">解析选项</h4>

<p><code>JSON.parse()</code>也可以接收第二个参数, 该参数是一个函数, 将在每对键值对上调用, 与序列化时的函数过滤器类似, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    releaseDate: new Date()
};

let bookJSON = JSON.stringify(book);

console.log(JSON.parse(bookJSON));

console.log(JSON.parse(bookJSON, function(key, value) {
    if (key === &#39;releaseDate&#39;)
        return new Date(value);
    return value;
}))
</code></pre>

<p>运行结果<br/>
<img src="media/15093607735574/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%20%E4%B8%8B%E5%8D%886.06.06.png" alt="屏幕快照 2017-11-01 下午6.06.06"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第六章]]></title>
    <link href="zerolocusta.github.io/15087314678145.html"/>
    <updated>2017-10-23T12:04:27+08:00</updated>
    <id>zerolocusta.github.io/15087314678145.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Design Patterns</h2>

<blockquote>
<p>经典设计模式在JS中的实现与应用</p>
</blockquote>

<h2 id="toc_1">摘要</h2>

<ul>
<li>Factory</li>
<li>Revealing constructor pattern</li>
<li>Proxy</li>
<li>Decorator</li>
<li>Adapter</li>
<li>Strategy</li>
<li>State</li>
<li>Template</li>
<li>Middleware</li>
<li>Command</li>
</ul>

<h3 id="toc_2">Factory</h3>

<blockquote>
<p>工厂模式</p>
</blockquote>

<p>经典工厂模式, 根据不同参数返回不同的示例</p>

<pre><code class="language-js">// Image 基类
class Image {
  constructor(path) {
    this.path = path;
  }
};
// 继承自 Image, 用于表示 Gif 图像
class ImageGif extends Image {
  constructor(path) {
    if (!path.match(/\.gif/)) {
      throw new Error(`${path} is not a GIF image`);
    }
    super(path);
  }
};
// 继承自 Image, 用于表示 Jpg 图像
class ImageJpg extends Image {
  constructor(path) {
    if (!path.match(/\.jpe?g$/)) {
      throw new Error(`${path} is not a JPEG image`);
    }
    super(path);
  }
};
// 继承自 Image, 用于表示 Png 图像
class ImagePng extends Image {
  constructor(path) {
    if (!path.match(/\.png$/)) {
      throw new Error(`${path} is not a PNG image`);
    }
    super(path);
  }
};
// 工厂函数, 根据不同的文件名创建相应的图像实例
function createImage(name) {
  if(name.match(/\.jpe?g$/)) {
    return new ImageJpeg(name);
  } else if(name.match(/\.gif$/)) {
    return new ImageGif(name);
  } else if(name.match(/\.png$/)) {
    return new ImagePng(name);
  } else {
    throw new Exception(&#39;Unsupported format&#39;);
  }
}
</code></pre>

<h4 id="toc_3">A mechanism to enforce encapsulation</h4>

<blockquote>
<p>利用工厂模式将封装性引入JavaScript</p>
</blockquote>

<ul>
<li>利用闭包特性, 对外部属性进行封装, 避免通过对象直接访问私有属性</li>
</ul>

<pre><code class="language-js">function createPerson(name) {
  // privateProperties 用于存放私有变量
  const privateProperties = {};
  // person 用于模拟类
  const person = {
    // 通过Getter 和 Setter访问外部
    // privateProperties属性
    setName: name =&gt; {
      if (!name) throw new Error(&#39;A person must have a name&#39;);
      privateProperties.name = name;
    },
    getName: () =&gt; {
      return privateProperties.name;
    }
  };
  
  person.setName(name);
  return person;
}
// 利用 createPerson 工厂函数创建person实例
const person = createPerson(&#39;James Joyce&#39;);
console.log(person.getName(), person);
</code></pre>

<h4 id="toc_4">Composable factory functions</h4>

<blockquote>
<p>利用第三方库<code>stampit</code>创建及组合工厂函数</p>
</blockquote>

<p>这章节里将一个对象的各种元素, 例如属性, 方法, 拆分为多个模块, 最后将他们组合起来, 利用工厂模式创建实例.</p>

<p><code>stampit</code>有几个主要方法用于创建模块化的类</p>

<ul>
<li><code>init(...args)</code>: 用于指示创建出的模块构造函数的参数</li>
<li><code>props(...args)</code>: 用于表示模块中拥有的属性</li>
<li><code>methods(...args)</code>: 用于表示模块中拥有的方法</li>
</ul>

<p>附上<code>stampit</code>的<a href="https://github.com/stampit-org/stampit/blob/master/docs/API.md">API</a>文档地址</p>

<p>使用示例:<br/>
   通过<code>stampit</code>组合创造出具有多种技能的人物.</p>

<pre><code class="language-js">const stampit = require(&#39;stampit&#39;);
// 创建角色模块
const character = stampit().
props({
  name: &#39;anonymous&#39;,
  lifePoints: 100,
  x: 0,
  y: 0
});
// mover, 具有移动的方法
const mover = stampit().
methods({
  move(xIncr, yIncr) {
    this.x += xIncr;
    this.y += yIncr;
    console.log(`${this.name} moved to [${this.x}, ${this.y}]`);
  }
});
// slasher, 类似于攻击的属性
const slasher = stampit().
methods({
  // 添加 slash 方法
  slash(direction) {
    console.log(`${this.name} slashed to the ${direction}`);
  }
});
// 射击
const shooter = stampit().
props({
  // 添加bullets属性
  bullets: 6
}).
methods({
  // 添加shoot方法
  shoot(direction) {
    if (this.bullets &gt; 0) {
      --this.bullets;
      console.log(`${this.name} shoot to the ${direction}`);
    }
  }
});
// 类似于多继承, 利用compose方法将多个特性组合起来
const runner = stampit.compose(character, mover);
const samurai = stampit.compose(character, mover, slasher);
const sniper = stampit.compose(character, shooter);
const gunslinger = stampit.compose(character, mover, shooter);
const westernSamurai = stampit.compose(gunslinger, samurai);

const gojiro = westernSamurai();
gojiro.name = &#39;Gojiro Kiryu&#39;;
gojiro.move(1, 0);
gojiro.slash(&#39;left&#39;);
gojiro.shoot(&#39;right&#39;);
</code></pre>

<p><code>stampit.compose</code>将多个模块组合起来, 创建出新的工厂方法, 与类的多继承类似.</p>

<h3 id="toc_5">Revealing constructor pattern</h3>

<blockquote>
<p>在构造函数中传入<code>executor</code>, 并在构造函数中马上执行</p>
</blockquote>

<p><code>Promise</code>就是<code>Revealing constructor pattern</code>的一种</p>

<pre><code class="language-js">const p = new Promise(function(resolve, reject){
    ...
})
</code></pre>

<p>在<code>Promise</code>被构造出来的那一刻, 传入构造函数的函数就会被马上执行, 并通过<code>resolve</code>和<code>reject</code>改变和传递<code>promise</code>的状态和结果</p>

<h4 id="toc_6">A read-only event emitter</h4>

<blockquote>
<p>构造一个以<code>Revealing constructor pattern</code>为原型的只读事件订阅类</p>
</blockquote>

<ul>
<li>创建<code>Roee(Read-only Event Emitter)</code></li>
</ul>

<pre><code class="language-js">const EventEmitter = require(&#39;events&#39;);

class Roee extends EventEmitter {
  constructor(executor) {
    super();
    // 保存emit函数
    const emit = this.emit.bind(this);
    // 将 this.emit 置为 undefined
    // 防止外部使用
    this.emit = undefined;
    // 执行executor
    // 只能在 executor 中执行 emit 函数
    executor(emit);
  }
};
</code></pre>

<ul>
<li>利用<code>Roee</code>创建一个<code>ticker</code></li>
</ul>

<pre><code class="language-js">const ticker = new Roee((emit) =&gt; {
  let tickCount = 0;
  // 每秒向 listener 发送 tickCount
  setInterval(() =&gt; emit(&#39;tick&#39;, tickCount++), 1000);
});

ticker.on(&#39;tick&#39;, (tickCount) =&gt; console.log(tickCount, &#39;TICK&#39;));
</code></pre>

<h3 id="toc_7">Proxy</h3>

<blockquote>
<p>代理模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-26%20%E4%B8%8B%E5%8D%885.47.55.png" alt="屏幕快照 2017-10-26 下午5.47.55"/></p>

<h4 id="toc_8">Techniques for implementing proxies</h4>

<blockquote>
<p>在JavaScript上实现代理模式的方法</p>
</blockquote>

<h5 id="toc_9">实现代理模式的技巧</h5>

<ul>
<li>利用操纵原型链的方法实现代理模式, 两个重要的方法

<ul>
<li><code>Object.getPrototypeOf</code>: 获取对象/实例的原型</li>
<li><code>Object.create</code>: 通过原型创建出新的对象, 常用于模拟类的继承</li>
</ul></li>
</ul>

<pre><code class="language-js">function createProxy(subject) {
  // 获取对象原型
  const proto = Object.getPrototypeOf(subject);
  // 创建 Proxy 类
  function Proxy(subject) {
    this.subject = subject;
  }
  // Proxy 继承 subject 的原型
  Proxy.prototype = Object.create(proto);
  // 代理 subject.hello 方法
  Proxy.prototype.hello = function(){
    return this.subject.hello() + &#39; world!&#39;;
  };
  
  // 返回代理对象实例
  return new Proxy(subject);
}

class Greeter {
  hello() {
    return &#39;Hello&#39;;
  }

  goodbye() {
    return &#39;Goodbye&#39;;
  }
}

const greeter = new Greeter();
const proxy = createProxy(greeter);

console.log(proxy.hello());
console.log(proxy.goodbye());
</code></pre>

<p>运行结果<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-26%20%E4%B8%8B%E5%8D%887.19.47.png" alt="屏幕快照 2017-10-26 下午7.19.47"/></p>

<h5 id="toc_10">ES6中的<code>Proxy</code>类</h5>

<p>ES6中提供了<code>Proxy</code>类, 这个<code>Proxy</code>与我们所说的代理模式并不是同一样事物, <code>Proxy</code>虽然实现了部分代理的特性, 但是更多是用于对<code>Object</code>的元编程中. </p>

<p><code>Proxy(target, handler)</code>, <code>Proxy</code>的构造函数, <code>target</code>表示需要被代理的类, <code>handler</code>用于设置代理行为.</p>

<p><code>handler</code>提供了相当多的属性用于描述代理的行为, 例如</p>

<ul>
<li><code>get</code>: 在读取对象中属性时调用</li>
<li><code>set</code>: 在写入对象属性时调用</li>
<li><code>has</code>: 对应<code>in</code>操作符</li>
</ul>

<p>等等方法用于对应语言层面的行为<br/>
使用示例:</p>

<pre><code class="language-js">const scientist = {
  name: &#39;nikola&#39;,
  surname: &#39;tesla&#39;
};

const uppercaseScientist = new Proxy(scientist, {
  // 修改读取对象内属性的行为
  // 对对象属性的值调用 toUpperCase() 并返回
  get: (target, property) =&gt; target[property].toUpperCase()
});
// 运行结果 NIKOLA TESLA
console.log(uppercaseScientist.name, uppercaseScientist.surname);
</code></pre>

<h3 id="toc_11">Decorator</h3>

<blockquote>
<p>装饰器模式</p>
</blockquote>

<p>相比起代理模式在原对象的方法进行行为的修改, 装饰器模式是在原对象上添加属性或方法.<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-26%20%E4%B8%8B%E5%8D%8811.00.29.png" alt="屏幕快照 2017-10-26 下午11.00.29"/></p>

<h4 id="toc_12">Techniques for implementing Decorators</h4>

<blockquote>
<p>在JavaScript上实现装饰器模式的方法</p>
</blockquote>

<h5 id="toc_13">实现装饰器模式的技巧</h5>

<p>与实现代理模式类似, 利用操纵原型链的方法为被代理实例添加方法</p>

<pre><code class="language-js">function decorate(component) {
  const proto = Object.getPrototypeOf(component);
  
  function Decorator(component) {
    this.component = component;
  }
  
  Decorator.prototype = Object.create(proto);
  
  //添加新方法
  Decorator.prototype.greetings = function() {
    return &#39;Hi!&#39;;
  };
  return new Decorator(component);
}

class Greeter {
  hello(subject) {
    return `Hello ${subject}`;
  }
}

const decoratedGreeter = decorate(new Greeter());
console.log(decoratedGreeter.hello(&#39;world&#39;));
console.log(decoratedGreeter.greetings());
</code></pre>

<h3 id="toc_14">Adapter</h3>

<blockquote>
<p>适配器模式<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-28%20%E4%B8%8B%E5%8D%888.22.45.png" alt="屏幕快照 2017-10-28 下午8.22.45"/></p>
</blockquote>

<p><code>Adapter</code>充当中间层, 模拟<code>Adaptee</code>的行为, 以减少对客户端代码原用于调用<code>Adaptee</code>部分的修改.</p>

<h4 id="toc_15">Techniques for implementing Adapters</h4>

<blockquote>
<p>适配器模式在JavaScript并没有什么需要用到元编程技巧的地方</p>
</blockquote>

<p>本节展示了一个用于模拟<code>fs</code>模块的<code>Adapter</code>, 而<code>Adapter</code>内部将<code>fs</code>主要方法重定向至访问数据库,并模拟<code>fs</code>模块的行为</p>

<pre><code class="language-js">module.exports = function createFsAdapter(db) {
  const fs = {};
  // 模拟 fs.readFile 函数
  fs.readFile = (filename, options, callback) =&gt; {
    // 处理 callback come last
    if (typeof options === &#39;function&#39;) {
      callback = options;
      options = {};
    } else if(typeof options === &#39;string&#39;) {
      options = {encoding: options};
    }
    // 通过 path.resolve 处理文件路径
    // 从数据库中获取文件数据
    db.get(path.resolve(filename), {
        valueEncoding: options.encoding
      },
      // 传入 callback
      (err, value) =&gt; {
        if(err) {
          // 模拟fs模块的异常信息
          if(err.type === &#39;NotFoundError&#39;) {
            err = new Error(`ENOENT, open &quot;${filename}&quot;`);
            err.code = &#39;ENOENT&#39;;
            err.errno = 34;
            err.path = filename;
          }
          return callback &amp;&amp; callback(err);
        }
        callback &amp;&amp; callback(null, value);
      }
    );
  };
  // 模拟fs.writeFile
  fs.writeFile = (filename, contents, options, callback) =&gt; {
    if(typeof options === &#39;function&#39;) {
      callback = options;
      options = {};
    } else if(typeof options === &#39;string&#39;) {
      options = {encoding: options};
    }
    // 同样通过path.resolve解析文件路径
    // 将文件放入数据库中
    db.put(path.resolve(filename), contents, {
      valueEncoding: options.encoding
    }, callback);
  };
  // 返回包装后的文件模块
  return fs;
};
</code></pre>

<h3 id="toc_16">Strategy</h3>

<blockquote>
<p>策略模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%8812.16.50.png" alt="屏幕快照 2017-10-29 下午12.16.50"/></p>

<p>策略模式对外暴露相同的接口, 但对于不同类型的数据, 客户端可以选择不同的处理策略.</p>

<h4 id="toc_17">Techniques for implementing Strategy</h4>

<p>这一节展示利用策略模式, 对不同格式的配置文件<code>ini</code>及<code>json</code>进行读取和写入</p>

<pre><code class="language-js">const fs = require(&#39;fs&#39;);
const ini = require(&#39;ini&#39;);
const objectPath = require(&#39;object-path&#39;);

class Config {
  // 构造方法处传入需要使用的策略对象
  constructor(strategy) {
    // 存放解析成对象后的配置
    this.data = {};
    // 用于存放策略对象, 对象需要实现 deserialize 及 serialize 方法
    this.strategy = strategy;
  }

  get(path) {
    // 获取对象内对应路径的数据
    return objectPath.get(this.data, path);
  }

  set(path, value) {
    // 设置对象内对应路径的数据
    return objectPath.set(this.data, path, value);
  }

  read(file) {
    console.log(`Deserializing from ${file}`);
    // 根据不同的策略, 使用不同的解析器对配置文件进行解析
    this.data = this.strategy.deserialize(fs.readFileSync(file, &#39;utf-8&#39;));
  }

  save(file) {
    console.log(`Serializing to ${file}`);
    fs.writeFileSync(file, this.strategy.serialize(this.data));
  }
}

strategies = {};
// 用于解析JSON文件的策略
strategies.json = {
  deserialize: data =&gt; JSON.parse(data),
  serialize: data =&gt; JSON.stringify(data, null, &#39;  &#39;)
};
// 用于解析INI文件的策略
strategies.ini = {
  deserialize: data =&gt; ini.parse(data),
  serialize: data =&gt; ini.stringify(data)
};
</code></pre>

<h3 id="toc_18">State</h3>

<blockquote>
<p>状态模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%8812.55.39.png" alt="屏幕快照 2017-10-29 下午12.55.39"/><br/>
上面的策略模式选择策略的方式是开发者根据状况,在编写代码时选择不同的策略<br/>
而状态模式是将对象编写成<strong>自动</strong>根据上下文去改变处理策略.</p>

<h4 id="toc_19">Techniques for implementing State</h4>

<p>本节展示一种自动切换状态的<code>socket</code>, 通过tcp协议传输JSON, 在连接失败时切换至<code>offline</code>状态, 并存储下需要发送的数据, 在连接成功时切换至<code>online</code>状态.</p>

<ul>
<li><code>offlineState</code>,用于处理连接断开时的状态</li>
</ul>

<pre><code class="language-js"> class OfflineState {

  constructor(failsafeSocket) {
    this.failsafeSocket = failsafeSocket;
  }

  send(data) {
    // 连接断开时无法发送数据
    // 利用 queue 暂存数据
    this.failsafeSocket.queue.push(data);
  }

  activate() {
    // retry 函数
    const retry = () =&gt; {
      setTimeout(() =&gt; this.activate(), 500);
    };
    // 连接到对端 socket
    this.failsafeSocket.socket = jot.connect(
      this.failsafeSocket.options,
      () =&gt; {
        // 连接完成时移除可能未被触发的 retry listener
        this.failsafeSocket.socket.removeListener(&#39;error&#39;, retry);
        // 连接完成时切换至 online 状态
        this.failsafeSocket.changeState(&#39;online&#39;);
      }
    );
    // 订阅 error 事件
    this.failsafeSocket.socket.once(&#39;error&#39;, retry);
  }
};
</code></pre>

<ul>
<li><code>onlineState</code>, 处理连接成功时正常发送数据的状态</li>
</ul>

<pre><code class="language-js">class OnlineState {
  constructor(failsafeSocket) {
    this.failsafeSocket = failsafeSocket;
  }

  send(data) {
    this.failsafeSocket.socket.write(data);
  };

  activate() {
    // 遍历并发送处于 offline 状态时未发送完成的数据
    this.failsafeSocket.queue.forEach(data =&gt; {
      this.failsafeSocket.socket.write(data);
    });
    // 清空队列
    this.failsafeSocket.queue = [];
    // 订阅 error 事件
    // 出现异常时切换至 offline 状态
    this.failsafeSocket.socket.once(&#39;error&#39;, () =&gt; {
      this.failsafeSocket.changeState(&#39;offline&#39;);
    });
  }
};
</code></pre>

<ul>
<li><code>FailsafeSocket</code>, 整合<code>online</code>与<code>offline</code>两种状态</li>
</ul>

<pre><code class="language-js">class FailsafeSocket {
  constructor(options) {
    this.options = options;
    this.queue = [];
    this.currentState = null;
    this.socket = null;
    this.states = {
      // FailsafeSocket 所具有的两种状态
      offline: new OfflineState(this),
      online: new OnlineState(this)
    }; 
    // 初始状态为 offline
    this.changeState(&#39;offline&#39;);
  }

  changeState(state) {
    console.log(&#39;Activating state: &#39; + state);
    this.currentState = this.states[state];
    // 激活状态对应的处理器
    this.currentState.activate();
  }

  send(data) {
    // 通过当前状态处理器发送数据
    this.currentState.send(data);
  }
}
</code></pre>

<h3 id="toc_20">Template</h3>

<blockquote>
<p>模板模式</p>
</blockquote>

<p>与C++中重写父类虚方法类似, JS中模板模式中, 通过继承模板类并重写模板方法.</p>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8A%E5%8D%8810.51.43.png" alt="屏幕快照 2017-10-30 上午10.51.43"/></p>

<h4 id="toc_21">Techniques for implementing Template</h4>

<p>以文件配置解析器为例, 留下<code>_serialize</code>与<code>_deserialize</code>给子类实现</p>

<pre><code class="language-js">const fs = require(&#39;fs&#39;);
const objectPath = require(&#39;object-path&#39;);

class ConfigTemplate {
  read (file) {
    console.log(`Deserializing from ${file}`);
    // 调用虚方法解析配置文件
    this.data = this._deserialize(fs.readFileSync(file, &#39;utf-8&#39;));
  }

  save (file) {
    console.log(`Serializing to ${file}`);
    // 调用虚方法序列化配置文件
    fs.writeFileSync(file, this._serialize(this.data));
  }

  get (path) {
    return objectPath.get(this.data, path);
  }

  set (path, value) {
    return objectPath.set(this.data, path, value);
  }

  _serialize () {
    // 如果子类未实现虚方法则抛出错误
    throw new Error(&#39;_serialize() must be implemented&#39;);
  }

  _deserialize () {
    throw new Error(&#39;_deserialize() must be implemented&#39;);
  }
}
</code></pre>

<ul>
<li>子类继承模板类并重写模板方法</li>
</ul>

<pre><code class="language-js">class JsonConfig extends ConfigTemplate {

  _deserialize (data) {
    return JSON.parse(data);
  };

  _serialize (data) {
    return JSON.stringify(data, null, &#39;  &#39;);
  }
}
</code></pre>

<h3 id="toc_22">Middleware</h3>

<blockquote>
<p>中间件模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%8812.44.47.png" alt="屏幕快照 2017-10-30 下午12.44.47"/></p>

<p>中间件模式利用中间件管理器(<code>Middleware Manager</code>), 链式传递输入, 通过多个中间件过滤形成输出.</p>

<p>以<code>koa</code>框架为例, 通过<code>app.use</code>传入一个<code>async函数</code>作为中间件处理并输出HTTP请求</p>

<p>在<code>koa</code>中, 中间件函数的签名应该为<code>async functiong(ctx, next)</code>, 其中</p>

<ul>
<li><code>ctx</code>, 表示 <code>HTTP Response</code> 与 <code>HTTP Request</code></li>
<li><code>next</code>, 表示中间件链中下一个中间件</li>
</ul>

<p>以<code>koa</code>官方实例为例</p>

<pre><code class="language-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.use(async(ctx, next) =&gt; {
  // 记录开始时间
  const start = Date.now();
  // await 下一个中间件
  await next();
  // 记录处理结束时间
  const ms = Date.now() - start;
  // 将处理事件设置在HTTP Response头部
  ctx.set(&#39;X-Response-Time&#39;, `${ms}ms`);
});

app.use(async(ctx, next) =&gt; {
  // 记录开始时间
  const start = Date.now();
  // await 下一个中间件
  await next();
  // 记录处理结束时间
  const ms = Date.now() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}`);
});

app.use(async ctx =&gt; {
  // 设置 HTTP Response 的 Body
  ctx.body = &#39;Hello World&#39;;
});

app.listen(3000);
</code></pre>

<p>整个中间件执行顺序为</p>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%881.12.05.png" alt="屏幕快照 2017-10-30 下午1.12.05"/></p>

<h3 id="toc_23">Command</h3>

<blockquote>
<p>命令模式</p>
</blockquote>

<p>命令模式通过将对 对象的操作包括对操作的回放, 撤销等 封装起来作为命令, 客户端只需执行该命令即可操纵目标对象<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%883.43.12.png" alt="屏幕快照 2017-10-30 下午3.43.12"/></p>

<ul>
<li><code>Client</code>:  命令的创建及通过<code>Invoker</code>执行命令的对象</li>
<li><code>Command</code>: 封装了对<code>Target</code>的执行命令</li>
<li><code>Invoker</code>: 缓存历史和向<code>Target</code>发送命令</li>
<li><code>Target</code>:  执行命令的对象</li>
</ul>

<p>通过命令模式执行操作而不是直接操作对象有以下优势</p>

<ul>
<li>命令可以被从新调整计划或是延后执行</li>
<li>命令可以被序列化然后通过网络传输</li>
<li>命令的执行历史可被保存, 并且在真正执行前可被撤销</li>
<li>由于命令可被缓存以及调整, 在某些算法中非常适合用于数据同步</li>
<li>多个命令可被组合, 执行过程可以被原子化</li>
</ul>

<h4 id="toc_24">Techniques for implementing Command</h4>

<p>本节展示一个简单的Map服务, 通过<code>Command</code>设置其中键值对</p>

<ul>
<li><code>Target</code>组件</li>
</ul>

<pre><code class="language-js">// Target对象
const statusUpdateService = {
  // 存储服务状态
  statusUpdates: {},
  // 模拟远程对象发送状态
  sendUpdate: function(status) {
    console.log(&#39;Status sent: &#39; + status);
    // 随机获取ID
    let id = Math.floor(Math.random() * 1000000);
    // 设置状态
    statusUpdateService.statusUpdates[id] = status;
    // 返回操作ID, 用于撤回操作
    return id;
  },
  // 根据ID撤回操作
  destroyUpdate: id =&gt; {
    console.log(&#39;Status removed: &#39; + id);
    delete statusUpdateService.statusUpdates[id];
  }
};
</code></pre>

<ul>
<li><code>Command</code>对象</li>
</ul>

<pre><code class="language-js">//封装命令参数的 Command 对象
function createSendStatusCmd(service, status) {
  let postId = null;
  // 创建Command对象
  const command = () =&gt; {
    postId = service.sendUpdate(status);
  };
  // undo方法用于撤销操作
  command.undo = () =&gt; {
    if(postId) {
      service.destroyUpdate(postId);
      postId = null;
    }
  };
  // 命令的序列化方法
  command.serialize = () =&gt; {
    return {type: &#39;status&#39;, action: &#39;post&#39;, status: status};
  };
  
  return command;
}
</code></pre>

<ul>
<li><code>Invoker</code>对象</li>
</ul>

<pre><code class="language-js">//Invoker 对象
class Invoker {
  constructor() {
    // 用于保存命令操作历史
    this.history = [];
  }

  run (cmd) {
    // 保存命令执行历史
    this.history.push(cmd);
    // 执行命令
    cmd();
    console.log(&#39;Command executed&#39;, cmd.serialize());
  }

  delay (cmd, delay) {
    // 延时执行命令
    setTimeout( () =&gt; {
      this.run(cmd);
    }, delay)
  }

  undo () {
    // 从命令历史中 pop出历史命令
    const cmd = this.history.pop();
    // 撤销命令
    cmd.undo();
    console.log(&#39;Command undone&#39;, cmd.serialize());
  }
  // 用于演示命令序列化并在远程执行
  runRemotely (cmd) {
    request.post(&#39;http://localhost:3000/cmd&#39;,
      {json: cmd.serialize()},
      err =&gt; {
        console.log(&#39;Command executed remotely&#39;, cmd.serialize());
      }
    );
  }
}
</code></pre>

<p>最后是作为<code>Client</code>, 通过<code>Invoker</code>执行命令</p>

<pre><code class="language-js">const invoker = new Invoker();
const command = createSendStatusCmd(statusUpdateService, &#39;HI!&#39;);
invoker.run(command);
invoker.delay(command, 1000 * 60 * 60);
invoker.undo();
invoker.runRemotely(command);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第五章]]></title>
    <link href="zerolocusta.github.io/15078961128669.html"/>
    <updated>2017-10-13T20:01:52+08:00</updated>
    <id>zerolocusta.github.io/15078961128669.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Coding with Streams</h2>

<blockquote>
<p>Stream作为Node.js中非常重要的概念, 在Node.js的官方库中有着广泛的体现(fs, socket, child_process等), 这一章将会阐述Stream的理念及使用方法</p>
</blockquote>

<h2 id="toc_1">摘要</h2>

<ul>
<li><code>Stream</code> 之于 <code>Node.js</code></li>
<li><code>Stream</code> 的使用方法</li>
</ul>

<h2 id="toc_2">Buffering versus streaming</h2>

<blockquote>
<p><code>Buffer</code> 与 <code>Stream</code> 的区别</p>
</blockquote>

<ul>
<li><code>Buffer</code>模式的特性</li>
</ul>

<p>大部分的异步API都是使用<code>Buffer</code>模式, 当数据<strong>接收完成</strong>的时候将它传递给<code>callback</code><br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8A%E5%8D%8810.39.50.png" alt="屏幕快照 2017-10-14 上午10.39.50"/></p>

<blockquote>
<p>在<code>t1</code>时刻, 系统仅收到<code>Hello N</code>几个字符, 还未收到一个完整的数据, 而在<code>t2</code>时刻系统接收到剩下的数据, 组成了完成的包<code>Hello Node.js</code>, 此时才把他提交给消费者</p>
</blockquote>

<p>特点: 使用<code>Buffer</code>模式的API在完成与未完成的状态之间有着完整的界限</p>

<ul>
<li><code>Stream</code>模式的特性</li>
</ul>

<p><code>Stream</code>模式与<code>Buffer</code>模式最大的不同是在<strong>接收到数据时, <code>Stream</code>模式的API会不断往消费者提交数据</strong><br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8A%E5%8D%8811.08.37.png" alt="屏幕快照 2017-10-14 上午11.08.37"/></p>

<blockquote>
<p>在<code>t1</code>时刻, 系统接收到了<code>Hello N</code>, 马上提交给消费者, 然后在接收到剩下的<code>ode.js</code>, 也马上提交到消费者</p>
</blockquote>

<p><code>Stream</code>相对于<code>Buffer</code>的优势</p>

<ul>
<li>更小的空间复杂度: <code>Buffer</code>需要开辟出一块空间用于存储接收到的数据, 在接收完毕时提交到消费者处, 而<code>Stream</code>在接收到数据后马上提交到消费者除, 空间的消耗小了很多.</li>
<li>更紧凑的时间: 相当于给后续函数提供了增量解析数据的可能性</li>
<li>可组合性: 利用<code>Stream</code>提供的<code>pipe</code>管道将多个流组合起来 </li>
</ul>

<h3 id="toc_3">Spatial efficiency</h3>

<p>V8引擎有一个限制, <code>buffer</code>大小在32位机器上不能大于<code>1GB - 1 Byte</code>, 64位系统上不能大于<code>2GB - 1 bytes</code>. (截止目前8.0版本)</p>

<p>下面给出两段代码, 演示<code>Buffer</code>与<code>Stream</code>两种不同风格下如何对文件进行压缩处理</p>

<h4 id="toc_4">Gzipping using a buffered API</h4>

<pre><code class="language-js">&quot;use strict&quot;;

const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

const file = process.argv[2];

// 读入文件
fs.readFile(file, (err, buffer) =&gt; {
  // 压缩文件
  zlib.gzip(buffer, (err, buffer) =&gt; {
    // 将压缩后文件写入硬盘
    fs.writeFile(file + &#39;.gz&#39;, buffer, err =&gt; {
      console.log(&#39;File successfully compressed&#39;);
    });
  });
});
</code></pre>

<p>在压缩大于2GB的文件时(测试环境: MacOS 10.13, 内存 16GB), 无法正确压缩文件</p>

<h4 id="toc_5">Gzipping using streams</h4>

<pre><code class="language-js">fs.createReadStream(file)
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream(file + &#39;.gz&#39;))
  .on(&#39;finish&#39;, () =&gt; console.log(&#39;File successfully compressed&#39;))
;
</code></pre>

<ul>
<li><code>fs.createReadStream</code>创建了具有<code>stream.Readable</code>特性的对象(<code>trait</code>)</li>
<li><code>zlib.createGzip</code>返回的<code>Gzip</code>实例具有<code>stream.Transform</code>的特性, 这个特性是同时具有可读和科协的流</li>
<li><code>fs.createWriteStream</code>创建了具有<code>stream.Writeable</code>特性的对象</li>
</ul>

<p>相当于<code>fs.createReadStream file | zlib.createGzip | fs.createWriteStream file.gz</code></p>

<p>由此突破了v8中对<code>Buffer</code>的限制, 经测试, 压缩大于2GB的文件并未出现问题</p>

<h3 id="toc_6">Time efficiency</h3>

<p>由于<code>Stream</code>能做到增量处理, 在时间的利用率上也非常有优势</p>

<p>设计一个CS服务</p>

<ul>
<li><code>Client</code> : 读取文件, 压缩文件, 发送文件</li>
<li><code>Server</code> : 接收文件, 解压文件, 保存文件</li>
</ul>

<p>如果这套逻辑采用<code>Buffer</code>模式实现, 读取,压缩,发送都要等待文件完成读入<code>Buffer</code>, 随后才能进行下一步操作, 虽然得益于<code>Node.js</code>的事件循环机制, 多个用户并不会因此阻塞, 但从单个用户来看, 处理时间变长了许多.</p>

<ul>
<li><code>Server</code> 的 <code>Stream</code> 模式实现</li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

// 创建HTTP服务
const server = http.createServer((req, res) =&gt; {
  // 从HTTP头部读取文件名
  const filename = req.headers.filename;
  console.log(&#39;File request received: &#39; + filename);
  req
    // 解压文件的流
    .pipe(zlib.createGunzip())
    // 创建写入文件的流
    .pipe(fs.createWriteStream(filename))
    .on(&#39;finish&#39;, () =&gt; {
      res.writeHead(201, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
      res.end(&#39;That\&#39;s it\n&#39;);
      console.log(`File saved: ${filename}`);
    });
});

server.listen(3000, () =&gt; console.log(&#39;Listening&#39;));

</code></pre>

<ul>
<li><code>Client</code> 的 <code>Stream</code> 模式实现 </li>
</ul>

<pre><code class="language-js">const options = {
  hostname: server,
  port: 3000,
  path: &#39;/&#39;,
  method: &#39;PUT&#39;,
  headers: {
    // 设置HTTP请求头部
    filename: path.basename(file),
    &#39;Content-Type&#39;: &#39;application/octet-stream&#39;,
    &#39;Content-Encoding&#39;: &#39;gzip&#39;
  }
};

const req = http.request(options, res =&gt; {
  console.log(&#39;Server response: &#39; + res.statusCode);
});
// 创建可写 Stream
fs.createReadStream(file)
  // 创建压缩文件的流
  .pipe(zlib.createGzip())
  // HttpClient 继承了 Stream.Writeable
  // 此处将压缩后的数据写入HTTP请求中
  .pipe(req)
  .on(&#39;finish&#39;, () =&gt; {
    console.log(&#39;File successfully sent&#39;);
  })
;
</code></pre>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-15%20%E4%B8%8B%E5%8D%887.19.51.png" alt="屏幕快照 2017-10-15 下午7.19.51"/></p>

<h3 id="toc_7">Composability</h3>

<blockquote>
<p>得益于<code>Stream</code>中的<code>pipe</code>方法, 多个流组合起来非常方便简洁</p>
</blockquote>

<p>对于上面的CS压缩文件传输模型, 加入加密传输功能对于<code>Stream</code>来说非常简单</p>

<ul>
<li><code>Client</code></li>
</ul>

<pre><code class="language-js">fs.createReadStream(file)
  .pipe(zlib.createGzip())
  // 对压缩后文件进行加密
  .pipe(crypto.createCipher(&#39;aes192&#39;, &#39;a_shared_secret&#39;))
  .pipe(req)
  .on(&#39;finish&#39;, () =&gt; {
    console.log(&#39;File successfully sent&#39;);
  });
</code></pre>

<ul>
<li><code>Server</code></li>
</ul>

<pre><code class="language-js">const server = http.createServer((req, res) =&gt; {
  const filename = req.headers.filename;
  console.log(&#39;File request received: &#39; + filename);
  req
    // 对收到的请求进行解密
    .pipe(crypto.createDecipher(&#39;aes192&#39;, &#39;a_shared_secret&#39;))
    .pipe(zlib.createGunzip())
    .pipe(fs.createWriteStream(filename))
    .on(&#39;finish&#39;, () =&gt; {
      res.writeHead(201, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
      res.end(&#39;That\&#39;s it\n&#39;);
      console.log(`File saved: ${filename}`);
    })
  ;
});
</code></pre>

<p>的确只以非常小的改动, 添加上加解密的功能, 但个人认为对于<code>async/await</code>来说, 在工程组合上<code>Stream</code>并无太大优势.</p>

<hr/>

<h3 id="toc_8">Getting started with streams</h3>

<blockquote>
<p>到目前为止, 我们只是看到了如何使用已有的<code>Stream</code>模块, 接下来介绍如何创建自己的<code>Stream</code>模块</p>
</blockquote>

<p>不难看出, 上面的<code>fs.createReadStream</code>和<code>fs.createWriteStream</code>都会返回一个<code>Stream</code>对象, 而在<code>Node.js</code>官方库中, <code>Stream</code>模块中具有几个可被继承的对象</p>

<ul>
<li><code>stream.Readable</code></li>
<li><code>stream.Writable</code></li>
<li><code>stream.Duplex</code></li>
<li><code>stream.Transform</code></li>
</ul>

<p>以上的类均继承了<code>EventEmitter</code>, 实现了<code>end</code>事件, <code>error</code>事件等</p>

<p><code>Stream</code>除了能像<code>fs.createReadFile</code>之类处理IO的二进制流之外(二进制流以Chunk的形式体现), <code>Stream</code>也能传递<code>Object</code>, 能从上一个<code>Stream</code>不断生成<code>Object</code>传递到下一个<code>Stream</code>中, 所以<code>Stream</code>不仅能应用于IO处理中, 普通的对象处理也能得到<code>Stream</code>的好处.</p>

<hr/>

<h3 id="toc_9">Readable streams</h3>

<blockquote>
<p>可读流的使用和创建</p>
</blockquote>

<p><code>Readable streams</code>有两种从中读取数据的方法, <code>non-flowing mode</code>和<code>flowing mode</code></p>

<h4 id="toc_10">The non-flowing mode</h4>

<p><code>non-flowing mode</code>很直白, 从可读流中读取数据直到无数据可读, 由于监听<code>readable</code>后是<code>listener</code>主动从流中读取数据, 相对于<code>flowing mode</code>, 数据并未从事件监听器流入<code>listener</code></p>

<pre><code class="language-js">process.stdin
  // 订阅了 readable
  // 当流变的可读取时调用回调函数
  .on(&#39;readable&#39;, () =&gt; {
    let chunk;
    console.log(&#39;New data available&#39;);
    // 不断循环读取数据直至结束
    while ((chunk = process.stdin.read()) !== null) {
      console.log(
        `Chunk read: (${chunk.length}) &quot;${chunk.toString()}&quot;`
      );
    }
  })
  .on(&#39;end&#39;, () =&gt; process.stdout.write(&#39;End of stream&#39;));
</code></pre>

<p>运行结果</p>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8A%E5%8D%8810.21.07.png" alt="屏幕快照 2017-10-16 上午10.21.07"/></p>

<h4 id="toc_11">Flowing mode</h4>

<p>还有一种从<code>Stream</code>中读取数据的方式是通过监听<code>data</code>事件, </p>

<p><code>stream</code>同时提供了<code>data</code>事件, 每当<code>Readable Stream</code>接收到新的数据时, <code>listener</code>就会被触发, 同时数据以形参的形式传递到<code>listener</code>中</p>

<pre><code class="language-js">process.stdin
  .on(&#39;data&#39;, chunk =&gt; {
    console.log(&#39;New data available&#39;);
    console.log(
      `Chunk read: (${chunk.length}) &quot;${chunk.toString()}&quot;`
    );
  })
  .on(&#39;end&#39;, () =&gt; process.stdout.write(&#39;End of stream&#39;));
</code></pre>

<h4 id="toc_12">Implementing Readable streams</h4>

<blockquote>
<p>创建自己的<code>Readable Stream</code></p>
</blockquote>

<p>创建自己的<code>Readable Stream</code>类的时候, 需要继承<code>stream.Readable</code>, 并实现<code>_read</code>方法, 通过<code>stream.Readable.push</code>方法往<code>Stream</code>内部提供的<code>Buffer</code>推入数据.</p>

<p>书里提供了一个利用<code>chance</code>库生成随机字符串, 并且将生成的字符串作为流输出<br/>
 <strong>(往流中推入<code>null</code>表示流的结束)</strong></p>

<pre><code class="language-js"> class RandomStream extends stream.Readable {
  constructor(options) {
    super(options);
  }
  // 实现 _read 接口
  _read(size) {
    // 生成随机字符串
    const chunk = chance.string();
    console.log(`Pushing chunk of size: ${chunk.length}`);
    // 将随机串推入内部buffer
    this.push(chunk, &#39;utf8&#39;);
    // 有 5% 的概率出现 true
    if (chance.bool({
        likelihood: 5
      })) {
      this.push(null);
    }
  }
}
</code></pre>

<p><code>RandomStream</code>使用示例</p>

<pre><code class="language-js">const randomStream = new RandomStream();

randomStream
  // 订阅 data 事件
  .on(&#39;data&#39;, (chunk) =&gt; {
    console.log(`Chunk received: ${chunk.toString()}`);
  })
  .on(&#39;end&#39;, () =&gt; {
    process.stdout.write(&#39;End of stream\n&#39;)
  });
</code></pre>

<hr/>

<h3 id="toc_13">Writable streams</h3>

<h4 id="toc_14">Writing to a stream</h4>

<blockquote>
<p>如何往<code>Writable Stream</code>中写入数据</p>
</blockquote>

<p><code>stream.Writable</code>中有两个主要方法</p>

<ul>
<li><code>writable.write(chunk[, encoding][, callback])</code>: 往<code>Writable Stream</code>中写入<code>chunk</code></li>
<li><code>writable.end([chunk][, encoding][, callback])</code>: 结束流</li>
</ul>

<p>示例:</p>

<pre><code>往HTTP回包中写入数据
</code></pre>

<pre><code class="language-js">const Chance = require(&#39;chance&#39;);
const chance = new Chance();

require(&#39;http&#39;).createServer((req, res) =&gt; {
  // 写入 HTTP 回包请求头部
  res.writeHead(200, {
    &#39;Content-Type&#39;: &#39;text/plain&#39;
  });
  while (chance.bool({
      likelihood: 95
    })) {
    // 往 HTTP 回包请求中写入随机字符串
    res.write(chance.string() + &#39;\n&#39;);
  }
  // 关闭流
  res.end(&#39;\nThe end...\n&#39;);
  res.on(&#39;finish&#39;, () =&gt; console.log(&#39;All data was sent&#39;)); //[5]
}).listen(8080, () =&gt; console.log(&#39;Listening on http://localhost:8080&#39;));    
</code></pre>

<p>回应结果:<br/>
 <img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8B%E5%8D%887.50.35.png" alt="屏幕快照 2017-10-16 下午7.50.35"/></p>

<h4 id="toc_15">Back-pressure</h4>

<blockquote>
<p>负反馈</p>
</blockquote>

<p><strong>当我们往<code>Writable Stream</code>内部的<code>Buffer</code>写入数据, 而<code>Buffer</code>的大小是有限制的, 写入数据如果过多而消费者未及时取出数据的话, 缓存很容易出现溢出现象</strong></p>

<p>为了解决缓存过载的问题, <code>stream.Writable</code>在内部设置了<code>highWaterMark</code>属性(默认是16KB), 当内部缓存无法容纳更多的数据的时候<code>writable.write</code>将会返回<code>false</code>(<code>Readable Stream</code>内部也有相似的机制)</p>

<p>应用负反馈后的<code>Http Stream</code></p>

<pre><code class="language-js">require(&#39;http&#39;).createServer((req, res) =&gt; {
  res.writeHead(200, {
    &#39;Content-Type&#39;: &#39;text/plain&#39;
  });

  function generateMore() {
    // 有 95% 的概率返回ture
    while (chance.bool({
        likelihood: 95
      })) {
      // 写入一段超长的字符串
      let shouldContinue = res.write(
        chance.string({
          length: (16 * 1024) - 1
        })
      );
      // 当
      if (!shouldContinue) { //[3]
        console.log(&#39;Backpressure&#39;);
        // 如果buffer已经触及极限, 那么订阅 drain 事件
        return res.once(&#39;drain&#39;, generateMore);
      }
    }
    
    res.end(&#39;\nThe end...\n&#39;, () =&gt; console.log(&#39;All data was sent&#39;));
  }
  generateMore();
  
}).listen(8080, () =&gt; console.log(&#39;Listening on http://localhost:8080&#39;));
</code></pre>

<p>这段代码有两个重点:</p>

<ul>
<li>创建了<code>generateMore</code>函数用于在缓存已满的情况下注册为<code>listener</code></li>
<li>在<code>writable stream</code>上监听了<code>drain</code>事件, 根据官方文档的说法, 当<code>writable stream</code>从不可写变为可写时, 注册在<code>drain</code>事件上的<code>listener</code>将会被触发</li>
</ul>

<h4 id="toc_16">Implementing Writable streams</h4>

<blockquote>
<p>实现自己的可写流</p>
</blockquote>

<p>书中示例创建一个传递<code>Object</code>的<code>Stream</code>, 与实现<code>Readable Stream</code>相似, 只需继承<code>stream.Writable</code>后实现<code>_write</code>方法即可</p>

<pre><code class="language-js">class ToFileStream extends stream.Writable {
  constructor() {
    // 启用 object 模式
    super({objectMode: true});
  }
  // chunk 实为 
  // {
  //   path: &lt;path to file&gt;,
  //   content : &lt; content of file&gt;
  // }
  // 的对象
  _write (chunk, encoding, callback) {
    // 创建目录
    mkdirp(path.dirname(chunk.path), err =&gt; {
      if (err) {
        return callback(err);

      }
      // 写入文件
      fs.writeFile(chunk.path, chunk.content, callback);
    });
  }
}
</code></pre>

<p>使用示例</p>

<pre><code class="language-js">let tfs = new ToFileStream();

tfs.write({path: &quot;file1.txt&quot;, content: &quot;Hello&quot;});
tfs.write({path: &quot;file2.txt&quot;, content: &quot;Node.js&quot;});
tfs.write({path: &quot;file3.txt&quot;, content: &quot;Streams&quot;});
tfs.end(() =&gt; console.log(&quot;All files created&quot;));
</code></pre>

<hr/>

<h3 id="toc_17">Duplex streams</h3>

<p><code>Duplex streams</code>表示一种双向的流, 同时继承了<code>Readable Stream</code> 和 <code>Writable Stream</code>, 适合用于具有双向通信功能的实现(例如Socket)<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8B%E5%8D%8811.41.05.png" alt="屏幕快照 2017-10-16 下午11.41.05"/></p>

<h3 id="toc_18">Transform streams</h3>

<p><code>Transform streams</code>是特殊的<code>Duplex streams</code>, 在<code>Readable Stream</code>和<code>Writable Stream</code> 之间提供额外的桥梁<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-17%20%E4%B8%8A%E5%8D%8811.21.06.png" alt="屏幕快照 2017-10-17 上午11.21.06"/></p>

<h4 id="toc_19">Implementing Transform streams</h4>

<p><code>stream.Transform</code>类中有两个需要子类实现的方法</p>

<ul>
<li><code>_transform</code> : 用于在<code>write</code>时调用并写入内部缓存</li>
<li><code>_flust</code>: 在<code>end</code>方法调用时将剩余数据推入内部缓存中</li>
</ul>

<p>示例: 往<code>Transform streams</code>写入字符串, 替换目标字符串并输出</p>

<pre><code class="language-js">class ReplaceStream extends stream.Transform {
  constructor(searchString, replaceString) {
    super();
    this.searchString = searchString;
    this.replaceString = replaceString;
    this.tailPiece = &#39;&#39;;
  }

  _transform(chunk, encoding, callback) {
    // 利用 String.prototype.split 提取出所有目标字符串
    const pieces = (this.tailPiece + chunk)
      .split(this.searchString);
    // 获取分片后字符串数组的末尾元素
    const lastPiece = pieces[pieces.length - 1];
    // 由于写入流的数据不一定是工整的,
    // 需要从输入的流中读取至少searchString.length - 1个字符
    // 用于与后续输入的数据进行拼接搜索
    const tailPieceLen = this.searchString.length - 1;
    // 从末尾切分出 tailPieceLen 长度的字符串
    this.tailPiece = lastPiece.slice(-tailPieceLen);
    // 去除 his.tailPiece 部分的字符串, 以免重复
    pieces[pieces.length - 1] = lastPiece.slice(0, -tailPieceLen);
    // pieces 是由 searchString 分割的字符串数组
    // 经过slice去掉 searchString 后通过 replaceString
    // 拼接字符串数组, 得到替换后的字符串
    // 推入 Readable Stream 中
    this.push(pieces.join(this.replaceString));
    callback();
  }
  // 当流结束时, 切割下来的 tailPiece 仍未推入内部缓存
  // 通过_flush将最后的字符串推入内部缓存
  _flush(callback) {
    this.push(this.tailPiece);
    callback();
  }
}
</code></pre>

<p>使用示例:</p>

<pre><code class="language-js const">// 指定替换的字符串
const rs = new ReplaceStream(&#39;World&#39;, &#39;Node.js&#39;);
// 订阅 Readable Stream 一侧上的 data 事件
// 接收到数据时输出到终端
rs.on(&#39;data&#39;, chunk =&gt; console.log(chunk.toString()));
// 往 Writable Stream 一侧上写入数据
rs.write(&#39;Hello W&#39;);
rs.write(&#39;orld!&#39;);
rs.end();
</code></pre>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-18%20%E4%B8%8B%E5%8D%884.41.13.png" alt="屏幕快照 2017-10-18 下午4.41.13"/></p>

<p>运行结果的输出对应了<code>ReplaceStream</code>的实现所映射出的<code>push数据</code>的行为.</p>

<h4 id="toc_20">Through and from for working with streams</h4>

<p>两个用于快速生成<code>Transform Stream</code> 和 <code>Readable Stream</code>的库</p>

<ul>
<li>through2 , 用于生成<code>Transform Stream</code></li>
</ul>

<pre><code class="language-js">const transform = through2([options], [_transform], [_flush])
</code></pre>

<ul>
<li>from , 用于生成<code>Readable Stream</code>的库</li>
</ul>

<pre><code class="language-js">const readable = from2([options], _read)
</code></pre>

<h3 id="toc_21">Asynchronous control flow with streams</h3>

<blockquote>
<p>实际代码中如何使用<code>Stream</code><br/>
之前的<code>spider</code>实例相似, 分别以<code>Sequential execution</code>和<code>Parallel execution</code>为例</p>
</blockquote>

<h4 id="toc_22">Sequential execution</h4>

<p>以<code>Stream</code>实现一个线性执行拼接文件的功能.</p>

<pre><code class="language-js">const fromArray = require(&#39;from2-array&#39;);
const through = require(&#39;through2&#39;);
const fs = require(&#39;fs&#39;);

function concatFiles(destination, files, callback) {
  // 创建用于存放拼接后文件的 Writable Stream
  const destStream = fs.createWriteStream(destination);
  // fromArray.obj 将会遍历 files
  // 将多个文件名通过 pipe 传递到下一个 Stream
  fromArray.obj(files)
    // 利用 through2 创建一个 Transform Stream
    .pipe(through.obj((file, enc, done) =&gt; {
      //  通过文件名创建 Readable Stream
      const src = fs.createReadStream(file);
      // 往目标文件中写入数据
      // 由于 pipe 在完成时会自动调用end函数
      // 但destStream并未将所有文件拼接完成,
      // 此处将 end 设为 false
      src.pipe(destStream, {
        end: false,
      });
      // 当前文件拼接完毕时调用done函数
      // 以供 fromArray 向 pipe 传递下一个文件名
      src.on(&#39;end&#39;, done);
    }))
    // 在所有文件遍历完毕时
    // 介素 Writable Stream
    .on(&#39;finish&#39;, () =&gt; {
      destStream.end();
      callback();
    });
}
</code></pre>

<p><code>Stream</code>风格的串行执行和上两章中的串行执行风格其实有很多相似的地方</p>

<ul>
<li><code>fromArray.obj</code>逐个遍历文件名并传递到下个流中, 而<code>through.obj</code>中的回调函数在处理完单个文件时, 通过调用<code>done</code>触发下个文件的处理, 类似于上两章串行执行风格中的<code>next</code>函数, 以控制任务遍历的速度</li>
<li>在所有文件处理完毕时, <code>destStream.end</code>标识处理结束, 与上两章串行执行风格中, 执行完毕调用<code>callback</code>相似</li>
</ul>

<h4 id="toc_23">Unordered parallel execution</h4>

<blockquote>
<p>利用<code>Stream</code>实现非顺序的并行执行任务</p>
</blockquote>

<pre><code class="language-js">class ParallelStream extends stream.Transform {
  constructor(userTransform) {
    super({
      objectMode: true
    });
    // userTransform 存放处理任务的函数
    // 也就是用于处理任务的 worker 函数
    this.userTransform = userTransform;
    // 用于记录当前正在运行任务数
    this.running = 0;
    this.terminateCallback = null;
  }

  _transform(chunk, enc, done) {
    this.running++;
    // 将数据传递到 worker 函数
    this.userTransform(chunk, enc, this._onComplete.bind(this), this.push.bind(this));
    // 由于是并发执行 userTransform
    // 我们有自己的_onComplete函数处理worker函数完成事件
    // 需要调用done触发流中下一个任务
    done();
  }

  _flush(done) {
    if (this.running &gt; 0) {
      // 在流结束时还有任务运行时
      // 暂不结束当前流
      this.terminateCallback = done;
    } else {
      done();
    }
  }

  _onComplete(err) {
    // 减少运行任务数
    this.running--;
    if (err) {
      // 往 error 事件发送错误
      return this.emit(&#39;error&#39;, err);
    }
    // _onComplete在每次task完成都会触发
    if (this.running === 0) {
      this.terminateCallback &amp;&amp; this.terminateCallback();
    }
  }
}
</code></pre>

<p><code>Stream</code>的并行执行模式有几点重要的地方</p>

<ul>
<li>利用<code>Stream</code>中的<code>done</code>函数, 强制<code>Stream</code>处理下一个元素</li>
<li>通过<code>running</code>记录正在执行的任务</li>
<li>任务完成时调用<code>_onComplete</code>函数, 触发完成事件.</li>
</ul>

<h4 id="toc_24">Unordered limited parallel execution</h4>

<p>在并行执行中加入并发任务数限制</p>

<pre><code class="language-js">class LimitedParallelStream extends stream.Transform {
  // 加入 concurrency 限制并发数
  constructor(concurrency, userTransform) {
    super({objectMode: true});
    this.concurrency = concurrency;
    this.userTransform = userTransform;
    this.running = 0;
    this.terminateCallback = null;
    this.continueCallback = null;
  }

  _transform(chunk, enc, done) {
    this.running++;
    this.userTransform(chunk, enc,  this.push.bind(this), this._onComplete.bind(this));
    if(this.running &lt; this.concurrency) {
      // 未触及并发上限
      // 调用 done 促使 Stream 传入下一个任务
      done();
    } else {
      // 当某个任务完成时,
      // 调用的 _onComplete 函数的时候将会调用continueCallback
      // 此时触发Stream 传入下一个任务
      this.continueCallback = done;
    }
  }

  _flush(done) {
    if(this.running &gt; 0) {
      this.terminateCallback = done;
    } else {
      done();
    }
  }

  _onComplete(err) {
    this.running--;
    if(err) {
      return this.emit(&#39;error&#39;, err);
    }
    // 由continueCallback指示是否存在等待执行的任务
    const tmpCallback = this.continueCallback;
    this.continueCallback = null;
    tmpCallback &amp;&amp; tmpCallback();
    if(this.running === 0) {
      this.terminateCallback &amp;&amp; this.terminateCallback();
    }
  }
}
</code></pre>

<ul>
<li>这里利用了<code>Stream</code>的机制来充当任务队列, 任务存储在<code>pipe</code>中的上一个<code>Stream</code>中, 而任务控制通过<code>done</code>来控制任务流入的速度</li>
</ul>

<hr/>

<h3 id="toc_25">Piping patterns</h3>

<blockquote>
<p>利用<code>pipe</code>设计和组合<code>Stream</code></p>
</blockquote>

<h4 id="toc_26">Combining streams</h4>

<p>将多个<code>Stream</code>组合起来, 对外只暴露成一个<code>Stream</code><br/>
将<code>Stream</code>组合起来有多个优点</p>

<ul>
<li>将多个流简化, 对外暴露单个接口</li>
<li>流的错误处理简化, 所有被组合的流的错误信息被重定向到组合后的流的错误事件里, 对外接口只需订阅组合后流的错误时间即可</li>
</ul>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8A%E5%8D%8811.28.49.png" alt="屏幕快照 2017-10-20 上午11.28.49"/></p>

<p>组合多个流基于两个原则:</p>

<ul>
<li>当我们往一个组合后的流写入数据时, 实际上是往组合中的第一个流写入数据</li>
<li>当我们往一个组合后的流读取数据时, 实际上是往组合中的最后一个流读取数据</li>
</ul>

<p>基于上述的原则, 利用<code>Duplex Stream</code>或<code>Transform Stream</code>能很轻松做到组合多个流, 而在这里使用第三方库<code>multipipe</code></p>

<pre><code class="language-js">const zlib = require(&#39;zlib&#39;);
const crypto = require(&#39;crypto&#39;);
const combine = require(&#39;multipipe&#39;);

module.exports.compressAndEncrypt = password =&gt; {
  // 返回一个组合后的流
  return combine(
    // 压缩数据
    zlib.createGzip(),

    // 加密数据
    crypto.createCipher(&#39;aes192&#39;, password)
  );
};

module.exports.decryptAndDecompress = password =&gt; {
  return combine(
    // 解密数据
    crypto.createDecipher(&#39;aes192&#39;, password),
    // 解压数据
    zlib.createGunzip()
  );
};
</code></pre>

<p>组合后的<code>Stream</code>使用方法与普通<code>Stream</code>无异.</p>

<h4 id="toc_27">Forking streams</h4>

<p>针对<code>Readable Stream</code>能fork出多个流, 提供给后续多个pipe的数据<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8B%E5%8D%884.48.39.png" alt="屏幕快照 2017-10-20 下午4.48.39"/></p>

<p>而实现方法也非常简单, 直接在同一个<code>Readable Stream</code>实例上分别调用<code>pipe</code>方法.</p>

<ul>
<li>对输入的文件同时进行<code>sha1</code>与<code>md5</code>哈希计算</li>
</ul>

<pre><code class="language-js">const fs = require(&#39;fs&#39;);
const crypto = require(&#39;crypto&#39;);

const sha1Stream = crypto.createHash(&#39;sha1&#39;);
sha1Stream.setEncoding(&#39;base64&#39;);

const md5Stream = crypto.createHash(&#39;md5&#39;);
md5Stream.setEncoding(&#39;base64&#39;);

const inputFile = process.argv[2];
const inputStream = fs.createReadStream(inputFile);
// 在同一个inputStream实例上调用pipe
// 完成 Fork Stream
inputStream
  .pipe(sha1Stream)
  .pipe(fs.createWriteStream(inputFile + &#39;.sha1&#39;));

inputStream
  .pipe(md5Stream)
  .pipe(fs.createWriteStream(inputFile + &#39;.md5&#39;));
</code></pre>

<h4 id="toc_28">Merging streams</h4>

<blockquote>
<p>整个多个流</p>
</blockquote>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8B%E5%8D%8810.27.15.png" alt="屏幕快照 2017-10-20 下午10.27.15"/></p>

<p>实现方法:</p>

<ul>
<li>在多个留上使用<code>pipe</code>方法导向同一个流, 并把<code>pipe</code>方法的自动结束<code>Stream</code>设为<code>false</code>({end: false})</li>
<li>订阅多个流的<code>end</code>事件, 应用自定义的处理<code>end</code>事件函数</li>
</ul>

<p>示例: 将多个文件流导向同一个压缩处理流中</p>

<pre><code class="language-js">const tar = require(&#39;tar&#39;);
const fstream = require(&#39;fstream&#39;);
const path = require(&#39;path&#39;);

const destination = path.resolve(process.argv[2]);
const sourceA = path.resolve(process.argv[3]);
const sourceB = path.resolve(process.argv[4]);

// 获取压缩流(Writable Stream)
const pack = tar.Pack();
// 将压缩后的流写入文件中
pack.pipe(fstream.Writer(destination));

let endCount = 0;
// 用于在多个流处理结束后
// 关闭 压缩流
function onEnd() {
  if(++endCount === 2) {
    pack.end();
  }
}

const sourceStreamA = fstream.Reader({type: &quot;Directory&quot;, path: sourceA})
  .on(&#39;end&#39;, onEnd);

const sourceStreamB = fstream.Reader({type: &quot;Directory&quot;, path: sourceB})
  .on(&#39;end&#39;, onEnd);

// 两个流重定向至 pack
sourceStreamA.pipe(pack, {end: false});
sourceStreamB.pipe(pack, {end: false});
</code></pre>

<h4 id="toc_29">Multiplexing and demultiplexing</h4>

<blockquote>
<p>复用单个流写入多个数据, 在另一端从单个流中解离出多个数据<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8B%E5%8D%8811.13.06.png" alt="屏幕快照 2017-10-20 下午11.13.06"/><br/>
在两段利用对称的<code>mux</code>和<code>demux</code>函数融合与分离多个流</p>
</blockquote>

<p>示例: 创建CS服务, <code>Server</code>接收数据并写入文件中(log服务), <code>Client</code>发送日志数据.</p>

<ul>
<li><code>Client</code></li>
</ul>

<pre><code class="language-js">const child_process = require(&#39;child_process&#39;);
const net = require(&#39;net&#39;);

// multiplexChannels 用于将多个流(sources)
// 同时写入同一个流(destination)中
function multiplexChannels(sources, destination) {
  let totalChannels = sources.length;
  // 遍历sources数组中的多个流
  for (let i = 0; i &lt; sources.length; i++) {
    sources[i]
      // 订阅 readable 事件
      .on(&#39;readable&#39;, function () {
        let chunk;
        // 利用 Non-Flowing 模式
        while ((chunk = this.read()) !== null) {
          const outBuff = new Buffer(1 + 4 + chunk.length);
          // 每一个buffer头部
          // 8 bits用于标识数据的ID
          outBuff.writeUInt8(i, 0);
          // 紧接着的32 bits用于记录当前chunk的长度
          outBuff.writeUInt32BE(chunk.length, 1);
          // 将 chunk 复制到 outBuffer 中
          chunk.copy(outBuff, 5);
          console.log(&#39;Sending packet to channel: &#39; + i);
          // 将数据写入 destination 流中
          destination.write(outBuff);
        }
      })
      .on(&#39;end&#39;, () =&gt; {
        // 在所有sources上订阅end事件
        if (--totalChannels === 0) {
          // 当所有流处理完毕,
          // 关闭 destination
          destination.end();
        }
      });
  }
}

const socket = net.connect(3000, () =&gt; {
  const child = child_process.fork(
    process.argv[2],
    process.argv.slice(3), {
      silent: true
    }
  );
  multiplexChannels([child.stdout, child.stderr], socket);
});
</code></pre>

<p><code>Client</code>中使用<code>Non-Flowing</code>模式非常重要, 每次往<code>destination</code>中写入一个完整的<code>Chunk</code>, 不会导致多个<code>Chunk</code>交错在一起.</p>

<ul>
<li><code>Server</code></li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const net = require(&#39;net&#39;);
const fs = require(&#39;fs&#39;);

function demultiplexChannel(source, destinations) {
  let currentChannel = null;
  let currentLength = null;
  source
    // 订阅 readable 事件
    .on(&#39;readable&#39;, () =&gt; {
      let chunk;
      if (currentChannel === null) {
        // 从source中读取 8 bits, 获得管道的ID
        chunk = source.read(1);
        currentChannel = chunk &amp;&amp; chunk.readUInt8(0);
      }

      if (currentLength === null) {
        // 从source中读取 32 bits, 获的Chunk的长度
        chunk = source.read(4);
        // 转换字节序
        currentLength = chunk &amp;&amp; chunk.readUInt32BE(0);
        if (currentLength === null) {
          // 如果 currentLength 获取失败
          // 表明 tcp 流在传输过程中被切分
          // 在下次可读事件时重新读取
          return;
        }
      }
      // 从source中读取chunk长度的数据
      chunk = source.read(currentLength);
      if (chunk === null) {
        // 如果currentLength长度的数据读取失败
        // 说明TCP流被拆包
        // 也需要在下次可读事件时再重新读取
        return;
      }

      console.log(&#39;Received packet from: &#39; + currentChannel);

      // 往 destinations 中写入chunk
      destinations[currentChannel].write(chunk);
      // 写入完成后复原头部数据
      currentChannel = null;
      currentLength = null;
    })
    .on(&#39;end&#39;, () =&gt; {
      destinations.forEach(destination =&gt; destination.end());
      console.log(&#39;Source channel closed&#39;);
    });
}

net.createServer(socket =&gt; {
    const stdoutStream = fs.createWriteStream(&#39;stdout.log&#39;);
    const stderrStream = fs.createWriteStream(&#39;stderr.log&#39;);
    demultiplexChannel(socket, [stdoutStream, stderrStream]);
  })
  .listen(3000, () =&gt; console.log(&#39;Server started&#39;));
</code></pre>

<p><code>Server</code>利用了<code>Client</code>中<code>Chunk</code>串行写入与TCP协议的实现中按序移交到用户态的特性, 按序读取<code>Chunk</code>并写入文件中.</p>

<p>运行结果<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-21%20%E4%B8%8A%E5%8D%8812.14.05.png" alt="屏幕快照 2017-10-21 上午12.14.05"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第四章]]></title>
    <link href="zerolocusta.github.io/15064131114315.html"/>
    <updated>2017-09-26T16:05:11+08:00</updated>
    <id>zerolocusta.github.io/15064131114315.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Asynchronous Control Flow Patterns with ES2015 and Beyond</h2>

<blockquote>
<p>本章主要讲述了ES6中的Promise, Generator特性与使用方法, 以及稍微探讨了async/await</p>
</blockquote>

<hr/>

<h2 id="toc_1">摘要</h2>

<ul>
<li>Promise</li>
<li>Generator</li>
<li>async / await</li>
</ul>

<hr/>

<h2 id="toc_2">Promise</h2>

<p>除了上一章的CPS风格之外, 在JS中实现异步编程还有另外一些风格, 例如ES6新加入的Promise</p>

<h3 id="toc_3">What is a promise?</h3>

<blockquote>
<p>在JavaScript中, <code>Promise</code>按照<a href="https://promisesaplus.com/">Promise a+</a>标准实现</p>
</blockquote>

<p><code>Promise</code>指的是对异步操作的抽象, 而<code>Promise</code>又有多种状态</p>

<ul>
<li>当<code>Promise</code>操作未完成时状态称为<code>pending</code></li>
<li>当<code>Promise</code>操作成功完成时状态称为<code>fulfilled</code></li>
<li>当<code>Promise</code>操作失败时状态称为<code>rejected</code></li>
<li>无论<code>Promise</code>操作成功或者失败, 状态都叫<code>settled</code></li>
</ul>

<p>在JavaScript中, <code>Promise</code>被实现为一个对象, <strong>实例中</strong>提供了<code>then</code>方法用于接收异步事件的完成状态</p>

<ul>
<li><code>promise.then(onFulfilled[, onRejected])</code>: <code>onFulfilled</code>和<code>onRejected</code>都是接收一个形参的函数,<code>onFulfilled</code>用于接收<code>Promise</code>成功执行之后的结果, 而<code>onRejected</code>用于接收<code>Promise</code>执行失败的结果, 返回值为<strong>另一个</strong>处于<code>pending</code>状态的<code>Promise</code>实例</li>
</ul>

<p>和异步CPS风格作对比</p>

<pre><code class="language-js">// CPS风格
asyncOperation(arg, (err, result) =&gt; {
    if (err) { 
        //处理错误
        return;
    } 
    // 正常处理流程 
});

// Promise风格, 假设asyncOperation返回一个Promise的实例
// 传入了两个函数用于处理 正常事件 和 异常事件
asyncOperation(arg).then(result =&gt; { 
    //do stuff with result   
}, err =&gt; {
    //handle error   
});
</code></pre>

<p><code>then()</code>方法还有一些很重要的属性</p>

<ol>
<li><code>then()</code>必然返回另外一个<code>Promise</code>实例, 只有当第一个<code>Promise</code>解决或被拒绝后, 第二个<code>Promise</code>才会被解决 (<code>then</code>方法是异步的, 但返回的另一个<code>Promise</code>只有在第一个<code>Promse</code>解决或被拒绝后才开始执行)</li>
<li>由于<code>then()</code>函数返回另一个<code>Promise</code>实例, 有可能形成一个<code>Promise</code>链, <code>onFulfilled</code>或<code>onRejected</code>的返回值会在<code>Promise</code>链中传递

<ul>
<li>当<code>onFulfilled</code>或<code>onRejected</code>的返回值为<code>Promise</code>实例<strong>以外</strong>的值时, 以此返回值作为下一个<code>Promise</code>中传递给<code>onFulfilled</code>函数的值</li>
<li>当<code>onFulFilled</code>返回一个<code>Promise</code>实例时, <code>then()</code>方法的返回值会替换为<code>onFulFilled</code>的返回值, 但是当第一个<code>Promise</code>被拒绝时, 第二个<code>Promise</code>的<code>onFulfilled</code>方法将不会被调用</li>
</ul></li>
</ol>

<p>由于上述的特性, 我们可以非常容易实现一个串行执行的<code>Promise</code>链</p>

<pre><code class="language-js">asyncOperation(arg).then(result1 =&gt; {
    // asyncOperation返回另一个Promise实例 
    return asyncOperation(arg2);
}).then(result2 =&gt; {
    // 返回一个普通的值  
    return &#39;done&#39;;
}).then(undefined, err =&gt; {
    // 利用 onRejected 函数捕抓异常
});
</code></pre>

<p><img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-26%20%E4%B8%8B%E5%8D%889.34.16.png" alt="屏幕快照 2017-09-26 下午9.34.16"/></p>

<h4 id="toc_4">Promise对象</h4>

<ol>
<li>构造函数<code>Constructor (new Promise(function(resolve, reject) {}))</code>

<ul>
<li><code>resolve(obj)</code>: 会将<code>Promise</code>置为<code>Fulfilled</code>状态</li>
<li><code>reject(err)</code> : 会将<code>Promise</code>置为<code>Rejected</code>状态</li>
</ul></li>
<li>静态方法

<ul>
<li><code>Promise.resolve(obj)</code>: 将会创建一个已解决的<code>Promise</code>实例</li>
<li><code>Promise.reject(err)</code> : 将会创建一个被拒绝的<code>Promise</code>实例</li>
<li><code>Promise.all(iterable)</code> : 返回一个新的<code>Promise</code>实例, 并且在<code>iterable</code>中<strong>所有</strong><code>Promise</code>状态为<code>Fulfilled</code>时, 返回的<code>Promise</code>实例状态会被置为<code>Fulfilled</code>, 如果<code>iterable</code>中至少有一个<code>Promise</code>状态为<code>Rejected</code>时, 返回的<code>Promise</code>实例状态也会被置为<code>Rejected</code>并且拒因为<strong>第一个</strong>被拒绝<code>Promise</code>的拒因</li>
<li><code>Promise.race(iterable)</code> : 返回一个<code>Promise</code>实例, 当<code>iterable</code>中任何一个<code>Promise</code>解决或被拒绝时, 返回的<code>Promise</code>实例以同样的原因完成.</li>
</ul></li>
<li>实例方法

<ul>
<li><code>promise.then(onFulfilled, onRejected)</code> : 已经介绍过了</li>
<li><code>promise.catch(onRejected)</code> : 是<code>promise.then(undefined, onRejected)</code>的语法糖</li>
</ul></li>
</ol>

<h4 id="toc_5">Promisifying a Node.js style function</h4>

<blockquote>
<p>创建一个工具函数将CPS风格函数转换为Promise</p>
</blockquote>

<p>遵循了JavaScript编程风格(Callbacks come last 和 Error come First)的函数是很容易被转换成Promise的, 而且<code>util.promisify</code>也提供了这样的函数, 书中也给出了一个实现</p>

<pre><code class="language-js">module.exports.promisify = function (callbackBasedApi) {
    // 包裹 callbackBasedApi, 返回一个新函数
    return function promisified() {
        // Function.arguments 是 Function 实例中存储着形参对象
        // 仅在 Node.js下生效

        // 将 arguments 对象 转换为数组
        const args = [].slice.call(arguments);
        // 创建一个Promise实例
        return new Promise((resolve, reject) =&gt; {
            // 按照callback come last的约定在形参末尾推入回调函数
            args.push((err, result) =&gt; { 
                if (err) {
                    return reject(err);
                }
                if (arguments.length &lt;= 2) {
                    resolve(result);
                } else {
                    resolve([].slice.call(arguments, 1));
                }
            });
            // 调用 callbackBasedApi, callback被替换
            callbackBasedApi.apply(null, args);
        });
    }
};
</code></pre>

<p>这段代码将<code>reject</code>和<code>resolve</code>置入需要被包裹的函数的回调形参中, 令函数完成调用callback时, 触发<code>Promise</code>状态的变换.</p>

<h3 id="toc_6">Sequential execution</h3>

<blockquote>
<p>串行执行的<code>spider</code>网络爬虫, 以<code>Promise</code>的风格实现</p>
</blockquote>

<p>首先把之前的CPS风格函数用<code>promisify</code>将其Promise风格化</p>

<pre><code class="language-js">const utilities = require(&#39;./utilities&#39;);
const request = utilities.promisify(require(&#39;request&#39;));
const mkdirp = utilities.promisify(require(&#39;mkdirp&#39;));
const fs = require(&#39;fs&#39;);
const readFile = utilities.promisify(fs.readFile);
const writeFile = utilities.promisify(fs.writeFile);
</code></pre>

<p>对<code>download</code>函数<code>Promise</code>化</p>

<pre><code class="language-js">function download(url, filename) {
    console.log(`Downloading ${url}`);
    let body;
    return request(url)
    .then(response =&gt; {
        body = response.body;
        // 返回新的Promise
        return mkdirp(path.dirname(filename));
    })
    .then(
        // writeFile 同样返回一个Promise
        () =&gt; writeFile(filename, body)
    )
    .then(() =&gt; {
        console.log(`Downloaded and saved: ${url}`);
        return body;
    });
}
</code></pre>

<p>对<code>spider</code>函数<code>Promise</code>化</p>

<pre><code class="language-js">function spider(url, nesting) {
  let filename = utilities.urlToFilename(url);
  // 先从本地查找此URL是否已被下载
  return readFile(filename, &#39;utf8&#39;)
    .then(
      // 如果已存在则直接从文件中查找其他链接
      (body) =&gt; (spiderLinks(url, body, nesting)),
      // 不存在则下载URL
      (err) =&gt; {
        if (err.code !== &#39;ENOENT&#39;) {
          throw err;
        }

        return download(url, filename)
          .then(body =&gt; spiderLinks(url, body, nesting));
      }
    );
}
</code></pre>

<h4 id="toc_7">Sequential iteration</h4>

<p>还记得串行模式的核心是控制遍历的速度, 也就是通过自制的<code>iterator</code>函数去遍历任务, 而<code>spider</code>中是由<code>spiderLinks</code>去控制多个URL下载</p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting) {
  // 初始化用于控制串行流的Promise
  let promise = Promise.resolve();
  if (nesting === 0) {
    return promise;
  }
  // 获取页面内链接
  const links = utilities.getPageLinks(currentUrl, body);
  links.forEach(link =&gt; {
    // 利用Promise只有在上一个Promise执行成功, 下一个Promise才会执行的特性
    // 串行执行多个Promise实例
    promise = promise.then(() =&gt; spider(link, nesting - 1));
  });

  return promise;
}
</code></pre>

<p>利用链式调用<code>Promise</code>只有在上一个<code>Promise</code>完成后才会执行下一个<code>Promise</code>的特性, 串行执行</p>

<p>执行结果<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-27%20%E4%B8%8B%E5%8D%888.06.48.png" alt="屏幕快照 2017-09-27 下午8.06.48"/></p>

<h4 id="toc_8">Sequential iteration – the pattern</h4>

<blockquote>
<p>串行遍历在<code>Promise</code>风格下的经典模式</p>
</blockquote>

<pre><code class="language-js">// 构造任务队列
let tasks = [ /* ... */ ]
// 初始化 Promise 链
let promise = Promise.resolve();
// 构造 Promise 任务链
tasks.forEach(task =&gt; {
  promise = promise.then(() =&gt; {
    return task();
  });
});
// 启动 Promise
promise.then(() =&gt; {
  //All tasks completed 
});
</code></pre>

<p>而这里遍历<code>task</code>就是一个对任务队列的<strong>化约</strong>操作, 也可以用<code>reduce</code>函数代替</p>

<pre><code class="language-js">// 构造任务队列
let tasks = [ /* ... */ ]
let promise = tasks.reduce((prev, task) =&gt; {
  // 利用 reduce 形成 Promise 链
  return prev.then(() =&gt; {
    return task();
  });
}, Promise.resolve());
// 启动 Promise
promise.then(() =&gt; {
  //All tasks completed 
});
</code></pre>

<hr/>

<h3 id="toc_9">Parallel execution</h3>

<blockquote>
<p>并行执行的<code>spider</code>网络爬虫, 以<code>Promise</code>的风格实现</p>
</blockquote>

<p>只需要修改<code>spiderLink</code>并利用<code>Promise.all</code>并行运行多个任务就可以了</p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting) {
  //  爬取深度
  if (nesting === 0) {
    return Promise.resolve();
  }
  // 获取页面内所有链接
  const links = utilities.getPageLinks(currentUrl, body);
  // 构造Promise任务列表
  const promises = links.map(link =&gt; spider(link, nesting - 1));
  // 并行运行多个promise
  return Promise.all(promises);
}
</code></pre>

<h3 id="toc_10">Limited parallel execution</h3>

<p>在上一章的<strong>Limited parallel execution</strong>小节中, 构造了一个<code>TaskQueuee</code>用于限制和管理任务, 这里用<code>Promise</code>风格实现一遍</p>

<p>修改<code>TaskQueue</code></p>

<pre><code class="language-js"> class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    // 队列中存储着多个promise
    this.queue = [];
  }

  pushTask(task) {
    this.queue.push(task);
    // 同样充当在任务推入队列后Notify的作用
    this.next();
  }

  next() {
    while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {
      // 获取 queue 中第一个 promise
      const task = this.queue.shift();
      // 设置promise完成后减少running, 让出资源
      task().then(() =&gt; {
        this.running--;
        this.next();
      });
      this.running++;
    }
  }
};
</code></pre>

<p>修改<code>spiderLinks</code>, 接入<code>TaskQueue</code></p>

<pre><code class="language-js">// 构造任务队列, 限制并发数为2
let downloadQueue = new TaskQueue(2);

function spiderLinks(currentUrl, body, nesting) {
  // 达到爬取深度, 返回 Fulfilled 状态的 Promise
  if(nesting === 0) {
    return Promise.resolve();
  }
  // 获取页面内所有链接
  const links = utilities.getPageLinks(currentUrl, body);
  // 如果页面内没有链接, 返回一个 Fulfilled 的Promise
  if(links.length === 0) {
    return Promise.resolve();
  }
  // 返回一个Promise实例
  return new Promise((resolve, reject) =&gt; {
    let completed = 0;
    let errored = false;
    links.forEach(link =&gt; {
      let task = () =&gt; {
        // task 返回一个 promise 实例
        return spider(link, nesting - 1)
          .then(() =&gt; {
            // 当所有链接爬取完毕时Promise置为Fulfilled状态
            if(++completed === links.length) {
              resolve();
            }
          })
          .catch(() =&gt; {
            // 出现异常时
            if (!errored) {
              errored = true;
              reject();
            }
          })
        ;
      };
      // 将Promise任务推入任务队列
      downloadQueue.pushTask(task);
    }); 
  });
}
</code></pre>

<h3 id="toc_11">Exposing callbacks and promises in public APIs</h3>

<blockquote>
<p>在使用优秀的第三方库的时候, 很多函数都会同时提供<code>callback</code>风格和<code>Promise</code>风格的API<br/>
一是为了兼容旧的API接口, 又能同时提供<code>Promise</code>风格的新接口</p>
</blockquote>

<p>书中的示例</p>

<pre><code class="language-js"> function asyncDivision(dividend, divisor, cb) {
  return new Promise((resolve, reject) =&gt; { // [1]
    // 注意到函数名是 asyncDivision, 
    // 利用 process.nextTick 使函数异步执行
    process.nextTick(() =&gt; {
      const result = dividend / divisor;
      if (isNaN(result) || !Number.isFinite(result)) {
        const error = new Error(&#39;Invalid operands&#39;);
        // 除了 reject Promise, 
        // 也要将错误传递到 callback 中
        if (cb) {
          cb(error);
        }
        return reject(error);
      }
      // 正常调用callback
      if (cb) {
        cb(null, result);
      }
      // 同时将promise置为Fulfilled状态
      resolve(result);
    });
  });
};
</code></pre>

<p>使用的时候, 如果我们不传递<code>callback</code>形参, 那么<code>cb</code>此时为<code>undefined</code>, 表明使用者需要的是<code>Promise</code>风格的接口, 反之则是需要CPS风格的接口</p>

<p>然而我个人认为这断代码存在问题, 在出现异常时不仅调用<code>cb(error)</code>传递异常, 还调用<code>reject(error)</code>将<code>Promise</code>置为<code>Reject</code>状态, 这样会导致使用者就算意图只使用<code>callback</code>风格的API时, 没对返回的<code>Promise</code>调用<code>promise.catch</code>捕抓错误的话就会引发Node告警<br/>
例如</p>

<pre><code class="language-js">asyncDivision(10, 0, (error, result) =&gt; {
  if (error) {
    return console.error(error);
  }
  console.log(result);
});
</code></pre>

<p>发生除零错误, 而且已经在<code>callback</code>中处理了错误, 但由于没有对返回的<code>Promise</code>进行错误捕抓, Node也会进行告警<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-30%20%E4%B8%8A%E5%8D%8811.23.19.png" alt="屏幕快照 2017-09-30 上午11.23.19"/><br/>
    这明显不是我们所需要的结果, 所以对函数改良一下</p>

<pre><code class="language-js">function asyncDivision(dividend, divisor, cb) {
  if (cb) {
    return process.nextTick(() =&gt; {
      const result = dividend / divisor;
      if (isNaN(result) || !Number.isFinite(result)) {
        const error = new Error(&#39;Invalid operands&#39;);
        return cb(error);
      }
      cb(null, result);
    })
  }
  return new Promise((resolve, reject) =&gt; {
    asyncDivision(dividend, divisor, (err, result) =&gt; {
      if (err)
        return reject(err)
      return resolve(result);
    })
  })
};
</code></pre>

<p>在传入了<code>callback</code>情况下无需返回一个<code>Promise</code>实例, 从而分离两种风格, 就不会导致Node对异常告警了</p>

<p><img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-30%20%E4%B8%8A%E5%8D%8811.40.27.png" alt="屏幕快照 2017-09-30 上午11.40.27"/></p>

<h2 id="toc_12">Generators</h2>

<blockquote>
<p>ES6中的生成器, 类似于Python中的生成器, 实现状态的暂存和通信</p>
</blockquote>

<p>生成器一般用于模拟协程, 或者用于无限长度的流</p>

<pre><code class="language-js">// ES6 中利用 function* 标识生成器函数
function* fruitGenerator() {
  // yield用于挂起生成器
  yield &#39;apple&#39;;
  yield &#39;orange&#39;;
  return &#39;watermelon&#39;;
}
</code></pre>

<p>使用生成器</p>

<pre><code class="language-js">// 实例化生成器
const newFruitGenerator = fruitGenerator();
// Generator.next用于 载入/恢复 生成器
console.log(newFruitGenerator.next());
console.log(newFruitGenerator.next());
console.log(newFruitGenerator.next());
</code></pre>

<p>运行结果<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-30%20%E4%B8%8B%E5%8D%8810.03.53.png" alt="屏幕快照 2017-09-30 下午10.03.53"/></p>

<p>当生成器函数返回时, 状态<code>Done</code> 为真.</p>

<h3 id="toc_13">Generators as iterators</h3>

<blockquote>
<p>遍历生成器</p>
</blockquote>

<p>利用<code>done</code>指示生成器遍历进度</p>

<pre><code class="language-js">function* iteratorGenerator(num) {
  for (let i = 0; i &lt;num; i++) {
    yield i;
  }
}

// 初始化生成器
const iterator = iteratorGenerator(3);

let currentItem = iterator.next();
// 遍历生成器
while (!currentItem.done) {
  console.log(currentItem.value);
  currentItem = iterator.next();
}
</code></pre>

<p>运行结果<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-01%20%E4%B8%8B%E5%8D%8812.17.14.png" alt="屏幕快照 2017-10-01 下午12.17.14"/></p>

<h3 id="toc_14">Passing values back to a generator</h3>

<blockquote>
<p>生成器的数据流是双向的, 不仅可以从生成器得到数据, 还可以向生成器发送数据</p>
</blockquote>

<pre><code class="language-js">&quot;use strict&quot;;

function* twoWayGenerator() {
  const what = yield null;
  console.log(&#39;Hello &#39; + what);
}

const twoWay = twoWayGenerator();
// 第一次 next() 返回 null
twoWay.next();
// 第二次 next() 将数据传递至 what, 并结束生成器
twoWay.next(&#39;world&#39;);
</code></pre>

<p>运行结果将会打印出<code>Hello world</code></p>

<h3 id="toc_15">Asynchronous control flow with generators</h3>

<blockquote>
<p>既然生成器能做到控制流的暂停和恢复, 那么用于模拟协程暂停与恢复就很容易了</p>
</blockquote>

<pre><code class="language-js">function asyncFlow(generatorFunction) {
  // 嵌套声明的 callback 函数
  function callback(err) {
    if (err) { 
      return generator.throw(err); 
    }
    // 通过 Functions.arguments 获取 callback 的形参
    // 剔除掉err, 也就是 callback 的结果
    const results = [].slice.call(arguments, 1);
    // 恢复协程, 并将结果返回至挂起点
    generator.next(results.length &gt; 1 ? results : results[0]); 
  }
  // 实例化深层器
  const generator = generatorFunction(callback);
  // 启动生成器
  generator.next(); 
}
</code></pre>

<p><code>asyncFlow</code>函数通过传入生成器函数, 并在<code>callback</code>中恢复和传递生成器的结果从而达到操作完成时恢复生成器的功能.</p>

<p>用例: 复制一个文件<br/>
<code>js<br/>
// 创建匿名生成器函数<br/>
asyncFlow(function* (callback) {<br/>
  const fileName = path.basename(__filename);<br/>
  // 替换callback<br/>
  const myself = yield fs.readFile(fileName, &#39;utf8&#39;, callback);<br/>
  yield fs.writeFile(`clone_of_${fileName}`, myself, callback);<br/>
  console.log(&#39;Clone created&#39;);<br/>
});<br/>
</code></p>

<h4 id="toc_16">JavaScript 中的 Chunk</h4>

<blockquote>
<p>JS中的Chunk其实是将典型的CPS函数<code>柯里化</code>成为只剩下<code>callback</code>参数的函数, 例如</p>

<pre><code class="language-js">function readFileChunk(filename, options) {
 return (callback) =&gt; {
  fs.readFile(filename, options, callback)
 }
}
</code></pre>

<p><code>readFileChunk</code>函数将<code>fs.readFile</code>柯里化成为仅接受<code>callback</code>的函数</p>
</blockquote>

<ul>
<li><p>Thunk的作用<br/>
注意到上面的<code>asyncFlow</code>函数, 传入的形参是带<code>callback</code>的生成器函数, 而在使用<code>yield</code>时, 仍需要往CPS风格函数传入<code>callback</code>, 这看起来并不简约, 于是出现了新的<code>asyncFlow</code>生成器控制函数及<code>Thunk</code>技术, 解决生成器函数风格问题.</p></li>
<li><p>基于<code>Chunk</code>的<code>asyncFlow</code></p></li>
</ul>

<pre><code class="language-js">function asyncFlowWithThunks(generatorFunction) {
  function callback(err) {
    if (err) {
      return generator.throw(err);
    }
    const results = [].slice.call(arguments, 1);
    const thunk = generator.next(results.length &gt; 1 ? results : results[0]).value;
    // 检查 Thunk 并且传入 callback
    thunk &amp;&amp; thunk(callback);
  }
  // 初始化生成器
  const generator = generatorFunction();
  // 生成器函数将会返回一个 Thunk
  const thunk = generator.next().value;
  // 检查 Thunk 并且传入 callback
  thunk &amp;&amp; thunk(callback);
}
</code></pre>

<ul>
<li>函数<code>Thunk</code>化</li>
</ul>

<pre><code class="language-js">const readFileThunk = (filename, options) =&gt; {
  return (cb) =&gt; {
    fs.readFile(filename, options, cb);
  }
};

const writeFileThunk = (filename, options) =&gt; {
  return (cb) =&gt; {
    fs.writeFile(filename, options, cb);
  }
};
</code></pre>

<p>使用示例</p>

<pre><code class="language-js">asyncFlowWithThunks(function* () {
  const fileName = path.basename(__filename);
  const myself = yield readFileThunk(fileName, &#39;utf8&#39;);
  yield writeFileThunk(`clone_of_${fileName}`, myself);
  console.log(&#39;Clone created&#39;);
});
</code></pre>

<p>如此一来, 整个生成器流控制函数就简练很多了.</p>

<h4 id="toc_17">thunkify</h4>

<p>就像之前的<code>promisify</code>一样, <code>thunkify</code>能方便将普通的CPS风格函数转换为<code>Thunk</code>风格函数, 方便应用到生成器中</p>

<pre><code class="language-js">function thunkify(fn) {
  assert(&#39;function&#39; == typeof fn, &#39;function required&#39;);

  return function () {
    let args = [].slice.call(arguments)
    let ctx = this;
    // 返回一个 Thunk 化后的函数
    // done 代表 callback 函数
    return function (done) {
      let called;
      // 在形参末尾推入 callback
      args.push(function () {
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });
      // 调用fn
      try {
        fn.apply(ctx, args);
      } catch (err) {
        done(err);
      }
    }
  }
}
</code></pre>

<h4 id="toc_18">Generator-based control flow using co</h4>

<p><code>co</code>是Node.js中一个控制异步流程的库, 支持</p>

<ul>
<li>Thunks</li>
<li>Promises</li>
<li>Arrays</li>
<li>Objects</li>
<li>Generators</li>
<li>Generator functions</li>
</ul>

<h4 id="toc_19">Sequential execution</h4>

<blockquote>
<p>利用<code>co</code>与<code>Thunk</code>技术实现串行执行</p>
</blockquote>

<p>同样是以<code>spider</code>为例</p>

<ul>
<li>首先利用<code>thunkify</code>将普通函数转化为<code>Thunk</code>风格</li>
</ul>

<pre><code class="language-js">const co = require(&#39;co&#39;);
const request = thunkify(require(&#39;request&#39;));
const fs = require(&#39;fs&#39;);
const mkdirp = thunkify(require(&#39;mkdirp&#39;));
const readFile = thunkify(fs.readFile);
const writeFile = thunkify(fs.writeFile);
const nextTick = thunkify(process.nextTick);
</code></pre>

<ul>
<li>利用生成器改造函数</li>
</ul>

<pre><code class="language-js">// 将 download 改造成生成器函数
function* download(url, filename) {
  console.log(&#39;Downloading &#39; + url);
  const response = yield request(url);
  const body = response[1];
  // 等待 mkdirp 完成
  yield mkdirp(path.dirname(filename));
  // 等待 writeFile 完成
  yield writeFile(filename, body);
  console.log(`Downloaded and saved: ${url}`);
  return body;
}

// 将 spider 改造成生成器函数
function* spider(url, nesting) {
  const filename = utilities.urlToFilename(url);
  let body;
  try {
    // readFile 已被 Thunk 化, 返回文件 body
    body = yield readFile(filename, &#39;utf8&#39;);
  } catch (err) {
    if (err.code !== &#39;ENOENT&#39;) {
      throw err;
    }
    body = yield download(url, filename);
  }
  yield spiderLinks(url, body, nesting);
}

// 以及 Sequential execution 最重要的
// 控制任务载入速度的 spiderLinks
function* spiderLinks(currentUrl, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getPageLinks(currentUrl, body);
  for (let i = 0; i &lt; links.length; i++) {
    yield spider(links[i], nesting - 1);
  }
}

</code></pre>

<ul>
<li>利用<code>co</code>库启动生成器</li>
</ul>

<pre><code class="language-js co(function*">  try {
    yield spider(process.argv[2], 1);
    console.log(&#39;Download complete&#39;);
  } catch (err) {
    console.log(err);
  }
});
</code></pre>

<h4 id="toc_20">Parallel execution</h4>

<ul>
<li> 利用<code>co</code>能并发载入生成器数组中元素的特性, 改造<code>spiderLinks</code>即可</li>
</ul>

<pre><code class="language-js">function* spiderLinks(currentUrl, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getPageLinks(currentUrl, body);
  // spide 函数返回一个生成器实例
  const tasks = links.map(link =&gt; spider(link, nesting - 1));
  // 返回一个生成器数组
  yield tasks;
}
</code></pre>

<h4 id="toc_21">Limited parallel execution</h4>

<ul>
<li>以<code>生产者-消费者</code>模式, 控制并发任务数</li>
</ul>

<pre><code class="language-js">class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.taskQueue = [];
    this.consumerQueue = [];
    // 创建 worker
    this.spawnWorkers(concurrency);
  }

  pushTask(task) {
    if (this.consumerQueue.length !== 0) {
      // 相当于 notify, 通知被挂起的生成器
      this.consumerQueue.shift()(null, task);
    } else {
      // 说明当前已达任务上限, 推入任务队列
      this.taskQueue.push(task);
    }
  }

  spawnWorkers(concurrency) {
    const self = this;
    for (let i = 0; i &lt; concurrency; i++) {
      co(function* () {
        while (true) {
          // worker获取下一个任务
          const task = yield self.nextTask();
          // 载入任务
          yield task;
        }
      });
    }
  }

  nextTask() {
    // nextTask 返回一个 Thunk, 这样 co 库才能载入这个生成器
    return callback =&gt; {
      // co 在获得这个 Thunk 函数后
      // 这个生成器被马上激活
      if (this.taskQueue.length !== 0) {
        // 如果任务队列中存在任务
        // 那么将它返回至生成器另一端
        return callback(null, this.taskQueue.shift());
      }
      // 如果任务队列为空
      // 那么挂起这个生成器, 直到 pushTask 被调用
      this.consumerQueue.push(callback);
    }
  }
}
</code></pre>

<p>利用<code>Generator</code>模拟的任务队列设计的非常巧妙, <code>this.consumerQueue</code>保存了<code>worker</code>生成器的状态, 用于在有新的任务时触发</p>

<h4 id="toc_22">Async await using Babel</h4>

<blockquote>
<p><code>async</code> 和 <code>await</code> 已经在<code>Node.js 8</code>中完全支持, 而不需要 Babel 了</p>
</blockquote>

<pre><code class="language-js">function getPageHtml(url) {
  return new Promise((resolve, reject) =&gt; {
    request(url, (error, response, body) =&gt; {
      resolve(body);
    });
  });
}

async function main() {
  const html = await getPageHtml(&#39;http://google.com&#39;);
  console.log(html);
}

main();
</code></pre>

<p><code>async</code>和<code>await</code>利用了原有的<code>Promise</code>, 并将传给<code>resolve</code>的值通过<code>await</code>返回, 传递给<code>reject</code>的值将会以异常的形式抛出, 通过<code>try...catch</code>捕获.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libco 源码阅读 · 系统调用钩子]]></title>
    <link href="zerolocusta.github.io/15061378949226.html"/>
    <updated>2017-09-23T11:38:14+08:00</updated>
    <id>zerolocusta.github.io/15061378949226.html</id>
    <content type="html"><![CDATA[
<p>libco中将常用的I/O调用都做了替换,为的是将现有的业务无痛切换到libco中.<br/>
由于替换掉的系统调用函数太多这里只选取<code>read</code><code>write</code>两个系统调用展示.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libco 源码阅读 · 事件循环调度器]]></title>
    <link href="zerolocusta.github.io/15058774867304.html"/>
    <updated>2017-09-20T11:18:06+08:00</updated>
    <id>zerolocusta.github.io/15058774867304.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>libco中, 将多路复用I/O配合事件循环与协程调度结合起来了</p>
</blockquote>

<h2 id="toc_0">1.1 <code>co_eventloop</code>, 启动事件循环</h2>

<p>libco中启动事件循环的函数是<code>co_eventloop</code>, 这个函数将epoll(bsd下是kqueue)和协程的调度策略结合起来<br/>
<code>co_eventloop</code>的签名</p>

<pre><code class="language-c">void co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg)
</code></pre>

<p>逐个分析<code>co_eventloop</code>的形参列表</p>

<ul>
<li> <code>stCoEpoll_t</code></li>
</ul>

<pre><code class="language-c++">struct stCoEpoll_t
{
    // epoll fd
    int iEpollFd;
    // epoll结果数组的大小
    static const int _EPOLL_SIZE = 1024 * 10;
    // 用于存放所有超时事件
    struct stTimeout_t *pTimeout;
   // 用于存放已经超时的事件
    struct stTimeoutItemLink_t *pstTimeoutList;
   // 用于存放已就绪事件
    struct stTimeoutItemLink_t *pstActiveList;
   // 用于存放epoll返回结果
    co_epoll_res *result;
};
</code></pre>

<ul>
<li><code>pfn_co_eventloop_t</code></li>
</ul>

<pre><code class="language-c">typedef int (*pfn_co_eventloop_t)(void *);
</code></pre>

<p><code>pfn_co_eventloop_t</code>会在每次循环末尾调用</p>

<ul>
<li><code>arg</code>
恰好是传递给<code>pfn</code>的参数</li>
</ul>

<h4 id="toc_1">1.1.1 libco中的超时处理</h4>

<p>libco的超时事件贯穿整个<code>co_eventloop</code>, 首先要了解这个重要的超时事件</p>

<p>与超时处理相关的结构体</p>

<pre><code class="language-c++">struct stTimeout_t;
struct stTimeoutItem_t;
struct stTimeoutItemLink_t
</code></pre>

<p>首先是<code>stTimeoutItemLink_t</code>, 保存了由<code>stTimeoutItem_t</code>组成的链表的头部和尾部</p>

<pre><code class="language-c++">struct stTimeoutItemLink_t
{
    stTimeoutItem_t *head;
    stTimeoutItem_t *tail;
};
</code></pre>

<p>而<code>stTimeoutItem_t</code>本身也是链表, 并且存储了更多信息</p>

<pre><code class="language-c++">struct stTimeoutItem_t
{
    enum
    {
        // 最大超时, 但代码中并没又发现有利用这个限制
        // 猜测是用于兼容旧版本
        eMaxTimeout = 40 * 1000 //40s
    };
    // 当当前时间点出现多个超时时间时
    // 利用链表结构存储
    stTimeoutItem_t *pPrev;
    stTimeoutItem_t *pNext;
    // 记录所在的链表
    stTimeoutItemLink_t *pLink;
    // 记录超时时间点
    unsigned long long ullExpireTime;
    // 超时事件处理前会调用这个函数
    OnPreparePfn_t pfnPrepare;
    // 超时事件处理函数
    OnProcessPfn_t pfnProcess;
    // 存放着某个协程, 根据不同的pfnProcess会有不同表现
    void *pArg; // routine
    // 标识此结构体是否用于超时事件
    bool bTimeout;
};
</code></pre>

<p>最后是<code>stTimeout_t</code>, 记录了所有<code>stTimeoutItem_t</code>的信息</p>

<pre><code class="language-c++">struct stTimeout_t
{
    // 超时事件链表数组
    stTimeoutItemLink_t *pItems;
    // stTimeoutItem_t总数
    int iItemSize;
    // 记录上次处理超时事件的事件
    unsigned long long ullStart;
    // 最后一个超时事件的索引
    long long llStartIdx;
};
</code></pre>

<p><code>stTimeout_t</code>和它相对应的函数<strong>组成</strong>超时事件处理的核心, 而<code>llStartIdx</code>非常重要, libco中利用这个偏移量重复利用<code>pItems</code>, 具体机制在下面会讲到.</p>

<h4 id="toc_2">1.1.2 <code>stTimeout_t</code>的相关函数</h4>

<p><code>stTimeout_t</code>有几个相关函数</p>

<pre><code class="language-c++">// 初始化
stTimeout_t *AllocTimeout(int)
// 析构
void FreeTimeout(stTimeout_t *)
// 添加超时事件
int AddTimeout(stTimeout_t *, stTimeoutItem_t *, unsigned long long)
// 获取所有超时事件
inline void TakeAllTimeout(stTimeout_t *, unsigned long long, stTimeoutItemLink_t *)
</code></pre>

<ul>
<li><code>AllocTimeout</code></li>
</ul>

<pre><code class="language-c++">stTimeout_t *AllocTimeout(int iSize)
{
    stTimeout_t *lp = (stTimeout_t *)calloc(1, sizeof(stTimeout_t));

    lp-&gt;iItemSize = iSize;
    // 形参中的iSize决定了链表的数量, 也就是说超时事件的数量是有限的
    lp-&gt;pItems = (stTimeoutItemLink_t *)calloc(1, sizeof(stTimeoutItemLink_t) * lp-&gt;iItemSize);
    // ullStart用于记录上次处理超时事件的事件, 此处需要初始化
    lp-&gt;ullStart = GetTickMS();
    lp-&gt;llStartIdx = 0;

    return lp;
}
</code></pre>

<p>在<code>stTimeout_t</code>初始化后, <code>pItems</code>中存储了<strong>链表数组</strong>, <strong>这点非常重要</strong>, 而<code>iItemSize</code>决定了超时事件的最大等待时间.</p>

<ul>
<li><code>FreeTimeout</code></li>
</ul>

<pre><code class="language-c++">void FreeTimeout(stTimeout_t *apTimeout)
{
    free(apTimeout-&gt;pItems);
    free(apTimeout);
}
</code></pre>

<ul>
<li><code>AddTimeout</code></li>
</ul>

<pre><code class="language-c++">int AddTimeout(stTimeout_t *apTimeout, stTimeoutItem_t *apItem, unsigned long long allNow)
{
    // 用于重新初始化stTimeout_t
    if (apTimeout-&gt;ullStart == 0)
    {
        apTimeout-&gt;ullStart = allNow;
        apTimeout-&gt;llStartIdx = 0;
    }
    // 如果传入的当前时间比开始时间还小, 明显发生了错误
    if (allNow &lt; apTimeout-&gt;ullStart)
    {
        co_log_err(&quot;CO_ERR: AddTimeout line %d allNow %llu apTimeout-&gt;ullStart %llu&quot;,
                   __LINE__, allNow, apTimeout-&gt;ullStart);

        return __LINE__;
    }
    // 如果超时时间点小于当前时间
    if (apItem-&gt;ullExpireTime &lt; allNow)
    {
        co_log_err(&quot;CO_ERR: AddTimeout line %d apItem-&gt;ullExpireTime %llu allNow %llu apTimeout-&gt;ullStart %llu&quot;,
                   __LINE__, apItem-&gt;ullExpireTime, allNow, apTimeout-&gt;ullStart);

        return __LINE__;
    }
    // 计算出超时时间点和开始时间的差值
    unsigned long long diff = apItem-&gt;ullExpireTime - apTimeout-&gt;ullStart;
    // 存储超时事件的链表大小是确定的, 
    // 而AddTimeout会根据diff来确定索引
    // 需要对超过链表大小的size的diff进行处理
    // 并放置到链表数组末尾的链表中
    if (diff &gt;= (unsigned long long)apTimeout-&gt;iItemSize)
    {
        diff = apTimeout-&gt;iItemSize - 1;
        co_log_err(&quot;CO_ERR: AddTimeout line %d diff %d&quot;,
                   __LINE__, diff);
    }
    // 添加到索引为 (apTimeout-&gt;llStartIdx + diff) % apTimeout-&gt;iItemSize 的链表中
    AddTail(apTimeout-&gt;pItems + (apTimeout-&gt;llStartIdx + diff) % apTimeout-&gt;iItemSize, apItem);

    return 0;
}
</code></pre>

<p><code>AddTimeout</code>中, 每一毫秒都有用一个超时事件的链表, 而在<code>stTimeout_t</code>中的链表数组大小在<code>AllocTimeout</code>时已经确定了, 而且在同一毫秒中也存在多个超时事件, 所以这里必然有冲突处理的机制, 具体体现在<code>AddTail</code>中</p>

<blockquote>
<p>一种可能的<code>stTimeout_t</code>结构<br/>
<img src="media/15058774867304/untitled.png" alt="untitled"/></p>
</blockquote>

<ul>
<li><code>TakeAllTimeout</code></li>
</ul>

<pre><code class="language-c++">inline void TakeAllTimeout(stTimeout_t *apTimeout, unsigned long long allNow, stTimeoutItemLink_t *apResult)
{
    // 用于重新初始化stTimeout_t
    if (apTimeout-&gt;ullStart == 0)
    {
        apTimeout-&gt;ullStart = allNow;
        apTimeout-&gt;llStartIdx = 0;
    }
    // 如果传入的当前时间比开始时间还小, 明显发生了错误
    if (allNow &lt; apTimeout-&gt;ullStart)
    {
        return;
    }
    // 计算当前时间离上次超时处理过了多久
    // 每一毫秒都有一个对应的用于存储超时事件的结构体
    int cnt = allNow - apTimeout-&gt;ullStart + 1;
    // 时间差超出了链表数组大小
    if (cnt &gt; apTimeout-&gt;iItemSize)
    {
        cnt = apTimeout-&gt;iItemSize;
    }
    if (cnt &lt; 0)
    {
        return;
    }
    for (int i = 0; i &lt; cnt; i++)
    {
        // 通过llStartIdx偏移量计算索引
        int idx = (apTimeout-&gt;llStartIdx + i) % apTimeout-&gt;iItemSize;
        // 将stTimeoutItemLink_t指向的链表
        // 移动到stTimeout_t中的pItems链表中
        // 并且重置stTimeoutItemLink_t
        Join&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(apResult, apTimeout-&gt;pItems + idx);
    }
    // 重新设置开始时间
    apTimeout-&gt;ullStart = allNow;
    // 重新设置偏移量, 供下次TakeTimeout使用
    apTimeout-&gt;llStartIdx += cnt - 1;
}
</code></pre>

<h4 id="toc_3">1.1.3 libco超时时间处理机制总结</h4>

<ol>
<li><code>llStartIdx</code>: 利用取余操作将<code>pItems</code>数组当作<strong>环状数组</strong>, 具体机制:
<img src="media/15058774867304/stTimeout_t.png" alt="stTimeout_t"/></li>
<li>虽然这种超时事件处理机制在<code>TakeAllTimeout</code>中需要遍历从上次<code>TakeAllTimeout</code>到当前时间所有的超时事件, 但在<code>co_eventloop</code>中, 限定了每次loop最长等待1ms, 考虑到时间精度, <code>TakeAllTimeout</code>遍历的链表并不多, 时间复杂度并不高.</li>
<li>当设定时间与开始时间(<code>diff</code>)超出<code>iItemSize</code>时, 事件会被放置到<code>pItems</code>利用<code>llStartIdx</code>偏移后的数组末尾, 造成堆积. 但是在调度器中做了处理, 无需担心超时事件被提前触发的问题.</li>
</ol>

<hr/>

<h3 id="toc_4">1.2 回到<code>co_eventloop</code></h3>

<p><code>co_eventloop</code>代码篇幅比较长, 分段分析.</p>

<ul>
<li>初始化部分</li>
</ul>

<pre><code class="language-c++">void co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg)
{
    // 检查用于存储epoll结果数组的结构体是否已创建
    if (!ctx-&gt;result)
    {
        // 创建epoll结果结构体
        ctx-&gt;result = co_epoll_res_alloc(stCoEpoll_t::_EPOLL_SIZE);
    }
    // 取出result指针, 方便后续使用
    co_epoll_res *result = ctx-&gt;result;
    ......
</code></pre>

<ul>
<li><code>epoll_wait</code>部分</li>
</ul>

<pre><code class="language-c++">   ......
    // 事件循环开始
    for (;;)
    {
        // 调用epoll, 并且最长等待时间设置为1ms
        // co_epoll_wait 在 *inx 系统下只是简单包装了下epoll_wait
        int ret = co_epoll_wait(ctx-&gt;iEpollFd, result, stCoEpoll_t::_EPOLL_SIZE, 1);
    ......
</code></pre>

<ul>
<li>查找出所有需要调度的事件</li>
</ul>

<pre><code class="language-c++">        // 获取active链表
        // active链表与libco提供的协程信号量机制有关
        stTimeoutItemLink_t *active = (ctx-&gt;pstActiveList);
        // 获取timeout链表, 用于在后续操作中存储超时事件
        stTimeoutItemLink_t *timeout = (ctx-&gt;pstTimeoutList);

        memset(timeout, 0, sizeof(stTimeoutItemLink_t));
        // 开始遍历epoll_wait返回的已就绪事件
        for (int i = 0; i &lt; ret; i++)
        {
            // 取出对应就绪事件的指针
            stTimeoutItem_t *item = (stTimeoutItem_t *)result-&gt;events[i].data.ptr;
            if (item-&gt;pfnPrepare)
            {
                // 如果存在pfnPrepare, 表明需要自定义的调度机制
                item-&gt;pfnPrepare(item, result-&gt;events[i], active);
            }
            else
            {
                // 否则直接添加到actice链表中
                AddTail(active, item);
            }
        }
        // 获取当前时间ms
        unsigned long long now = GetTickMS();
        // 取出所有已超时事件, 并添加到timeout链表中
        TakeAllTimeout(ctx-&gt;pTimeout, now, timeout);

        // 遍历已超时事件链表
        stTimeoutItem_t *lp = timeout-&gt;head;
        while (lp)
        {
            // 由于普通的事件和超时事件共用stTimeoutItem_t类型
            // 需要设置此标识以区分两种事件
            lp-&gt;bTimeout = true;
            lp = lp-&gt;pNext;
        }
        // 将timeout链表所有元素移动到active链表中
        Join&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(active, timeout);
</code></pre>

<ul>
<li>开始载入就绪事件</li>
</ul>

<pre><code class="language-c++">        // 获取链表头部
        lp = active-&gt;head;
        while (lp)
        {
            // 从active链表中删除头部元素
            PopHead&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(active);
            // 如果当前时间小于设定的超时事件, 说明此事件不应该触发
            // 出现这种情况是由于stTimeout_t中iItemSize限制了超时事件最大事件
            // 所有超时时间点超出iItemSize的都会放置到末尾元素中
            if (lp-&gt;bTimeout &amp;&amp; now &lt; lp-&gt;ullExpireTime)
            {
                // 重新将超时事件放回超时队列
                int ret = AddTimeout(ctx-&gt;pTimeout, lp, now);
                if (!ret)
                {
                    // 返回正常, 遍历下一个事件
                    lp-&gt;bTimeout = false;
                    lp = active-&gt;head;
                    continue;
                }
            }
            if (lp-&gt;pfnProcess)
            {
                // 调用就绪事件中的函数
                lp-&gt;pfnProcess(lp);
            }

            lp = active-&gt;head;
        }
</code></pre>

<ul>
<li>每次事件循环末尾调用自定义<code>pfn</code></li>
</ul>

<pre><code class="language-c++">        if (pfn)
        {
            if (-1 == pfn(arg))
            {
                break;
            }
        }
    } // 事件循环结束, 进入下一轮
}
</code></pre>

<hr/>

<h3 id="toc_5">1.3 libco中的信号量</h3>

<p>libco中提供了协程之间的信号量操作, 分别有</p>

<pre><code class="language-c++">stCoCond_t *co_cond_alloc();
int co_cond_free(stCoCond_t *cc);

int co_cond_signal(stCoCond_t *);
int co_cond_broadcast(stCoCond_t *);
int co_cond_timedwait(stCoCond_t *, int timeout_ms);
</code></pre>

<h4 id="toc_6">1.3.1 <code>stCoCond_t</code>结构相关</h4>

<ul>
<li><code>stCoCond_t</code>是一个链表</li>
</ul>

<pre><code class="language-c++">struct stCoCond_t
{
    stCoCondItem_t *head;
    stCoCondItem_t *tail;
};
</code></pre>

<ul>
<li> <code>stCoCondItem_t</code>结构体</li>
</ul>

<pre><code class="language-c++">struct stCoCondItem_t
{
    stCoCondItem_t *pPrev;
    stCoCondItem_t *pNext;
    stCoCond_t *pLink;
    // 调度器会将
    stTimeoutItem_t timeout;
};
</code></pre>

<p><code>pLink</code>存储着所有注册在当前<code>cond</code>上的事件</p>

<ul>
<li><code>co_cond_alloc</code>, 申请cond内存</li>
</ul>

<pre><code class="language-c++">stCoCond_t *co_cond_alloc()
{
    return (stCoCond_t *)calloc(1, sizeof(stCoCond_t));
}
</code></pre>

<ul>
<li><code>co_cond_free</code>, 析构<code>stCoCond_t</code></li>
</ul>

<pre><code class="language-c++">int co_cond_free(stCoCond_t *cc)
{
    free(cc);
    return 0;
}
</code></pre>

<ul>
<li><code>co_cond_pop</code>, 利用<code>stCoCond_t</code>链表模拟栈</li>
</ul>

<pre><code class="language-c++">stCoCondItem_t *co_cond_pop(stCoCond_t *link)
{
    // 取链表头部元素
    stCoCondItem_t *p = link-&gt;head;
    if (p)
    {
        // 删除链表头部元素
        PopHead&lt;stCoCondItem_t, stCoCond_t&gt;(link);
    }
    return p;
}
</code></pre>

<h4 id="toc_7">1.3.3 PV操作</h4>

<ul>
<li><code>co_cond_timedwait</code></li>
</ul>

<pre><code class="language-c++">int co_cond_timedwait(stCoCond_t *link, int ms)
{
    stCoCondItem_t *psi = (stCoCondItem_t *)calloc(1, sizeof(stCoCondItem_t));
    // 获取当前协程
    psi-&gt;timeout.pArg = GetCurrThreadCo();
    // 设置被调度时运行的函数
    psi-&gt;timeout.pfnProcess = OnSignalProcessEvent;

    if (ms &gt; 0)
    {
        // ms大于零时同时注册到超时队列中
        unsigned long long now = GetTickMS();
        psi-&gt;timeout.ullExpireTime = now + ms;
        // 获取当前线程的epoll, 并添加超时事件
        int ret = AddTimeout(co_get_curr_thread_env()-&gt;pEpoll-&gt;pTimeout, &amp;psi-&gt;timeout, now);
        if (ret != 0)
        {
            free(psi);
            return ret;
        }
    }
    // 在当前信号量注册事件
    AddTail(link, psi);
    // 挂起当前协程
    co_yield_ct();
    // 协程恢复后的清理
    RemoveFromLink&lt;stCoCondItem_t, stCoCond_t&gt;(psi);
    free(psi);

    return 0;
}
</code></pre>

<p>回想一下, 在调度器里恢复协程时, 会以<code>lp-&gt;pfnProcess(lp);</code>, 调用<code>pfnProcess</code>函数, 在协程调用<code>co_cond_timedwait</code>后, <code>pfnProcess</code>存储着<code>OnSignalProcessEvent</code>, <code>lp</code>指向<code>stTimeoutItem_t*</code>, 而这个<code>lp-&gt;pArg</code>存储着被挂起协程信息</p>

<ul>
<li><code>OnSignalProcessEvent</code></li>
</ul>

<pre><code>static void OnSignalProcessEvent(stTimeoutItem_t *ap)
{
    // 从stTimeoutItem_t.pArg中获取协程信息
    stCoRoutine_t *co = (stCoRoutine_t *)ap-&gt;pArg;
    // 恢复协程
    co_resume(co);
}
</code></pre>

<ul>
<li><code>co_cond_signal</code></li>
</ul>

<pre><code class="language-c++">int co_cond_signal(stCoCond_t *si)
{
    // 取出并删除栈顶元素
    stCoCondItem_t *sp = co_cond_pop(si);
    if (!sp)
    {
        return 0;
    }
    // 从stCoCondItem_t中的timeout删除当前元素
    RemoveFromLink&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(&amp;sp-&gt;timeout);
    // 将当前事件添加到调度器的active队列中, 等待调度
    AddTail(co_get_curr_thread_env()-&gt;pEpoll-&gt;pstActiveList, &amp;sp-&gt;timeout);

    return 0;
}
</code></pre>

<ul>
<li><code>co_cond_broadcast</code></li>
</ul>

<pre><code class="language-c++">int co_cond_broadcast(stCoCond_t *si)
{
    for (;;)
    {
        // 遍历当前条件变量链表
        stCoCondItem_t *sp = co_cond_pop(si);
        if (!sp)
            return 0;
        // 从stCoCondItem_t中的timeout删除当前元素
        RemoveFromLink&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(&amp;sp-&gt;timeout);
        // 将当前事件添加到调度器的active队列中, 等待调度
        AddTail(co_get_curr_thread_env()-&gt;pEpoll-&gt;pstActiveList, &amp;sp-&gt;timeout);
    }

    return 0;
}
</code></pre>

<h2 id="toc_8">未解问题</h2>

<p>本章只探讨了libco中协程的调度相关操作</p>

<ul>
<li>协程共享栈</li>
<li>系统钩子</li>
<li>闭包</li>
</ul>

<p>之后再探讨</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js设计模式 · 第三章]]></title>
    <link href="zerolocusta.github.io/15057240638063.html"/>
    <updated>2017-09-18T16:41:03+08:00</updated>
    <id>zerolocusta.github.io/15057240638063.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Asynchronous Control Flow Patterns with Callbacks</h2>

<blockquote>
<p>JavaScript著名的回调地狱  </p>
</blockquote>

<h2 id="toc_1">摘要</h2>

<ul>
<li>回调风格的JavaScript与一般顺序风格的区别</li>
<li>以回调风格写一个网络爬虫</li>
<li>回调风格的JavaScript需要注意的事项</li>
<li>async库</li>
</ul>

<hr/>

<h2 id="toc_2">写在前面</h2>

<p>这一章以网络爬虫代码以及他的各种不同风格变种为主, 代码量巨大.</p>

<hr/>

<h2 id="toc_3">The difficulties of asynchronous programming</h2>

<p>从顺序式编程转向以回调为主的异步CPS风格的确会有很多不适应的地方, 虽然在bluebird出现之后有了Promise, ES6之后引入的生成器和原生的Promise, ES7更是引入了async/await, 不过不少旧代码仍然是CPS风格, 而且就得浏览器也并不支持新的ES标准, 所以学习异步CPS风格还是很有必要的.</p>

<p>而异步CPS风格很容易引起问题, 例如</p>

<ul>
<li>callback的处理在另一个函数内部, 就像上一章中无法被捕获的错误一样, callback抛出的错误上浮到Eventloop层面</li>
<li>callback中又会用到很多的闭包, 不正确地使用闭包会引起内存泄漏</li>
<li>回调的嵌套很容易造成回调地狱, 到时候代码阅读起来异常困难</li>
</ul>

<hr/>

<h3 id="toc_4">Creating a simple web spider</h3>

<p>书里面以网络爬虫的代码示例阐释回调地狱的问题.<br/>
爬虫的功能: 输入一个URL, 然后将整个HTML下载到本地<br/>
同时这个爬虫还利用了两个开源库:</p>

<ul>
<li>request : 用于发起HTTP请求</li>
<li>mkdirp:   用于递归的创建文件及其文件夹
观察一下这个爬虫的核心源码:</li>
</ul>

<pre><code class="language-js">const request = require(&#39;request&#39;);
const fs = require(&#39;fs&#39;);
const mkdirp = require(&#39;mkdirp&#39;);
const path = require(&#39;path&#39;);
// utilities 是作者做的一个简单的库吗提供了一些简单的工具函数
const utilities = require(&#39;./utilities&#39;);

function spider(url, callback) {
    // 将 url 转换成 文件名
    // 例如, 会将 https://bangumi.bilibili.com/movie/ 
    // 转换成 bangumi.bilibili.com/movie.html 这样一个文件路径
    const filename = utilities.urlToFilename(url);
    // 首先检查文件是否存在, 也就是说这个url是否已经下载了
    fs.exists(filename, exists =&gt; {
        if (!exists) {
            // 如果不存在就开始下载这个url
            console.log(`Downloading ${url}`);
            // 发起HTTP请求
            request(url, (err, response, body) =&gt; {
                if (err) {
                    // Error Come First的方法处理错误
                    callback(err);
                } else {
                    // 创建文件
                    mkdirp(path.dirname(filename), err =&gt; {
                        if (err) {
                           //同样以Error Come First的方法处理错误
                            callback(err);
                        } else {
                            // 将Http Body写入文件
                            fs.writeFile(filename, body, err =&gt; {
                                if (err) {
                                    callback(err);
                                } else {
                                    // 回调 callback
                                    callback(null, filename, true);
                                }
                            });
                        }
                    });
                }
            });
        } else {
              // 如果文件已经存在. 直接回调callback
            callback(null, filename, false);
        }
    });
}


spider(process.argv[2], (err, filename, downloaded) =&gt; {
    if (err) {
        console.log(err);
    } else if (downloaded) {
        console.log(`Completed the download of &quot;${filename}&quot;`);
    } else {
        console.log(`&quot;${filename}&quot; was already downloaded`);
    }
});
</code></pre>

<p>以<code>node index.js https://bangumi.bilibili.com/movie/</code>命令调用这个spider, 输出的结果<br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-17%20%E4%B8%8A%E5%8D%8811.55.07.png" alt="屏幕快照 2017-09-17 上午11.55.07"/></p>

<hr/>

<h3 id="toc_5">The callback hell</h3>

<blockquote>
<p>JS回调地狱  </p>
</blockquote>

<p>从上面的代码里面看到, JS这种嵌套的回调很容易造成代码混乱, 即使是spider这种功能直白简单的代码, 也写成了多层回调的嵌套</p>

<p>回调地狱造成的问题:</p>

<ul>
<li>难以阅读,、追踪代码</li>
<li>重复的命名在嵌套的回调函数中不断出现, 例如err</li>
<li>滥用闭包容易导致内存泄漏</li>
</ul>

<hr/>

<h2 id="toc_6">Using plain JavaScript</h2>

<blockquote>
<p>在只使用JavaScript的特性时, 如何减少回调嵌套的深度</p>
</blockquote>

<p>在不使用第三方库的情况下, 有哪些方法去减少回调嵌套的深度和分支</p>

<h4 id="toc_7">对于单个callback的风格约束</h4>

<ol>
<li>在出现分支时候尽快跳出当前逻辑, 利用return,  continue 和 break.</li>
</ol>

<pre><code class="language-js">// 相比起
if(err)
    callback(err)
else
    callback(null, args...)

// 更倾向于使用
if(err)
    return callback(err)
callback(null, args...)
</code></pre>

<p>减少分支和代码量, 改善代码的可读性<br/>
2. 尽量使用具名函数代替匿名函数</p>

<p>书里利用上面的<code>spider</code>作为例子</p>

<pre><code>spider由三个部分组成:
    1. 查找本地是否已经存在url对应的文件
    2. 发起HTTP请求
    3. 创建并将请求保存为文件
</code></pre>

<ul>
<li>将<code>创建并将请求保存为文件</code>的功能抽离出来, 抽象成单个函数</li>
</ul>

<pre><code class="language-js">// spider中 创建并将请求保存为文件 的部分
mkdirp(path.dirname(filename),
    err =&gt; {
        if (err) {
            callback(err);
        } else {
            fs.writeFile(filename, body, err =&gt; {
                if (err) {
                    callback(err);
                } else {
                    callback(null, filename, true);
                }
            })
        }
    })

// 将它抽象成 saveFile 函数
function saveFile(filename, contents, callback) {
    mkdirp(path.dirname(filename), err =&gt; {
        if (err)
            return callback(err)
        fs.writeFile(filename, contents, callback)
    })
}
</code></pre>

<ul>
<li>将<code>发起HTTP请求</code>和<code>创建并将请求保存为文件</code>的部分抽象为单个函数</li>
</ul>

<pre><code class="language-js">// spider中 发起HTTP请求 和 创建并将请求保存为文件 的部分
request(url, (err, response, body) =&gt; {
    if (err) {
        // Error Come First的方法处理错误
        callback(err);
    } else {
        // 创建文件
        mkdirp(path.dirname(filename), err =&gt; {
            if (err) {
                // 同样以Error Come First的方法处理错误
                callback(err);
            } else {
                // 将Http Body写入文件
                fs.writeFile(filename, body, err =&gt; {
                    if (err) {
                        callback(err);
                    } else {
                        // 回调 callback
                        callback(null, filename, true);
                    }
                });
            }
        });
    }
});

// 抽象成download函数
function download(url, filename, callback) {
    console.log(`Downloading ${url}`)
    request(url, (err, response, body) =&gt; {
        if (err)
            return callback(err)
        saveFile(filename, body, (err) =&gt; {
            if (err)
                return callback(err)
            callback(null, filename, true)
        })
    })
}
</code></pre>

<ul>
<li>最后利用函数替换掉<code>spider</code>中的功能</li>
</ul>

<pre><code class="language-js">function spider(url, callback) {
    const filename = utilities.urlToFilename(url);
    fs.exists(filename, exists =&gt; {
        if (exists) {
            return callback(null, filename, false);
        }
        download(url, filename, err =&gt; {
            if (err) {
                return callback(err);
            }
            callback(null, filename, true);
        })
    });
}
</code></pre>

<p>完成修改的<code>spider</code>函数和之前由回调地狱组成的<code>spider</code>清晰许多, 而且分离出来的<code>savaFile</code>和<code>download</code>函数还可以复用.</p>

<hr/>

<h3 id="toc_8">Sequential execution</h3>

<blockquote>
<p>构建一个工具函数, 将多个函数以串行化的方式通过管道传递结果的方式执行<br/><br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-17%20%E4%B8%8B%E5%8D%887.05.30.png" alt="屏幕快照 2017-09-17 下午7.05.30"/></p>
</blockquote>

<h4 id="toc_9">Executing a known set of tasks in sequence</h4>

<p>要在CPS风格中实现类似于管道的方式处理多个任务, 要有一个用于流式处理任务的函数, 类似于</p>

<pre><code class="language-js">// 通过asyncOperation这样的中间函数
// 实现多个任务之间间的解离
function task1(callback) {
  asyncOperation(() =&gt; {
    task2(callback);
  });
}

function task2(callback) {
  asyncOperation(() =&gt; {
    task3(callback);
  });
}

function task3(callback) {
  asyncOperation(() =&gt; {
    callback();
  });
}

task1(() =&gt; {
  console.log(&#39;tasks 1, 2 and 3 executed&#39;);
});
</code></pre>

<p>上面这一段代码中的<code>asyncOperation</code>函数就是一个流式任务处理函数, 利用这种中间函数的意义是, 一个任务只需知道下一个任务, 实现了多个任务之间的解耦.</p>

<h4 id="toc_10">Web spider version 2</h4>

<p>仍然以spider的代码为蓝本进行修改, 新的<code>spider</code>实现了获取页面内所有的连接并下载的功能, 并且重新进行了功能切分<br/>
        1. spider函数用于下载url指向的页面<br/>
        2. spiderLinks函数用于获取当前页面内所有链接, 并再次调用spider</p>

<p>首先是新添加的<code>spiderLinks</code>函数</p>

<pre><code class="language-js">// spiderLinks函数用于查找当前页面所有连接并下载
// 参数列表中的 nesting 表示爬取的深度
function spiderLinks(currentUrl, body, nesting, callback) {
  if (nesting === 0) {
    // 如果爬去深度为0, 那么在下一tick调用callback
    return process.nextTick(callback);
  }
  // utilities.getPageLinks 的作用是获取页面内所有链接,并返回一个列表
  let links = utilities.getPageLinks(currentUrl, body);

  // spiderLinks 内部定义iterate函数, 用于遍历links列表
  function iterate(index) {
    if (index === links.length) {
      // links列表遍历完毕, 调用回调函数
      return callback();
    }
    // 调用 spider 函数爬取下一个链接的内容
    spider(links[index], nesting - 1, function (err) {
      if (err) {
        return callback(err);
      }
      // 方位links列表下一个url
      iterate(index + 1);
    });
  }
  // 初始调用, 访问links列表第一个元素
  iterate(0);
}
</code></pre>

<p><code>saveFile</code>方法没有变化,  <code>download</code>方法发生了变化</p>

<pre><code class="language-js">function download(url, filename, callback) {
  console.log(`Downloading ${url}`);
  request(url, (err, response, body) =&gt; {
    if (err) {
      return callback(err);
    }
    saveFile(filename, body, err =&gt; {
      if (err) {
        return callback(err);
      }
      console.log(`Downloaded and saved: ${url}`);
      // 由于需要查找出body中的链接, 
      // 下载完成后传递给callback的形参修改成了body
      callback(null, body);
    });
  });
}
</code></pre>

<p><code>spider</code>函数</p>

<pre><code class="language-js">function spider(url, nesting, callback) {
  const filename = utilities.urlToFilename(url);
  // 由于需要从 body 中查找a标签
  // 所以从fs.exists 改成 fs.readFile
  fs.readFile(filename, &#39;utf8&#39;, function (err, body) {
    if (err) {
      // 如果网页未下载的本地
      if (err.code !== &#39;ENOENT&#39;) {
        return callback(err);
      }
      // 此处的return只是为了减少一个else
      return download(url, filename, function (err, body) {
        if (err) {
          return callback(err);
        }
        // 调用 spiderLinks 查找页面内链接并下载
        spiderLinks(url, body, nesting, callback);
      });
    }
    // 已经下载url对应的文件, 直接调用 spiderLinks
    spiderLinks(url, body, nesting, callback);
  });
}

spider(process.argv[2], 1, (err) =&gt; {
  if (err) {
    console.log(err);
    process.exit();
  } else {
    console.log(&#39;Download complete&#39;);
  }
});
</code></pre>

<p>最后是运行结果:<br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-18%20%E4%B8%8B%E5%8D%8812.29.07.png" alt="屏幕快照 2017-09-18 下午12.29.07"/></p>

<pre><code>其实是以参数中的url为节点, 展开广度优先搜索
个人觉得这个模式用在`spider`上面没有感觉代码更清晰易读, 反而`spiderLinks`和`spider`耦合更严重了, 不太认同书中的做法..
</code></pre>

<h4 id="toc_11">Sequential execution 风格总结</h4>

<p>串行执行分割的核心模式抽离出来, 其实是<code>iterator</code>函数, 为了达到串行执行的目的, 没有用<code>forEach</code>等关键字遍历任务列表(for..遍历无法令异步函数串行),  取而代之的是<code>iterator</code>函数</p>

<pre><code class="language-js">function iterate(index) {
  if (index === tasks.length) {
    return finish();
  }
  const task = tasks[index];
  task(function () {
    iterate(index + 1);
  });
}

function finish() {
  //iteration completed
}

iterate(0);
</code></pre>

<hr/>

<h3 id="toc_12">Parallel execution</h3>

<blockquote>
<p>对于不要求执行顺序的任务, 并行执行是最好的<br/><br/>
    并发执行图示:<br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-18%20%E4%B8%8B%E5%8D%883.10.01.png" alt="屏幕快照 2017-09-18 下午3.10.01"/><br/>
吐槽 -&gt; (然而JS除非开子进程, 不然做不到并行, 只能并发)</p>
</blockquote>

<p>在I/O密集型的应用中, 并发还是能最大限度模拟并行效果的<br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-18%20%E4%B8%8B%E5%8D%884.58.09.png" alt="屏幕快照 2017-09-18 下午4.58.09"/></p>

<blockquote>
<p>在上图中, I/O密集型的Task依赖于EventLoop同时发起多个I/O, 以并发的形式模拟并行I/</p>
</blockquote>

<h4 id="toc_13">Web spider version 3</h4>

<p>同样以<code>spider</code>函数为基础进行修改<br/>
首先, <code>saveFile</code>和<code>download</code>两个函数都没有修改.</p>

<p>而<code>spiderLinks</code>进行了大幅度修改</p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting, callback) {
  // 同样是以nesting表示 爬取页面的深度
  if(nesting === 0) {
    // 已达到爬取深度, 不再爬取页面
    return process.nextTick(callback);
  }
  // 获取当前页面内所有链接
  const links = utilities.getPageLinks(currentUrl, body);  //[1]
  if(links.length === 0) {
    // 当前页面没有其他链接
    return process.nextTick(callback);
  }
  // completed 用于标示所有并行任务是否完成
  let completed = 0, hasErrors = false;

  // done 函数 在任务中执行, 一旦任务执行完毕就调用done
  // 从而记录任务的完成数量
  function done(err) {
    if(err) {
      // 其中一个任务出现错误立刻调用callback
      hasErrors = true;
      return callback(err);
    }
    if(++completed === links.length &amp;&amp; !hasErrors) {
      // 在所有任务完成并且没有错误的情况下
      return callback();
    }
  }
  // 遍历links列表, 同时触发多个spider任务
  links.forEach(function(link) {
    spider(link, nesting - 1, done);
  });
}
</code></pre>

<p><code>spider</code>的修改</p>

<pre><code class="language-js">// 在并行的模式下, 需要用spidering标识链接是否正在下载
// 否则会出现同时重复下载的情况
let spidering = new Map();

function spider(url, nesting, callback) {
  if(spidering.has(url)) {
    // 如果当前url已经在爬取或爬取过了, 那么直接返回
    // 这个处理方式存在问题
    return process.nextTick(callback);
  }
  // 标识当前url正在下载
  spidering.set(url, true);
  // 以下功能与 Web spider version 2 的一样
  const filename = utilities.urlToFilename(url);
  fs.readFile(filename, &#39;utf8&#39;, function(err, body) {
    if(err) {
      if(err.code !== &#39;ENOENT&#39;) {
        return callback(err);
      }

      return download(url, filename, function(err, body) {
        if(err) {
          return callback(err);
        }
        spiderLinks(url, body, nesting, callback);
      });
    }

    spiderLinks(url, body, nesting, callback);
  });
}

spider(process.argv[2], 1, (err) =&gt; {
  if(err) {
    console.log(err);
    process.exit();
  } else {
    console.log(&#39;Download complete&#39;);
  }
});
</code></pre>

<p>运行结果:<br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-18%20%E4%B8%8B%E5%8D%889.46.12.png" alt="屏幕快照 2017-09-18 下午9.46.12"/><br/>
其实书里的这段代码存在问题, 在<code>spider</code>函数里, 处理重复爬取的链接时可能会导致程序提前结束</p>

<pre><code class="language-js">  if(spidering.has(url)) {
    // 如果当前url已经在爬取或爬取过了, 那么直接返回
    // 这个处理方式存在问题
    // 加入当前链接重复而且恰好是最后一个任务
    // 有可能在当前链接未完成爬取时提前结束程序
    return process.nextTick(callback);
  }
</code></pre>

<h4 id="toc_14">Parallel execution 风格总结</h4>

<p>以<code>forEach</code>遍历任务列表并同时启动多个任务, 添加一个<code>completed</code>标识用于标识所有任务是否完成</p>

<pre><code class="language-js">const tasks = [ /* ... */ ];
let completed = 0;
tasks.forEach(task =&gt; {
  task(() =&gt; {
    if (++completed === tasks.length) {
      finish();
    }
  });
});

function finish() {
  //all the tasks completed
}
</code></pre>

<h4 id="toc_15">Fixing race conditions with concurrent tasks</h4>

<p>在其他语言中, 多线程+阻塞任务是一种普遍的并发模型, 而在Node.js中, 单协程+异步任务+多路复用I/O也能用于模拟并发, 而并发就有可能导致静态条件的出现<br/>
而并发风格的<code>spider</code>中就存在这个竞态条件</p>

<pre><code class="language-js">function spider(url, nesting, callback) {
  const filename = utilities.urlToFilename(url);
  // 问题出现在fs.readFile这里
  fs.readFile(filename, &#39;utf8&#39;, (err, body) =&gt; {
        if (err) {
          if (err.code !== &#39;ENOENT&#39;) {
            return callback(err);
          }
          return download(url, filename, function (err, body) {
          //...
</code></pre>

<p>在<code>fs.readFile</code>中传递给他的回调函数是在文件读取完成之后执行的, 而这期间有可能有一个相同文件名的url传入spider, 也就是说同一个url有可能导致重复下载.<br/>
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-19%20%E4%B8%8A%E5%8D%8811.06.59.png" alt="屏幕快照 2017-09-19 上午11.06.59"/><br/>
解决办法: 添加用于记录当前url是否已经爬取的<code>spidering</code>Map</p>

<pre><code class="language-js">const spidering = new Map();

function spider(url, nesting, callback) {
  if (spidering.has(url)) {
    return process.nextTick(callback);
  }
  spidering.set(url, true); 
  //...
</code></pre>

<p>修改之后的代码就是<code>Web Spider Version 3</code>了</p>

<h4 id="toc_16">Limited parallel execution</h4>

<blockquote>
<p>无限制的并行执行会导致资源快速消耗, 最后资源耗尽导致程序终止, 限制并发数显然是必须的.</p>
</blockquote>

<p>限制并发数但又能最大化利用并发的好处</p>

<ul>
<li>运行尽可能多的任务, 但设置一个同时运行任务书的上限</li>
<li>每当一个任务运行完马上运行另一个被挂起的任务
<img src="media/15057240638063/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-19%20%E4%B8%8B%E5%8D%882.48.40.png" alt="屏幕快照 2017-09-19 下午2.48.40"/>
遵循这两条规则, 对<code>spider</code>进行修改</li>
</ul>

<pre><code class="language-js">// 任务队列
const tasks = [...];

let
  // 设置最大并发数为2
  concurrency = 2,
  // 记录当前正在运行的任务数量
  running = 0,
  // 记录当前已完成的任务数量
  completed = 0,
  // 记录当前任务列表下标
  index = 0;

// next 函数起到了迭代器的作用
function next() {
  // while 循环限制并发数
  while (running &lt; concurrency &amp;&amp; index &lt; tasks.length) {
    // 从任务队列获取新的任务
    task = tasks[index++];
    // task 是一个以callback为形参的函数
    task(() =&gt; {
      if (completed === tasks.length) {
        return finish();
      }
      // 当前任务完成时, 减少running计数器以让出并发资源
      completed++, running--;
      next();
    });
    // 当前任务开始时, 增加running计数器以限制并发数
    running++;
  }
}
next();

function finish() {
  //all tasks finished
}
</code></pre>

<p>修改过的<code>spider</code>融合了<code>Sequential execution</code>和<code>Paraller execution</code>两种风格, <code>next()</code>函数充当了<code>Sequential execution</code>中<code>iterator</code>的作用, 而<code>next()</code>函数中运行多个任务由融入了<code>Paraller execution</code>的风格.</p>

<h4 id="toc_17">Queues to the rescue</h4>

<blockquote>
<p>最常用的限制并发数的方法还是任务队列</p>
</blockquote>

<p>将<code>Limited parallel execution</code>中的函数抽离出来, 抽象成<code>TaskQueue</code></p>

<pre><code class="language-js">class TaskQueue {
  // 构造是传入最大并发数
  constructor(concurrency) {
    this.concurrency = concurrency;
    // 记录当前正在运行的任务数
    this.running = 0;
    // 任务队列
    this.queue = [];
  }

  pushTask(task) {
    // 添加新的任务
    this.queue.push(task);
    // 调用新的任务
    // 相当于平常任务队列中的notifyAll操作
    this.next();
  }
  // next函数无太大变化
  next() {
    while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {
      const task = this.queue.shift();
      task(() =&gt; {
        this.running--;
        this.next();
      });
      this.running++;
    }
  }
};
</code></pre>

<p>与平时的任务队列不用, 这个任务列表不仅用于存放任务, 任务的执行也由它负责</p>

<h4 id="toc_18">Web spider version 4</h4>

<p>利用<code>TaskQueue</code>修改<code>spider</code></p>

<pre><code class="language-js">// 限制最大并发数为2
const downloadQueue = new TaskQueue(2);

function spiderLinks(currentUrl, body, nesting, callback) {
  if (nesting === 0) {
    return process.nextTick(callback);
  }
  const links = utilities.getPageLinks(currentUrl, body);
  if (links.length === 0) {
    return process.nextTick(callback);
  }
  let completed = 0,
    hasErrors = false;
  // 遍历链接列表
  links.forEach(link =&gt; {
    // 往任务队列中添加新任务
    downloadQueue.pushTask(done =&gt; {
      spider(link, nesting - 1, err =&gt; {
        if (err) {
          hasErrors = true;
          return callback(err);
        }
        if (++completed === links.length &amp;&amp; !hasErrors) {
          callback();
        }
        done();
      });
    });
  });
}
</code></pre>

<p><code>spider</code>任务将由<code>downloadQueue</code>执行</p>

<hr/>

<h2 id="toc_19">The async library</h2>

<blockquote>
<p><a href="https://www.npmjs.com/package/async">async</a>是一个非常著名的用于处理异步风格的库</p>
</blockquote>

<h3 id="toc_20">利用<code>async</code>库对<code>Sequential execution</code>风格进行改造</h3>

<p><code>Web spider version 2</code>是网络爬虫的<code>Sequential execution</code>版本, 以此为基础利用<code>async</code>对它进行修改<br/>
在<code>async</code>库中, <code>async.series</code>是用于串行执行函数的, 具体签名为<br/>
<code>async.series(tasks, [callback])</code></p>

<ul>
<li><code>tasks</code>表示任务列表, 存放着多个函数, <code>tasks</code>中存放的是签名为<code>function (callback) {}</code>的函数,</li>
<li><code>callback</code>会作为形参传递给<code>tasks</code>中最后一个函数.</li>
</ul>

<p>利用<code>async.series</code>改造<code>download</code>函数</p>

<pre><code class="language-js">function download(url, filename, callback) {
  console.log(`Downloading ${url}`);
  // 声明body变量, 用于在多个task间传递结果
  let body;
  async.series([
    // 第一个函数, 发出请求
    callback =&gt; {   
      request(url, (err, response, resBody) =&gt; {
        if (err) {
          return callback(err);
        }
        body = resBody;
        callback();
      });
    },
    // 第二个函数, 创建目录, 并将mkdirp柯里化
    mkdirp.bind(null, path.dirname(filename)), //[2]    
    // 第三个函数, 将请求写入文件
    callback =&gt; { //[3]       
      fs.writeFile(filename, body, callback);
    }
  ], 
  // async.series 形参中的callback
  err =&gt; { //[4]
    if (err) {
      return callback(err);
    }
    console.log(`Downloaded and saved: ${url}`);
    callback(null, body);
  });
}
</code></pre>

<h4 id="toc_21">Sequential iteration</h4>

<p><code>Sequential execution</code>中, 典型的模式是利用<code>iterator</code>函数控制任务的遍历时间点<br/>
在<code>async</code>库中, <code>async.eachSeries(coll, iteratee, [callback])</code>能做同样的事情</p>

<ul>
<li><code>coll</code>, 需要遍历的集合</li>
<li><code>iteratee</code>, 处理集合中元素的函数</li>
<li><code>callback</code>, 在<code>coll</code>遍历完毕时调用</li>
</ul>

<p>修改<code>spiderLinks</code></p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting, callback) {
  if (nesting === 0) {
    return process.nextTick(callback);
  }
  const links = utilities.getPageLinks(currentUrl, body);
  if (links.length === 0) {
    return process.nextTick(callback);
  }
  async.eachSeries(links, (link, callback) =&gt; {
    spider(link, nesting - 1, callback);
  }, callback);
}
</code></pre>

<hr/>

<h3 id="toc_22">利用<code>async</code>库对<code>Parallel execution</code>风格进行改造</h3>

<p>这里的改造非常简单, 只需要将上面的<code>spiderLinks</code>中的<code>async.eachSeries</code>改为<code>async.each</code>就可以了</p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting, callback) { 
  // ...  
  async.each(links, (link, callback) =&gt; {
    spider(link, nesting - 1, callback);
  }, callback);
}
</code></pre>

<p>但是这里也并没有对并发任务数进行限制, 不过<code>async</code>也提供了和<code>TaskQueue</code>相似的工具<br/>
<code>async.queue(worker, concurrency)</code></p>

<ul>
<li><code>worker</code>是签名为<code>function worker(task, callback)</code>的函数</li>
<li><code>concurrency</code> 设置并发数上限</li>
<li><code>async.queue</code>函数返回一个任务队列实例</li>
</ul>

<p>根据<code>async.queue</code>的<a href="https://caolan.github.io/async/docs.html#queue">文档</a>, 函数会返回一个<code>QueueObject</code>, 我们主要用到他的<code>push</code>方法</p>

<ul>
<li><code>push(task, [callback])</code> 

<ul>
<li><code>task</code> : 传递给<code>worker</code>函数的形参</li>
<li><code>callback</code>: 同样是传递给<code>worker</code>函数的形参</li>
</ul></li>
</ul>

<h4 id="toc_23">利用<code>async.queue</code>修改<code>Web Spider Version 4</code></h4>

<pre><code class="language-js">const downloadQueue = async.queue( function(taskData, callback) {
  spider(taskData.link, taskData.nesting - 1, callback);
}, 2);

function spiderLinks(currentUrl, body, nesting, callback) {
  if (nesting === 0) {
    return process.nextTick(callback);
  }
  const links = utilities.getPageLinks(currentUrl, body);
  if (links.length === 0) {
    return process.nextTick(callback);
  }
  const completed = 0,
    hasErrors = false;
  links.forEach(function (link) {
    // 构造taskData
    // 由于async.queue在构造时设置好了worker函数
    // 无法以闭包方式传递link和nesting
    // 需要包装至object中传递
    const taskData = {
      link: link,
      nesting: nesting
    };
    // 往队列中推入数据和callback
    downloadQueue.push(taskData, err =&gt; {
      if (err) {
        hasErrors = true;
        return callback(err);
      }
      if (++completed === links.length &amp;&amp; !hasErrors) {
        callback();
      }
    });
  });
}
</code></pre>

<hr/>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libco 协程实现探索]]></title>
    <link href="zerolocusta.github.io/15057205491515.html"/>
    <updated>2017-09-18T15:42:29+08:00</updated>
    <id>zerolocusta.github.io/15057205491515.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">0. 源码蓝图</h1>

<h2 id="toc_1">0.1 功能假设</h2>

<pre><code>读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设
</code></pre>

<ul>
<li>libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间</li>
<li>在做协程上下文转换时, 会利用汇编对当前逻辑进行保存, 然后将控制权让渡给主协程调度器, 由调度器决定下一个运行的协程</li>
<li>保存协程上下文需要额外的栈, 但是libco的介绍里说了它利用了共享栈去保存协程状态
根据以上假设, 找出了几个相对应的文件和函数</li>
<li>epoll与调度器
<code>co_routine.h</code> 中</li>
</ul>

<pre><code class="language-c">// 用于运行协程的主调度循环
void co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg)
</code></pre>

<pre><code class="language-c">// 用于创建协程
int co_create(stCoRoutine_t **co, const stCoRoutineAttr_t *attr, void *(*routine)(void *), void *arg);
</code></pre>

<pre><code class="language-c">// 用于载入协程
void co_resume(stCoRoutine_t *co)
</code></pre>

<pre><code class="language-c">// 挂起协程相关操作
void co_yield_ct()
void co_yield_env(stCoRoutineEnv_t *env)
void co_yield(stCoRoutine_t *co)
</code></pre>

<hr/>

<h2 id="toc_2">0.2 简单尝试</h2>

<p>API那么多, 眼花缭乱了, 先找几个最简单的, 尝试一下他的效果吧</p>

<pre><code class="language-c">// 新建协程的API
int co_create(stCoRoutine_t **co, const stCoRoutineAttr_t *attr, void *(*routine)(void *), void *arg);

// 挂起当前协程的API
void co_yield_ct()

// 恢复被挂起协程的API
void co_resume(stCoRoutine_t *co)
</code></pre>

<p>利用这三个协程的创建, 挂起, 恢复, 简单地观察一下libco的协程运行状况.</p>

<h3 id="toc_3">0.2.1 简单的写一个测试的demo</h3>

<pre><code class="language-c">#include &quot;co_routine.h&quot;
#include &lt;stdio.h&gt;

void *foo(void *args)
{
    printf(&quot;[foo] Before Yield ①\n&quot;);
    co_yield_ct();
    printf(&quot;[foo] After  Yield ②\n&quot;);
    return NULL;
}

void *bar(void *args)
{
    printf(&quot;[bar] Before Yield ③\n&quot;);
    co_yield_ct();
    printf(&quot;[bar] After  Yield ④\n&quot;);
    return NULL;
}


int main(int argc, char *argv[])
{
    stCoRoutine_t *foo_co = NULL;
    stCoRoutine_t *bar_co = NULL;
    // 创建foo_co协程, 并且使用foo函数作为其入口函数
    co_create(&amp;foo_co, NULL, foo, 0);
    // 创建bar_co协程, 并且使用bar函数作为其入口函数
    co_create(&amp;bar_co, NULL, bar, 0);
    // 初次载入 foo_co 协程
    co_resume(foo_co);
    // 初次载入 bar_co 协程
    co_resume(bar_co);
    // 再次载入 foo_co 协程
    co_resume(foo_co);
    // 再次载入 bar_co 协程
    co_resume(bar_co);
}
</code></pre>

<p>运行结果<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.00.40.png" alt="屏幕快照 2017-09-14 下午9.00.40"/><br/>
    符合我们对协程的预期和理解, 接下来应该深入<code>co_create</code>, <code>co_resume</code> 和 <code>co_yield_ct()</code>去理解libco究竟如何实现这个过程了.</p>

<hr/>

<h2 id="toc_4">0.3 跟踪<code>co_create</code></h2>

<h3 id="toc_5">0.3.1 <code>co_create</code>函数本体</h3>

<pre><code class="language-c">int co_create(stCoRoutine_t **ppco, const stCoRoutineAttr_t *attr, pfn_co_routine_t pfn, void *arg)
{
    // 尝试获取当前线程的 全局协程运行环境
    if (!co_get_curr_thread_env())
    {
        // 如果当前线程的 全局协程运行环境 未初始化,
        // 那么初始化它
        co_init_curr_thread_env();
    }
    // 这里的 co_create_env 
    // 要理解为 根据pfn入口函数, 
    // 创建 协程私有的运行环境 , 
    // 要和上面的 全局运行环境 分开
    stCoRoutine_t *co = co_create_env(co_get_curr_thread_env(), attr, pfn, arg);
    *ppco = co;
    return 0;
}
</code></pre>

<p>根据<code>co_create</code>的源码, 发现</p>

<ul>
<li>libco每个线程都有一个全局协程运行环境</li>
<li>每个协程也有自己的私有运行环境(类似于上下文)</li>
</ul>

<hr/>

<h3 id="toc_6">0.3.1 <code>co_get_curr_thread_env()</code>函数本体</h3>

<p>先看看这个 <code>当前线程的协程全局运行环境(curr_thread_env)</code> 是什么吧</p>

<pre><code class="language-c">stCoRoutineEnv_t *co_get_curr_thread_env()
{
    return g_arrCoEnvPerThread[GetPid()];
}
</code></pre>

<p><code>co_get_curr_thread_env()</code>根据不同的当前 线程/进程  id, 去获取相应的<code>stCoRoutineEnv_t</code><br/>
    <code>g_arrCoEnvPerThread</code>数组长这样</p>

<pre><code class="language-c">static stCoRoutineEnv_t *g_arrCoEnvPerThread[204800] = {0};
</code></pre>

<hr/>

<h3 id="toc_7">0.3.2 <code>stCoRoutineEnv_t</code>结构体</h3>

<p>这个协程环境存了什么呢? <br/>
简单的看一下<code>stCoRoutineEnv_t</code>结构体</p>

<pre><code class="language-c">struct stCoRoutineEnv_t
{
  // 协程的调用栈 (resume/yield 栈) 
    stCoRoutine_t *pCallStack[128];
  // 协程调用栈的大小
    int iCallStackSize;
  // 当前线程使用的 epoll
    stCoEpoll_t *pEpoll;

    // for copy stack log lastco and nextco
  // 共享栈, 目前无视这个概念, 留到后面再深究
    stCoRoutine_t *pending_co;
    stCoRoutine_t *occupy_co;
};
</code></pre>

<p>目前看起来还是云里雾里, 因为这个<code>stCoRoutineEnv_t</code>需要和<code>co_resume</code> 和 <code>co_yield_ct()</code> 结合起来理解, 先放一边吧</p>

<hr/>

<h3 id="toc_8">0.3.3 <code>co_init_curr_thread_env()</code>函数本体</h3>

<p><code>co_create</code>下一个函数就是<code>co_init_curr_thread_env()</code></p>

<pre><code class="language-c"> void co_init_curr_thread_env()
{
    // 获取当前 线程/进程 id
    pid_t pid = GetPid();

    // 在堆中建立 stCoRoutineEnv_t 结构体
    // 将指针存入 g_arrCoEnvPerThread 相应的位置中
    g_arrCoEnvPerThread[pid] = (stCoRoutineEnv_t *)calloc(1, sizeof(stCoRoutineEnv_t));
    stCoRoutineEnv_t *env = g_arrCoEnvPerThread[pid];

    // 初始化调用栈大小
    env-&gt;iCallStackSize = 0;

    // 创建一个self协程, self协程并没有入口函数!
    struct stCoRoutine_t *self = co_create_env(env, NULL, NULL, NULL);
    // 设置self协程为当前线程的主协程
    self-&gt;cIsMain = 1;

    // 共享栈相关
    env-&gt;pending_co = NULL;
    env-&gt;occupy_co = NULL;

    // 初始化self协程的上下文
    coctx_init(&amp;self-&gt;ctx);

    // 将self协程置入 pCallStack 协程调用栈的栈底
    env-&gt;pCallStack[env-&gt;iCallStackSize++] = self;

    // 暂时无视epoll
    stCoEpoll_t *ev = AllocEpoll();
    SetEpoll(env, ev);›
}
</code></pre>

<p><code>co_init_curr_thread_env()</code>中有几个关键点</p>

<ul>
<li><code>stCoRoutine_t</code>结构体</li>
<li><code>self</code>主协程</li>
<li><code>pCallStack</code> 协程调用栈</li>
</ul>

<p><code>stCoRoutine_t</code>结构体 和 <code>self</code>主协程延后关注, 先看看当前<code>pCallStack</code>的样子<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.58.18.png" alt="屏幕快照 2017-09-14 下午9.58.18"/></p>

<ul>
<li><code>self</code>协程被置入<code>pCallStack</code>的底部</li>
</ul>

<hr/>

<h3 id="toc_9">0.3.4 <code>stCoRoutine_t</code>结构体</h3>

<p><code>stCoRoutine_t</code>是用于描述和记录<strong>一个协程</strong>上下文的结构体</p>

<pre><code class="language-c">struct stCoRoutine_t
{
    stCoRoutineEnv_t *env;  // 记录协程所在的当前线程全局环境
    pfn_co_routine_t pfn;   // 当前协程运行的入口函数
    void *arg;      // 传递给入口函数的形参
    coctx_t ctx;    // 保存着当前协程的寄存器状态
    char cStart;    // 记录当前协程是否已经开始执行
    char cEnd;      // 记录当前协程是否已经结束执行
    char cIsMain;   // 记录当前协程是否为主协程
    char cEnableSysHook; // 记录当前协程是否开启系统API钩子
    char cIsShareStack;  // 记录当前协程是否开启共享栈
    // 系统API钩子相关, 本节无视之
    void *pvEnv;

    stStackMem_t* stack_mem;// 记录当前协程存放栈数据的内存地址

    // 以下均为共享栈相关, 本节无视之
    char* stack_sp; 
    unsigned int save_size;
    char* save_buffer;
    stCoSpec_t aSpec[1024];
};
</code></pre>

<p>需要关注<code>coctx_t</code>和<code>stStackMem_t</code>这个结构体, 因为 恢复/保存(resume/yield) 协程的运行状态就靠他了.</p>

<hr/>

<h3 id="toc_10">0.3.5 <code>coctx_t</code> 和 <code>stStackMem_t</code></h3>

<p>仔细观察 <em>章节0.2 简单尝试</em> <em>中, 在<code>main</code>函数中通过<code>co_resume</code>载入<code>foo_co</code>, 并且调用<code>foo</code>函数, 而在<code>foo</code>函数中, 通过<code>co_yield_ct</code>回到<code>main</code>函数中, 而后在</em><em>再次调用</em>*<code>foo</code>函数的时候, 又能回到上一次调用<code>co_yield_ct</code>的地方, 并继续执行直到函数返回.</p>

<p>在那段代码里, <code>main</code>函数没有直接调用<code>foo</code>, 而在<code>foo</code>中也没有直接调用<code>main</code>, 但是却能通过<code>co_resume</code>和<code>co_yield_ct</code>来回调用</p>

<p>这里的魔法: <strong>利用汇编, 保存被挂起协程的运行现场, 然后恢复别的协程的运行现场</strong></p>

<ul>
<li>运行现场, 其实更确切的说法是, 协程被挂起前 CPU寄存器 和 内存中栈 的状态.
而<code>coctx_t</code>就是记录着协程被挂起前 CPU寄存器状态 的结构了.
至于协程被挂起前 内存中栈的状态, 当然记录在<code>stack_mem</code>里
要把 寄存器状态、内存中栈的状态 和协程运行状态的关系说清楚, 要理解 <em>处理器中的寄存器(libco里仅支持x86及amd64)</em> 还有 <em>X86调用约定</em> , 以及 <em>操作系统如何载入程序、分配内存并运行的</em>.</li>
</ul>

<p><u>即使libco同时支持x86和amd64架构, 但是为了简化文章, 这里只探讨x86架构</u></p>

<hr/>

<h4 id="toc_11">0.3.5.1 x86处理器中的寄存器</h4>

<p>这里只关注主要用到的几个<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%8811.56.26.png" alt="屏幕快照 2017-09-14 下午11.56.26"/><br/>
x86主要用到这几个寄存器</p>

<hr/>

<h4 id="toc_12">0.3.5.2 x86调用协定</h4>

<p>根据维基百科上的<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl">X86调用约定</a>, 在c语言中发生函数调用时, 调用者会操作寄存器和内存, 保存函数调用前状态, 然后跳转到被调函数的地址</p>

<p>这里有三个很重要的寄存器</p>

<ul>
<li>esp:  栈指针, 用于存放当前栈的位置</li>
<li>ebp: 基栈指针, 用于存放当前函数栈帧的开始位置</li>
<li>eip: 存放着下一条指令的地址, CPU会自动读取eip并载入取下一条指令</li>
</ul>

<p>参考维基百科上<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl">X86调用约定</a>给出的实例, 存在这样的c语言代码</p>

<pre><code class="language-c"> int callee(int, int, int);
 int caller(void)
 {
     register int ret;
     
     ret = callee(1, 2, 3);
     ret += 5;
     return ret;
 }
</code></pre>

<p>编译后产生这样的代码<br/>
(0 - 9是我添加的, 用于简单标识出地址, 实际编译不会产生)</p>

<pre><code>       .globl  caller
 caller:
0       pushl   %ebp            # 记录调用caller函数的栈帧
1       movl    %esp, %ebp   # 构造caller栈帧
2       pushl   $3           # 逆序将callee函数入栈
3       pushl   $2
4       pushl   $1
5       call    callee       # 调用callee函数
6       addl    $12,%esp     # 缩减栈大小
7       addl    $5,%eax      # 将callee返回值+ 5
8       leave                   # 清理栈帧
9       ret                 # 返回至调用者
</code></pre>

<p>操作符简释:</p>

<ul>
<li><code>pushl [操作数]</code>: <code>push long</code>, 将操作数中的值推入栈中, 并将栈指针增加4字节的大小.</li>
<li><code>movl [a] [b]</code>:  <code>move long</code>, 将 a 中的4字节值复制到 b 中</li>
<li><code>call [函数地址]</code>: 将eip中的值推入栈中, 并跳转到函数地址</li>
<li><code>addl [a] [b]</code>: 相当于<code>b = a + b</code></li>
<li><code>leave</code>: 清空当前函数调用栈帧</li>
<li><code>ret</code>: 从栈顶取得eip地址, 返回至该地址</li>
</ul>

<p>可视化这个函数调用</p>

<ol>
<li><p><code>call callee</code>前<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.56.12.png" alt="屏幕快照 2017-09-15 上午8.56.12"/></p></li>
<li><p><code>call callee时</code><br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.54.09.png" alt="屏幕快照 2017-09-15 上午8.54.09"/></p></li>
<li><p><code>call callee后 - leave前</code><br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.52.19.png" alt="屏幕快照 2017-09-15 上午8.52.19"/><br/>
函数调用就是操纵CPU寄存器和内存栈, 有了这样的概念, 那么我们在协程切换时, 直接利用<strong>汇编</strong>操纵寄存器和栈就好啦.</p></li>
</ol>

<hr/>

<h4 id="toc_13">0.3.5.3 操作系统如何载入程序、分配内存并运行的</h4>

<p>寄存器的问题解决了, 但是栈的问题还没解决</p>

<p>操作系统在载入程序时, 会给一个线程分配<strong>一个</strong>固定大小的栈, 而在libco中, 一个线程里有多个协程</p>

<p>先来看看所有协程都使用操作系统分配的一个栈会怎样</p>

<p>仍然利用上面的<em>章节0.2 简单尝试</em>中实例代码展示<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.25.52.png" alt="屏幕快照 2017-09-15 上午9.25.52"/></p>

<p>如果只有一个栈,  在<code>co_yield_ct</code>时, <code>foo_co</code>的栈帧被抹去, 可是这时<code>foo_co</code>还没执行完啊, 抹去了<code>foo_co</code>栈帧, 那么就没办法恢复<code>foo_co</code>被挂起前状态了.</p>

<p>所以, 必须要有一个地方存放协程的栈帧, 可以申请堆内存去存放协程的栈帧<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.37.52.png" alt="屏幕快照 2017-09-15 上午9.37.52"/></p>

<p>利用汇编, 将esp和ebp指向我们申请的堆内存就好了, 这样程序运行的时候从esp和ebp取得的就是堆内存中的地址</p>

<hr/>

<h3 id="toc_14">0.3.6 <code>coctx_t</code>结构体</h3>

<pre><code class="language-c">struct coctx_t
{
#if defined(__i386__)
    void *regs[ 8 ];
#else
    void *regs[ 14 ];
#endif
  // 栈大小
    size_t ss_size;
  // 栈指针
    char *ss_sp;
};

//----- --------
// 32 bit
// | regs[0]: ret |
// | regs[1]: ebx |
// | regs[2]: ecx |
// | regs[3]: edx |
// | regs[4]: edi |
// | regs[5]: esi |
// | regs[6]: ebp |
// | regs[7]: eax |
</code></pre>

<p>只关注x86架构下, <code>coctx_t</code>存放了8个CPU寄存器的值, 就是 <em>0.3.5.1 x86处理器中的寄存器</em> 那张图里的8个, 堆中协程栈的大小和起始位置</p>

<hr/>

<h3 id="toc_15">0.3.7 <code>coctx_t</code>结构体的相关操作</h3>

<h4 id="toc_16">0.3.7.1 <code>coctx_init</code>函数, 初始化<code>coctx_t</code>结构体</h4>

<p><code>coctx_init</code>源码</p>

<pre><code class="language-c">int coctx_init( coctx_t *ctx )
{
    memset( ctx,0,sizeof(*ctx));
    return 0;
}
</code></pre>

<hr/>

<h4 id="toc_17">0.3.7.1 <code>coctx_make</code>函数, 准备协程入口</h4>

<p><code>coctx_make</code>源码</p>

<pre><code class="language-c">enum
{
    kEIP = 0,
    kESP = 7,
};

int coctx_make(coctx_t *ctx, coctx_pfn_t pfn, const void *s, const void *s1)
{
    //make room for coctx_param
    char *sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(coctx_param_t);
  // 清空sp末位, (-16L == 0xfffffff0), 为了内存对齐
    sp = (char *)((unsigned long)sp &amp; -16L);

    coctx_param_t *param = (coctx_param_t *)sp;
    param-&gt;s1 = s;
    param-&gt;s2 = s1;

    memset(ctx-&gt;regs, 0, sizeof(ctx-&gt;regs));

    // sizeof(void*)是给pfn的形参预留的位置
    ctx-&gt;regs[kESP] = (char *)(sp) - sizeof(void *);
    ctx-&gt;regs[kEIP] = (char *)pfn;

    return 0;
}
</code></pre>

<p>调用<code>coctx_make</code>后, 堆中协程栈和<code>coctx_t</code>结构体状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.05.19.png" alt="屏幕快照 2017-09-15 下午4.05.19"/></p>

<hr/>

<h3 id="toc_18">0.3.8 跟踪<code>co_create_env</code></h3>

<p><code>co_create_env</code>用于申请协程结构体<code>stCoRoutine_t</code>的内存及协程栈的内存</p>

<pre><code class="language-c">struct stCoRoutine_t *co_create_env(stCoRoutineEnv_t *env, const stCoRoutineAttr_t *attr, pfn_co_routine_t pfn, void *arg)
{

    stCoRoutineAttr_t at;
    if (attr)
    {
        // 复制 stCoRoutineAttr_t 至 at 中
        memcpy(&amp;at, attr, sizeof(at));
    }
    if (at.stack_size &lt;= 0)
    {
        at.stack_size = 128 * 1024;
    }
    else if (at.stack_size &gt; 1024 * 1024 * 8)
    {
        at.stack_size = 1024 * 1024 * 8;
    }

    if (at.stack_size &amp; 0xFFF)
    {
        at.stack_size &amp;= ~0xFFF;
        at.stack_size += 0x1000;
    }

    stCoRoutine_t *lp = (stCoRoutine_t *) malloc( sizeof( stCoRoutine_t ));

    memset(lp, 0, (long)(sizeof(stCoRoutine_t)));

    lp-&gt;env = env;
    lp-&gt;pfn = pfn;
    lp-&gt;arg = arg;

    stStackMem_t *stack_mem = NULL;
    if (at.share_stack)
    {
        // 共享栈, 本章不关注
        stack_mem = co_get_stackmem(at.share_stack);
        at.stack_size = at.share_stack-&gt;stack_size;
    }
    else
    {
        // 为协程申请运行栈
        stack_mem = co_alloc_stackmem(at.stack_size);
    }
    // 以下均为初始化协程信息
    lp-&gt;stack_mem = stack_mem;

    lp-&gt;ctx.ss_sp = stack_mem-&gt;stack_buffer;
    lp-&gt;ctx.ss_size = at.stack_size;

    lp-&gt;cStart = 0;
    lp-&gt;cEnd = 0;
    lp-&gt;cIsMain = 0;
    lp-&gt;cEnableSysHook = 0;
    lp-&gt;cIsShareStack = at.share_stack != NULL;

    lp-&gt;save_size = 0;
    lp-&gt;save_buffer = NULL;

    return lp;
}
</code></pre>

<hr/>

<h2 id="toc_19">0.4 跟踪<code>co_resume</code></h2>

<p>协程的栈, 存放寄存器<code>coctx_t</code>结构体准备好了, 接下来是调用<code>co_resume</code>载入协程了.</p>

<pre><code class="language-c">void co_resume(stCoRoutine_t *co)
{
  // 获取协程全局环境
    stCoRoutineEnv_t *env = co-&gt;env;
  // 获取上一个协程
    stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[env-&gt;iCallStackSize - 1];
  // 检查协程是否已经执行过
    if (!co-&gt;cStart)
    {
        // 创建协程入口, coctx_make在上面讨论过
        // 注意这里 CoRoutineFunc
        coctx_make(&amp;co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, 0);
        co-&gt;cStart = 1;
    }
  // 增加 pCallStack 协程调用栈, 并设置为 co
    env-&gt;pCallStack[env-&gt;iCallStackSize++] = co;
  // 保存当前协程现场, 切换到 co 协程现场
    co_swap(lpCurrRoutine, co);
}
</code></pre>

<hr/>

<h3 id="toc_20">0.4.1 <code>CoRoutineFunc</code>协程入口函数</h3>

<p>在<code>co_resume</code>的<code>coctx_make</code>中, 并没有直接将需要运行的函数直接传递给<code>coctx_make</code>, 而是将另一个函数<code>CoRoutineFunc</code>和<code>co</code>传给它, 先看<code>CoRoutineFunc</code>的源码</p>

<pre><code class="language-c">// 我认为 void * 是为了兼容历史遗留的API
static int CoRoutineFunc(stCoRoutine_t *co, void *)
{
    if (co-&gt;pfn)
    {
        // 在此调用需要运行在协程中的函数
        co-&gt;pfn(co-&gt;arg);
    }
    // 将协程运行完成的标识置为1
    co-&gt;cEnd = 1;

    stCoRoutineEnv_t *env = co-&gt;env;
    // 直接跳到上一个协程, co_yield_env 后面会讨论, 无需返回
    co_yield_env(env);
    // return 0 不该发生, 否则引发 SIGSEGV
  // 因为没有构造返回地址
    return 0;
}
</code></pre>

<p>再看在调用<code>coctx_make(&amp;co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, 0);</code>后,   堆中协程栈和<code>coctx_t</code>结构体状态.<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.17.00.png" alt="屏幕快照 2017-09-15 下午4.17.00"/></p>

<hr/>

<h3 id="toc_21">0.4.2 回到<code>co_resume</code></h3>

<p>同样以<em>章节0.2 简单尝试</em>中实例代码为例, 标上行号</p>

<pre><code class="language-c">1  int main(int argc, char *argv[])
2  {
3     stCoRoutine_t *foo_co = NULL;
4     stCoRoutine_t *bar_co = NULL;
5     // 创建foo_co协程, 并且使用foo函数作为其入口函数
6     co_create(&amp;foo_co, NULL, foo, 0);
7     // 创建bar_co协程, 并且使用bar函数作为其入口函数
8     co_create(&amp;bar_co, NULL, bar, 0);
9     // 初次载入 foo_co 协程
10    co_resume(foo_co);
11    // 初次载入 bar_co 协程
12    co_resume(bar_co);
13    // 再次载入 foo_co 协程
14    co_resume(foo_co);
15    // 再次载入 bar_co 协程
16    co_resume(bar_co);
17  }
</code></pre>

<ol>
<li><p>在第10行初次载入<code>foo_co</code>之前, <code>env-&gt;pCallStack</code>的状态,<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png" alt="屏幕快照 2017-09-15 下午12.18.14"/></p></li>
<li><p>调用<code>co_resume</code>增加pCallStack栈大小之后的状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png" alt="屏幕快照 2017-09-15 下午12.16.52 1"/></p></li>
</ol>

<hr/>

<h3 id="toc_22">0.4.3 <code>co_swap</code>函数, 切换协程</h3>

<p><code>co_swap</code>是一个用汇编实现的方法</p>

<ul>
<li>它的签名</li>
</ul>

<pre><code class="language-c">extern void coctx_swap(coctx_t *, coctx_t *) asm(&quot;coctx_swap&quot;)
</code></pre>

<ul>
<li>它的实现</li>
</ul>

<pre><code>    leal 4(%esp), %eax //sp 
    movl 4(%esp), %esp 
    leal 32(%esp), %esp //parm a : &amp;regs[7] + sizeof(void*)

    pushl %eax //esp -&gt;parm a 

    pushl %ebp
    pushl %esi
    pushl %edi
    pushl %edx
    pushl %ecx
    pushl %ebx
    pushl -4(%eax)

    
    movl 4(%eax), %esp //parm b -&gt; &amp;regs[0]

    popl %eax  //ret func addr
    popl %ebx  
    popl %ecx
    popl %edx
    popl %edi
    popl %esi
    popl %ebp

    popl %esp
    pushl %eax //set ret func addr

    xorl %eax, %eax
    ret
</code></pre>

<p>对于<em>章节0.2 简单尝试</em>中初次<code>co_resume(foo_co)</code>中的<code>co_swap</code>来说, 可视化后的图</p>

<ol>
<li><p>保存<code>self</code>现场<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.23.57.png" alt="屏幕快照 2017-09-15 下午12.23.57"/></p></li>
<li><p>恢复<code>foo_co</code>现场<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%885.13.05.png" alt="屏幕快照 2017-09-15 下午5.13.05"/></p></li>
<li><p>CPU会自动从eip寄存器去下一条指令地址, 即此时载入<code>CoRoutineFunc</code>函数, 而<code>CoRoutineFunc</code>载入的协程<code>co</code>中记录的<code>foo</code>函数</p>

<hr/></li>
</ol>

<h2 id="toc_23">0.5 跟踪<code>co_yield_ct</code></h2>

<p>创建、载入协程都说完了, 然后就是挂起协程的<code>co_yield_ct</code>了吧</p>

<pre><code class="language-c">
void co_yield_ct()
{
    co_yield_env(co_get_curr_thread_env());
}

void co_yield_env(stCoRoutineEnv_t *env)
{
    // pCallStack 调用栈中, 调用co_resume(当前协程)的协程
    stCoRoutine_t *last = \
        env-&gt;pCallStack[env-&gt;iCallStackSize - 2];
    // 栈顶部的协程, 也就是当前协程
    stCoRoutine_t *curr = \
        env-&gt;pCallStack[env-&gt;iCallStackSize - 1];
    // 栈大小减1, 栈顶元素出栈
    env-&gt;iCallStackSize--;
    // 切换至 上一个协程
    co_swap(curr, last);
}
</code></pre>

<p>同样以<em>章节0.2 简单尝试</em>中实例代码为例</p>

<pre><code class="language-c">void *foo(void *args)
{
    printf(&quot;[foo] Before Yield ①\n&quot;);
    co_yield_ct();
    printf(&quot;[foo] After  Yield ②\n&quot;);
    return NULL;
}
</code></pre>

<ol>
<li><p><code>foo</code>函数在调用<code>co_yield_ct</code>前, pCallStack的状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png" alt="屏幕快照 2017-09-15 下午12.16.52 1"/></p></li>
<li><p>在调用<code>co_yield_ct</code>后, pCallStack的状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png" alt="屏幕快照 2017-09-15 下午12.18.14"/></p></li>
<li><p>然后调用<code>co_swap</code>回到<code>self</code>协程中保存的现场, 继续执行.</p>

<hr/>

<h2 id="toc_24">未解问题</h2>

<p>本章只探讨了libco中协程的基本操作, libco还有更多特性</p></li>
</ol>

<ul>
<li>协程共享栈</li>
<li>co_eventloop</li>
<li>系统钩子</li>
<li>闭包</li>
</ul>

<p>之后再探讨</p>

]]></content>
  </entry>
  
</feed>

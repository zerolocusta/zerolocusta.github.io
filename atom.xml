<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zerolocust]]></title>
  <link href="zerolocusta.github.io/atom.xml" rel="self"/>
  <link href="zerolocusta.github.io/"/>
  <updated>2017-09-22T09:05:57+08:00</updated>
  <id>zerolocusta.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[libco 源码阅读 · 事件循环调度器]]></title>
    <link href="zerolocusta.github.io/15058774867304.html"/>
    <updated>2017-09-20T11:18:06+08:00</updated>
    <id>zerolocusta.github.io/15058774867304.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>libco中, 将多路复用I/O配合事件循环与协程调度结合起来了</p>
</blockquote>

<h2 id="toc_0">1.1 <code>co_eventloop</code>, 启动事件循环</h2>

<p>libco中启动事件循环的函数是<code>co_eventloop</code>, 这个函数将epoll(bsd下是kqueue)和协程的调度策略结合起来<br/>
<code>co_eventloop</code>的签名</p>

<pre><code class="language-c">void co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg)
</code></pre>

<p>逐个分析<code>co_eventloop</code>的形参列表</p>

<ul>
<li> <code>stCoEpoll_t</code></li>
</ul>

<pre><code class="language-c++">struct stCoEpoll_t
{
    // epoll fd
    int iEpollFd;
    // epoll结果数组的大小
    static const int _EPOLL_SIZE = 1024 * 10;
    // 用于存放所有超时事件
    struct stTimeout_t *pTimeout;
   // 用于存放已经超时的事件
    struct stTimeoutItemLink_t *pstTimeoutList;
   // 用于存放已就绪事件
    struct stTimeoutItemLink_t *pstActiveList;
   // 用于存放epoll返回结果
    co_epoll_res *result;
};
</code></pre>

<ul>
<li><code>pfn_co_eventloop_t</code></li>
</ul>

<pre><code class="language-c">typedef int (*pfn_co_eventloop_t)(void *);
</code></pre>

<p><code>pfn_co_eventloop_t</code>会在每次循环末尾调用</p>

<ul>
<li><code>arg</code>
恰好是传递给<code>pfn</code>的参数</li>
</ul>

<h4 id="toc_1">1.1.1 libco中的超时处理</h4>

<p>libco的超时事件贯穿整个<code>co_eventloop</code>, 首先要了解这个重要的超时事件</p>

<p>与超时处理相关的结构体</p>

<pre><code class="language-c++">struct stTimeout_t;
struct stTimeoutItem_t;
struct stTimeoutItemLink_t
</code></pre>

<p>首先是<code>stTimeoutItemLink_t</code>, 保存了由<code>stTimeoutItem_t</code>组成的链表的头部和尾部</p>

<pre><code class="language-c++">struct stTimeoutItemLink_t
{
    stTimeoutItem_t *head;
    stTimeoutItem_t *tail;
};
</code></pre>

<p>而<code>stTimeoutItem_t</code>本身也是链表, 并且存储了更多信息</p>

<pre><code class="language-c++">struct stTimeoutItem_t
{
    enum
    {
        // 最大超时, 但代码中并没又发现有利用这个限制
        // 猜测是用于兼容旧版本
        eMaxTimeout = 40 * 1000 //40s
    };
    // 当当前时间点出现多个超时时间时
    // 利用链表结构存储
    stTimeoutItem_t *pPrev;
    stTimeoutItem_t *pNext;
    // 记录所在的链表
    stTimeoutItemLink_t *pLink;
    // 记录超时时间点
    unsigned long long ullExpireTime;
    // 超时事件处理前会调用这个函数
    OnPreparePfn_t pfnPrepare;
    // 超时事件处理函数
    OnProcessPfn_t pfnProcess;
    // 存放着某个协程, 根据不同的pfnProcess会有不同表现
    void *pArg; // routine
    // 标识此结构体是否用于超时事件
    bool bTimeout;
};
</code></pre>

<p>最后是<code>stTimeout_t</code>, 记录了所有<code>stTimeoutItem_t</code>的信息</p>

<pre><code class="language-c++">struct stTimeout_t
{
    // 超时事件链表数组
    stTimeoutItemLink_t *pItems;
    // stTimeoutItem_t总数
    int iItemSize;
    // 记录上次处理超时事件的事件
    unsigned long long ullStart;
    // 最后一个超时事件的索引
    long long llStartIdx;
};
</code></pre>

<p><code>stTimeout_t</code>和它相对应的函数<strong>组成</strong>超时事件处理的核心, 而<code>llStartIdx</code>非常重要, libco中利用这个偏移量重复利用<code>pItems</code>, 具体机制在下面会讲到.</p>

<h4 id="toc_2">1.1.2 <code>stTimeout_t</code>的相关函数</h4>

<p><code>stTimeout_t</code>有几个相关函数</p>

<pre><code class="language-c++">// 初始化
stTimeout_t *AllocTimeout(int)
// 析构
void FreeTimeout(stTimeout_t *)
// 添加超时事件
int AddTimeout(stTimeout_t *, stTimeoutItem_t *, unsigned long long)
// 获取所有超时事件
inline void TakeAllTimeout(stTimeout_t *, unsigned long long, stTimeoutItemLink_t *)
</code></pre>

<ul>
<li><code>AllocTimeout</code></li>
</ul>

<pre><code class="language-c++">stTimeout_t *AllocTimeout(int iSize)
{
    stTimeout_t *lp = (stTimeout_t *)calloc(1, sizeof(stTimeout_t));

    lp-&gt;iItemSize = iSize;
    // 形参中的iSize决定了链表的数量, 也就是说超时事件的数量是有限的
    lp-&gt;pItems = (stTimeoutItemLink_t *)calloc(1, sizeof(stTimeoutItemLink_t) * lp-&gt;iItemSize);
    // ullStart用于记录上次处理超时事件的事件, 此处需要初始化
    lp-&gt;ullStart = GetTickMS();
    lp-&gt;llStartIdx = 0;

    return lp;
}
</code></pre>

<p>在<code>stTimeout_t</code>初始化后, <code>pItems</code>中存储了<strong>链表数组</strong>, <strong>这点非常重要</strong>, 而<code>iItemSize</code>决定了超时事件的最大等待时间.</p>

<ul>
<li><code>FreeTimeout</code></li>
</ul>

<pre><code class="language-c++">void FreeTimeout(stTimeout_t *apTimeout)
{
    free(apTimeout-&gt;pItems);
    free(apTimeout);
}
</code></pre>

<ul>
<li><code>AddTimeout</code></li>
</ul>

<pre><code class="language-c++">int AddTimeout(stTimeout_t *apTimeout, stTimeoutItem_t *apItem, unsigned long long allNow)
{
    // 用于重新初始化stTimeout_t
    if (apTimeout-&gt;ullStart == 0)
    {
        apTimeout-&gt;ullStart = allNow;
        apTimeout-&gt;llStartIdx = 0;
    }
    // 如果传入的当前时间比开始时间还小, 明显发生了错误
    if (allNow &lt; apTimeout-&gt;ullStart)
    {
        co_log_err(&quot;CO_ERR: AddTimeout line %d allNow %llu apTimeout-&gt;ullStart %llu&quot;,
                   __LINE__, allNow, apTimeout-&gt;ullStart);

        return __LINE__;
    }
    // 如果超时时间点小于当前时间
    if (apItem-&gt;ullExpireTime &lt; allNow)
    {
        co_log_err(&quot;CO_ERR: AddTimeout line %d apItem-&gt;ullExpireTime %llu allNow %llu apTimeout-&gt;ullStart %llu&quot;,
                   __LINE__, apItem-&gt;ullExpireTime, allNow, apTimeout-&gt;ullStart);

        return __LINE__;
    }
    // 计算出超时时间点和开始时间的差值
    unsigned long long diff = apItem-&gt;ullExpireTime - apTimeout-&gt;ullStart;
    // 存储超时事件的链表大小是确定的, 
    // 而AddTimeout会根据diff来确定索引
    // 需要对超过链表大小的size的diff进行处理
    // 并放置到链表数组末尾的链表中
    if (diff &gt;= (unsigned long long)apTimeout-&gt;iItemSize)
    {
        diff = apTimeout-&gt;iItemSize - 1;
        co_log_err(&quot;CO_ERR: AddTimeout line %d diff %d&quot;,
                   __LINE__, diff);
    }
    // 添加到索引为 (apTimeout-&gt;llStartIdx + diff) % apTimeout-&gt;iItemSize 的链表中
    AddTail(apTimeout-&gt;pItems + (apTimeout-&gt;llStartIdx + diff) % apTimeout-&gt;iItemSize, apItem);

    return 0;
}
</code></pre>

<p><code>AddTimeout</code>中, 每一毫秒都有用一个超时事件的链表, 而在<code>stTimeout_t</code>中的链表数组大小在<code>AllocTimeout</code>时已经确定了, 而且在同一毫秒中也存在多个超时事件, 所以这里必然有冲突处理的机制, 具体体现在<code>AddTail</code>中</p>

<blockquote>
<p>一种可能的<code>stTimeout_t</code>结构<br/>
<img src="media/15058774867304/untitled.png" alt="untitled"/></p>
</blockquote>

<ul>
<li><code>TakeAllTimeout</code></li>
</ul>

<pre><code class="language-c++">inline void TakeAllTimeout(stTimeout_t *apTimeout, unsigned long long allNow, stTimeoutItemLink_t *apResult)
{
    // 用于重新初始化stTimeout_t
    if (apTimeout-&gt;ullStart == 0)
    {
        apTimeout-&gt;ullStart = allNow;
        apTimeout-&gt;llStartIdx = 0;
    }
    // 如果传入的当前时间比开始时间还小, 明显发生了错误
    if (allNow &lt; apTimeout-&gt;ullStart)
    {
        return;
    }
    // 计算当前时间离上次超时处理过了多久
    // 每一毫秒都有一个对应的用于存储超时事件的结构体
    int cnt = allNow - apTimeout-&gt;ullStart + 1;
    // 时间差超出了链表数组大小
    if (cnt &gt; apTimeout-&gt;iItemSize)
    {
        cnt = apTimeout-&gt;iItemSize;
    }
    if (cnt &lt; 0)
    {
        return;
    }
    for (int i = 0; i &lt; cnt; i++)
    {
        // 通过llStartIdx偏移量计算索引
        int idx = (apTimeout-&gt;llStartIdx + i) % apTimeout-&gt;iItemSize;
        // 将stTimeoutItemLink_t指向的链表
        // 移动到stTimeout_t中的pItems链表中
        // 并且重置stTimeoutItemLink_t
        Join&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(apResult, apTimeout-&gt;pItems + idx);
    }
    // 重新设置开始时间
    apTimeout-&gt;ullStart = allNow;
    // 重新设置偏移量, 供下次TakeTimeout使用
    apTimeout-&gt;llStartIdx += cnt - 1;
}
</code></pre>

<h4 id="toc_3">1.1.3 libco超时时间处理机制总结</h4>

<ol>
<li><code>llStartIdx</code>: 利用取余操作将<code>pItems</code>数组当作<strong>环状数组</strong>, 具体机制:
<img src="media/15058774867304/stTimeout_t.png" alt="stTimeout_t"/></li>
<li>虽然这种超时事件处理机制在<code>TakeAllTimeout</code>中需要遍历从上次<code>TakeAllTimeout</code>到当前时间所有的超时事件, 但在<code>co_eventloop</code>中, 限定了每次loop最长等待1ms, 考虑到时间精度, <code>TakeAllTimeout</code>遍历的链表并不多, 时间复杂度并不高.</li>
<li>当设定时间与开始时间(<code>diff</code>)超出<code>iItemSize</code>时, 事件会被放置到<code>pItems</code>利用<code>llStartIdx</code>偏移后的数组末尾, 造成堆积. 但是在调度器中做了处理, 无需担心超时事件被提前触发的问题.</li>
</ol>

<hr/>

<h3 id="toc_4">1.2 回到<code>co_eventloop</code></h3>

<p><code>co_eventloop</code>代码篇幅比较长, 分段分析.</p>

<ul>
<li>初始化部分</li>
</ul>

<pre><code class="language-c++">void co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg)
{
    // 检查用于存储epoll结果数组的结构体是否已创建
    if (!ctx-&gt;result)
    {
        // 创建epoll结果结构体
        ctx-&gt;result = co_epoll_res_alloc(stCoEpoll_t::_EPOLL_SIZE);
    }
    // 取出result指针, 方便后续使用
    co_epoll_res *result = ctx-&gt;result;
    ......
</code></pre>

<ul>
<li><code>epoll_wait</code>部分</li>
</ul>

<pre><code class="language-c++">   ......
    // 事件循环开始
    for (;;)
    {
        // 调用epoll, 并且最长等待时间设置为1ms
        // co_epoll_wait 在 *inx 系统下只是简单包装了下epoll_wait
        int ret = co_epoll_wait(ctx-&gt;iEpollFd, result, stCoEpoll_t::_EPOLL_SIZE, 1);
    ......
</code></pre>

<ul>
<li>查找出所有需要调度的事件</li>
</ul>

<pre><code class="language-c++">        // 获取active链表
        // active链表与libco提供的协程信号量机制有关
        stTimeoutItemLink_t *active = (ctx-&gt;pstActiveList);
        // 获取timeout链表, 用于在后续操作中存储超时事件
        stTimeoutItemLink_t *timeout = (ctx-&gt;pstTimeoutList);

        memset(timeout, 0, sizeof(stTimeoutItemLink_t));
        // 开始遍历epoll_wait返回的已就绪事件
        for (int i = 0; i &lt; ret; i++)
        {
            // 取出对应就绪事件的指针
            stTimeoutItem_t *item = (stTimeoutItem_t *)result-&gt;events[i].data.ptr;
            if (item-&gt;pfnPrepare)
            {
                // 如果存在pfnPrepare, 表明需要自定义的调度机制
                item-&gt;pfnPrepare(item, result-&gt;events[i], active);
            }
            else
            {
                // 否则直接添加到actice链表中
                AddTail(active, item);
            }
        }
        // 获取当前时间ms
        unsigned long long now = GetTickMS();
        // 取出所有已超时事件, 并添加到timeout链表中
        TakeAllTimeout(ctx-&gt;pTimeout, now, timeout);

        // 遍历已超时事件链表
        stTimeoutItem_t *lp = timeout-&gt;head;
        while (lp)
        {
            // 由于普通的事件和超时事件共用stTimeoutItem_t类型
            // 需要设置此标识以区分两种事件
            lp-&gt;bTimeout = true;
            lp = lp-&gt;pNext;
        }
        // 将timeout链表所有元素移动到active链表中
        Join&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(active, timeout);
</code></pre>

<ul>
<li>开始载入就绪事件</li>
</ul>

<pre><code class="language-c++">        // 获取链表头部
        lp = active-&gt;head;
        while (lp)
        {
            // 从active链表中删除头部元素
            PopHead&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(active);
            // 如果当前时间小于设定的超时事件, 说明此事件不应该触发
            // 出现这种情况是由于stTimeout_t中iItemSize限制了超时事件最大事件
            // 所有超时时间点超出iItemSize的都会放置到末尾元素中
            if (lp-&gt;bTimeout &amp;&amp; now &lt; lp-&gt;ullExpireTime)
            {
                // 重新将超时事件放回超时队列
                int ret = AddTimeout(ctx-&gt;pTimeout, lp, now);
                if (!ret)
                {
                    // 返回正常, 遍历下一个事件
                    lp-&gt;bTimeout = false;
                    lp = active-&gt;head;
                    continue;
                }
            }
            if (lp-&gt;pfnProcess)
            {
                // 调用就绪事件中的函数
                lp-&gt;pfnProcess(lp);
            }

            lp = active-&gt;head;
        }
</code></pre>

<ul>
<li>每次事件循环末尾调用自定义<code>pfn</code></li>
</ul>

<pre><code class="language-c++">        if (pfn)
        {
            if (-1 == pfn(arg))
            {
                break;
            }
        }
    } // 事件循环结束, 进入下一轮
}
</code></pre>

<hr/>

<h3 id="toc_5">1.3 libco中的信号量</h3>

<p>libco中提供了协程之间的信号量操作, 分别有</p>

<pre><code class="language-c++">stCoCond_t *co_cond_alloc();
int co_cond_free(stCoCond_t *cc);

int co_cond_signal(stCoCond_t *);
int co_cond_broadcast(stCoCond_t *);
int co_cond_timedwait(stCoCond_t *, int timeout_ms);
</code></pre>

<h4 id="toc_6">1.3.1 <code>stCoCond_t</code>结构相关</h4>

<ul>
<li><code>stCoCond_t</code>是一个链表</li>
</ul>

<pre><code class="language-c++">struct stCoCond_t
{
    stCoCondItem_t *head;
    stCoCondItem_t *tail;
};
</code></pre>

<ul>
<li> <code>stCoCondItem_t</code>结构体</li>
</ul>

<pre><code class="language-c++">struct stCoCondItem_t
{
    stCoCondItem_t *pPrev;
    stCoCondItem_t *pNext;
    stCoCond_t *pLink;
    // 调度器会将
    stTimeoutItem_t timeout;
};
</code></pre>

<p><code>pLink</code>存储着所有注册在当前<code>cond</code>上的事件</p>

<ul>
<li><code>co_cond_alloc</code>, 申请cond内存</li>
</ul>

<pre><code class="language-c++">stCoCond_t *co_cond_alloc()
{
    return (stCoCond_t *)calloc(1, sizeof(stCoCond_t));
}
</code></pre>

<ul>
<li><code>co_cond_free</code>, 析构<code>stCoCond_t</code></li>
</ul>

<pre><code class="language-c++">int co_cond_free(stCoCond_t *cc)
{
    free(cc);
    return 0;
}
</code></pre>

<ul>
<li><code>co_cond_pop</code>, 利用<code>stCoCond_t</code>链表模拟栈</li>
</ul>

<pre><code class="language-c++">stCoCondItem_t *co_cond_pop(stCoCond_t *link)
{
    // 取链表头部元素
    stCoCondItem_t *p = link-&gt;head;
    if (p)
    {
        // 删除链表头部元素
        PopHead&lt;stCoCondItem_t, stCoCond_t&gt;(link);
    }
    return p;
}
</code></pre>

<h4 id="toc_7">1.3.3 PV操作</h4>

<ul>
<li><code>co_cond_timedwait</code></li>
</ul>

<pre><code class="language-c++">int co_cond_timedwait(stCoCond_t *link, int ms)
{
    stCoCondItem_t *psi = (stCoCondItem_t *)calloc(1, sizeof(stCoCondItem_t));
    // 获取当前协程
    psi-&gt;timeout.pArg = GetCurrThreadCo();
    // 设置被调度时运行的函数
    psi-&gt;timeout.pfnProcess = OnSignalProcessEvent;

    if (ms &gt; 0)
    {
        // ms大于零时同时注册到超时队列中
        unsigned long long now = GetTickMS();
        psi-&gt;timeout.ullExpireTime = now + ms;
        // 获取当前线程的epoll, 并添加超时事件
        int ret = AddTimeout(co_get_curr_thread_env()-&gt;pEpoll-&gt;pTimeout, &amp;psi-&gt;timeout, now);
        if (ret != 0)
        {
            free(psi);
            return ret;
        }
    }
    // 在当前信号量注册事件
    AddTail(link, psi);
    // 挂起当前协程
    co_yield_ct();
    // 协程恢复后的清理
    RemoveFromLink&lt;stCoCondItem_t, stCoCond_t&gt;(psi);
    free(psi);

    return 0;
}
</code></pre>

<p>回想一下, 在调度器里恢复协程时, 会以<code>lp-&gt;pfnProcess(lp);</code>, 调用<code>pfnProcess</code>函数, 在协程调用<code>co_cond_timedwait</code>后, <code>pfnProcess</code>存储着<code>OnSignalProcessEvent</code>, <code>lp</code>指向<code>stTimeoutItem_t*</code>, 而这个<code>lp-&gt;pArg</code>存储着被挂起协程信息</p>

<ul>
<li><code>OnSignalProcessEvent</code></li>
</ul>

<pre><code>static void OnSignalProcessEvent(stTimeoutItem_t *ap)
{
    // 从stTimeoutItem_t.pArg中获取协程信息
    stCoRoutine_t *co = (stCoRoutine_t *)ap-&gt;pArg;
    // 恢复协程
    co_resume(co);
}
</code></pre>

<ul>
<li><code>co_cond_signal</code></li>
</ul>

<pre><code class="language-c++">int co_cond_signal(stCoCond_t *si)
{
    // 取出并删除栈顶元素
    stCoCondItem_t *sp = co_cond_pop(si);
    if (!sp)
    {
        return 0;
    }
    // 从stCoCondItem_t中的timeout删除当前元素
    RemoveFromLink&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(&amp;sp-&gt;timeout);
    // 将当前事件添加到调度器的active队列中, 等待调度
    AddTail(co_get_curr_thread_env()-&gt;pEpoll-&gt;pstActiveList, &amp;sp-&gt;timeout);

    return 0;
}
</code></pre>

<ul>
<li><code>co_cond_broadcast</code></li>
</ul>

<pre><code class="language-c++">int co_cond_broadcast(stCoCond_t *si)
{
    for (;;)
    {
        // 遍历当前条件变量链表
        stCoCondItem_t *sp = co_cond_pop(si);
        if (!sp)
            return 0;
        // 从stCoCondItem_t中的timeout删除当前元素
        RemoveFromLink&lt;stTimeoutItem_t, stTimeoutItemLink_t&gt;(&amp;sp-&gt;timeout);
        // 将当前事件添加到调度器的active队列中, 等待调度
        AddTail(co_get_curr_thread_env()-&gt;pEpoll-&gt;pstActiveList, &amp;sp-&gt;timeout);
    }

    return 0;
}
</code></pre>

<h2 id="toc_8">未解问题</h2>

<p>本章只探讨了libco中协程的调度相关操作</p>

<ul>
<li>协程共享栈</li>
<li>系统钩子</li>
<li>闭包</li>
</ul>

<p>之后再探讨</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libco 源码阅读 · 协程实现]]></title>
    <link href="zerolocusta.github.io/15057205491515.html"/>
    <updated>2017-09-18T15:42:29+08:00</updated>
    <id>zerolocusta.github.io/15057205491515.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">0. 源码蓝图</h1>

<h2 id="toc_1">0.1 功能假设</h2>

<pre><code>读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设
</code></pre>

<ul>
<li>libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间</li>
<li>在做协程上下文转换时, 会利用汇编对当前逻辑进行保存, 然后将控制权让渡给主协程调度器, 由调度器决定下一个运行的协程</li>
<li>保存协程上下文需要额外的栈, 但是libco的介绍里说了它利用了共享栈去保存协程状态
根据以上假设, 找出了几个相对应的文件和函数</li>
<li>epoll与调度器
<code>co_routine.h</code> 中</li>
</ul>

<pre><code class="language-c">// 用于运行协程的主调度循环
void co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg)
</code></pre>

<pre><code class="language-c">// 用于创建协程
int co_create(stCoRoutine_t **co, const stCoRoutineAttr_t *attr, void *(*routine)(void *), void *arg);
</code></pre>

<pre><code class="language-c">// 用于载入协程
void co_resume(stCoRoutine_t *co)
</code></pre>

<pre><code class="language-c">// 挂起协程相关操作
void co_yield_ct()
void co_yield_env(stCoRoutineEnv_t *env)
void co_yield(stCoRoutine_t *co)
</code></pre>

<hr/>

<h2 id="toc_2">0.2 简单尝试</h2>

<p>API那么多, 眼花缭乱了, 先找几个最简单的, 尝试一下他的效果吧</p>

<pre><code class="language-c">// 新建协程的API
int co_create(stCoRoutine_t **co, const stCoRoutineAttr_t *attr, void *(*routine)(void *), void *arg);

// 挂起当前协程的API
void co_yield_ct()

// 恢复被挂起协程的API
void co_resume(stCoRoutine_t *co)
</code></pre>

<p>利用这三个协程的创建, 挂起, 恢复, 简单地观察一下libco的协程运行状况.</p>

<h3 id="toc_3">0.2.1 简单的写一个测试的demo</h3>

<pre><code class="language-c">#include &quot;co_routine.h&quot;
#include &lt;stdio.h&gt;

void *foo(void *args)
{
    printf(&quot;[foo] Before Yield ①\n&quot;);
    co_yield_ct();
    printf(&quot;[foo] After  Yield ②\n&quot;);
    return NULL;
}

void *bar(void *args)
{
    printf(&quot;[bar] Before Yield ③\n&quot;);
    co_yield_ct();
    printf(&quot;[bar] After  Yield ④\n&quot;);
    return NULL;
}


int main(int argc, char *argv[])
{
    stCoRoutine_t *foo_co = NULL;
    stCoRoutine_t *bar_co = NULL;
    // 创建foo_co协程, 并且使用foo函数作为其入口函数
    co_create(&amp;foo_co, NULL, foo, 0);
    // 创建bar_co协程, 并且使用bar函数作为其入口函数
    co_create(&amp;bar_co, NULL, bar, 0);
    // 初次载入 foo_co 协程
    co_resume(foo_co);
    // 初次载入 bar_co 协程
    co_resume(bar_co);
    // 再次载入 foo_co 协程
    co_resume(foo_co);
    // 再次载入 bar_co 协程
    co_resume(bar_co);
}
</code></pre>

<p>运行结果<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.00.40.png" alt="屏幕快照 2017-09-14 下午9.00.40"/><br/>
    符合我们对协程的预期和理解, 接下来应该深入<code>co_create</code>, <code>co_resume</code> 和 <code>co_yield_ct()</code>去理解libco究竟如何实现这个过程了.</p>

<hr/>

<h2 id="toc_4">0.3 跟踪<code>co_create</code></h2>

<h3 id="toc_5">0.3.1 <code>co_create</code>函数本体</h3>

<pre><code class="language-c">int co_create(stCoRoutine_t **ppco, const stCoRoutineAttr_t *attr, pfn_co_routine_t pfn, void *arg)
{
    // 尝试获取当前线程的 全局协程运行环境
    if (!co_get_curr_thread_env())
    {
        // 如果当前线程的 全局协程运行环境 未初始化,
        // 那么初始化它
        co_init_curr_thread_env();
    }
    // 这里的 co_create_env 
    // 要理解为 根据pfn入口函数, 
    // 创建 协程私有的运行环境 , 
    // 要和上面的 全局运行环境 分开
    stCoRoutine_t *co = co_create_env(co_get_curr_thread_env(), attr, pfn, arg);
    *ppco = co;
    return 0;
}
</code></pre>

<p>根据<code>co_create</code>的源码, 发现</p>

<ul>
<li>libco每个线程都有一个全局协程运行环境</li>
<li>每个协程也有自己的私有运行环境(类似于上下文)</li>
</ul>

<hr/>

<h3 id="toc_6">0.3.1 <code>co_get_curr_thread_env()</code>函数本体</h3>

<p>先看看这个 <code>当前线程的协程全局运行环境(curr_thread_env)</code> 是什么吧</p>

<pre><code class="language-c">stCoRoutineEnv_t *co_get_curr_thread_env()
{
    return g_arrCoEnvPerThread[GetPid()];
}
</code></pre>

<p><code>co_get_curr_thread_env()</code>根据不同的当前 线程/进程  id, 去获取相应的<code>stCoRoutineEnv_t</code><br/>
    <code>g_arrCoEnvPerThread</code>数组长这样</p>

<pre><code class="language-c">static stCoRoutineEnv_t *g_arrCoEnvPerThread[204800] = {0};
</code></pre>

<hr/>

<h3 id="toc_7">0.3.2 <code>stCoRoutineEnv_t</code>结构体</h3>

<p>这个协程环境存了什么呢? <br/>
简单的看一下<code>stCoRoutineEnv_t</code>结构体</p>

<pre><code class="language-c">struct stCoRoutineEnv_t
{
  // 协程的调用栈 (resume/yield 栈) 
    stCoRoutine_t *pCallStack[128];
  // 协程调用栈的大小
    int iCallStackSize;
  // 当前线程使用的 epoll
    stCoEpoll_t *pEpoll;

    // for copy stack log lastco and nextco
  // 共享栈, 目前无视这个概念, 留到后面再深究
    stCoRoutine_t *pending_co;
    stCoRoutine_t *occupy_co;
};
</code></pre>

<p>目前看起来还是云里雾里, 因为这个<code>stCoRoutineEnv_t</code>需要和<code>co_resume</code> 和 <code>co_yield_ct()</code> 结合起来理解, 先放一边吧</p>

<hr/>

<h3 id="toc_8">0.3.3 <code>co_init_curr_thread_env()</code>函数本体</h3>

<p><code>co_create</code>下一个函数就是<code>co_init_curr_thread_env()</code></p>

<pre><code class="language-c"> void co_init_curr_thread_env()
{
    // 获取当前 线程/进程 id
    pid_t pid = GetPid();

    // 在堆中建立 stCoRoutineEnv_t 结构体
    // 将指针存入 g_arrCoEnvPerThread 相应的位置中
    g_arrCoEnvPerThread[pid] = (stCoRoutineEnv_t *)calloc(1, sizeof(stCoRoutineEnv_t));
    stCoRoutineEnv_t *env = g_arrCoEnvPerThread[pid];

    // 初始化调用栈大小
    env-&gt;iCallStackSize = 0;

    // 创建一个self协程, self协程并没有入口函数!
    struct stCoRoutine_t *self = co_create_env(env, NULL, NULL, NULL);
    // 设置self协程为当前线程的主协程
    self-&gt;cIsMain = 1;

    // 共享栈相关
    env-&gt;pending_co = NULL;
    env-&gt;occupy_co = NULL;

    // 初始化self协程的上下文
    coctx_init(&amp;self-&gt;ctx);

    // 将self协程置入 pCallStack 协程调用栈的栈底
    env-&gt;pCallStack[env-&gt;iCallStackSize++] = self;

    // 暂时无视epoll
    stCoEpoll_t *ev = AllocEpoll();
    SetEpoll(env, ev);›
}
</code></pre>

<p><code>co_init_curr_thread_env()</code>中有几个关键点</p>

<ul>
<li><code>stCoRoutine_t</code>结构体</li>
<li><code>self</code>主协程</li>
<li><code>pCallStack</code> 协程调用栈</li>
</ul>

<p><code>stCoRoutine_t</code>结构体 和 <code>self</code>主协程延后关注, 先看看当前<code>pCallStack</code>的样子<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.58.18.png" alt="屏幕快照 2017-09-14 下午9.58.18"/></p>

<ul>
<li><code>self</code>协程被置入<code>pCallStack</code>的底部</li>
</ul>

<hr/>

<h3 id="toc_9">0.3.4 <code>stCoRoutine_t</code>结构体</h3>

<p><code>stCoRoutine_t</code>是用于描述和记录<strong>一个协程</strong>上下文的结构体</p>

<pre><code class="language-c">struct stCoRoutine_t
{
    stCoRoutineEnv_t *env;  // 记录协程所在的当前线程全局环境
    pfn_co_routine_t pfn;   // 当前协程运行的入口函数
    void *arg;      // 传递给入口函数的形参
    coctx_t ctx;    // 保存着当前协程的寄存器状态
    char cStart;    // 记录当前协程是否已经开始执行
    char cEnd;      // 记录当前协程是否已经结束执行
    char cIsMain;   // 记录当前协程是否为主协程
    char cEnableSysHook; // 记录当前协程是否开启系统API钩子
    char cIsShareStack;  // 记录当前协程是否开启共享栈
    // 系统API钩子相关, 本节无视之
    void *pvEnv;

    stStackMem_t* stack_mem;// 记录当前协程存放栈数据的内存地址

    // 以下均为共享栈相关, 本节无视之
    char* stack_sp; 
    unsigned int save_size;
    char* save_buffer;
    stCoSpec_t aSpec[1024];
};
</code></pre>

<p>需要关注<code>coctx_t</code>和<code>stStackMem_t</code>这个结构体, 因为 恢复/保存(resume/yield) 协程的运行状态就靠他了.</p>

<hr/>

<h3 id="toc_10">0.3.5 <code>coctx_t</code> 和 <code>stStackMem_t</code></h3>

<p>仔细观察 <em>章节0.2 简单尝试</em> <em>中, 在<code>main</code>函数中通过<code>co_resume</code>载入<code>foo_co</code>, 并且调用<code>foo</code>函数, 而在<code>foo</code>函数中, 通过<code>co_yield_ct</code>回到<code>main</code>函数中, 而后在</em><em>再次调用</em>*<code>foo</code>函数的时候, 又能回到上一次调用<code>co_yield_ct</code>的地方, 并继续执行直到函数返回.</p>

<p>在那段代码里, <code>main</code>函数没有直接调用<code>foo</code>, 而在<code>foo</code>中也没有直接调用<code>main</code>, 但是却能通过<code>co_resume</code>和<code>co_yield_ct</code>来回调用</p>

<p>这里的魔法: <strong>利用汇编, 保存被挂起协程的运行现场, 然后恢复别的协程的运行现场</strong></p>

<ul>
<li>运行现场, 其实更确切的说法是, 协程被挂起前 CPU寄存器 和 内存中栈 的状态.
而<code>coctx_t</code>就是记录着协程被挂起前 CPU寄存器状态 的结构了.
至于协程被挂起前 内存中栈的状态, 当然记录在<code>stack_mem</code>里
要把 寄存器状态、内存中栈的状态 和协程运行状态的关系说清楚, 要理解 <em>处理器中的寄存器(libco里仅支持x86及amd64)</em> 还有 <em>X86调用约定</em> , 以及 <em>操作系统如何载入程序、分配内存并运行的</em>.</li>
</ul>

<p><u>即使libco同时支持x86和amd64架构, 但是为了简化文章, 这里只探讨x86架构</u></p>

<hr/>

<h4 id="toc_11">0.3.5.1 x86处理器中的寄存器</h4>

<p>这里只关注主要用到的几个<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%8811.56.26.png" alt="屏幕快照 2017-09-14 下午11.56.26"/><br/>
x86主要用到这几个寄存器</p>

<hr/>

<h4 id="toc_12">0.3.5.2 x86调用协定</h4>

<p>根据维基百科上的<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl">X86调用约定</a>, 在c语言中发生函数调用时, 调用者会操作寄存器和内存, 保存函数调用前状态, 然后跳转到被调函数的地址</p>

<p>这里有三个很重要的寄存器</p>

<ul>
<li>esp:  栈指针, 用于存放当前栈的位置</li>
<li>ebp: 基栈指针, 用于存放当前函数栈帧的开始位置</li>
<li>eip: 存放着下一条指令的地址, CPU会自动读取eip并载入取下一条指令</li>
</ul>

<p>参考维基百科上<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl">X86调用约定</a>给出的实例, 存在这样的c语言代码</p>

<pre><code class="language-c"> int callee(int, int, int);
 int caller(void)
 {
     register int ret;
     
     ret = callee(1, 2, 3);
     ret += 5;
     return ret;
 }
</code></pre>

<p>编译后产生这样的代码<br/>
(0 - 9是我添加的, 用于简单标识出地址, 实际编译不会产生)</p>

<pre><code>       .globl  caller
 caller:
0       pushl   %ebp            # 记录调用caller函数的栈帧
1       movl    %esp, %ebp   # 构造caller栈帧
2       pushl   $3           # 逆序将callee函数入栈
3       pushl   $2
4       pushl   $1
5       call    callee       # 调用callee函数
6       addl    $12,%esp     # 缩减栈大小
7       addl    $5,%eax      # 将callee返回值+ 5
8       leave                   # 清理栈帧
9       ret                 # 返回至调用者
</code></pre>

<p>操作符简释:</p>

<ul>
<li><code>pushl [操作数]</code>: <code>push long</code>, 将操作数中的值推入栈中, 并将栈指针增加4字节的大小.</li>
<li><code>movl [a] [b]</code>:  <code>move long</code>, 将 a 中的4字节值复制到 b 中</li>
<li><code>call [函数地址]</code>: 将eip中的值推入栈中, 并跳转到函数地址</li>
<li><code>addl [a] [b]</code>: 相当于<code>b = a + b</code></li>
<li><code>leave</code>: 清空当前函数调用栈帧</li>
<li><code>ret</code>: 从栈顶取得eip地址, 返回至该地址</li>
</ul>

<p>可视化这个函数调用</p>

<ol>
<li><p><code>call callee</code>前<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.56.12.png" alt="屏幕快照 2017-09-15 上午8.56.12"/></p></li>
<li><p><code>call callee时</code><br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.54.09.png" alt="屏幕快照 2017-09-15 上午8.54.09"/></p></li>
<li><p><code>call callee后 - leave前</code><br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.52.19.png" alt="屏幕快照 2017-09-15 上午8.52.19"/><br/>
函数调用就是操纵CPU寄存器和内存栈, 有了这样的概念, 那么我们在协程切换时, 直接利用<strong>汇编</strong>操纵寄存器和栈就好啦.</p></li>
</ol>

<hr/>

<h4 id="toc_13">0.3.5.3 操作系统如何载入程序、分配内存并运行的</h4>

<p>寄存器的问题解决了, 但是栈的问题还没解决</p>

<p>操作系统在载入程序时, 会给一个线程分配<strong>一个</strong>固定大小的栈, 而在libco中, 一个线程里有多个协程</p>

<p>先来看看所有协程都使用操作系统分配的一个栈会怎样</p>

<p>仍然利用上面的<em>章节0.2 简单尝试</em>中实例代码展示<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.25.52.png" alt="屏幕快照 2017-09-15 上午9.25.52"/></p>

<p>如果只有一个栈,  在<code>co_yield_ct</code>时, <code>foo_co</code>的栈帧被抹去, 可是这时<code>foo_co</code>还没执行完啊, 抹去了<code>foo_co</code>栈帧, 那么就没办法恢复<code>foo_co</code>被挂起前状态了.</p>

<p>所以, 必须要有一个地方存放协程的栈帧, 可以申请堆内存去存放协程的栈帧<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.37.52.png" alt="屏幕快照 2017-09-15 上午9.37.52"/></p>

<p>利用汇编, 将esp和ebp指向我们申请的堆内存就好了, 这样程序运行的时候从esp和ebp取得的就是堆内存中的地址</p>

<hr/>

<h3 id="toc_14">0.3.6 <code>coctx_t</code>结构体</h3>

<pre><code class="language-c">struct coctx_t
{
#if defined(__i386__)
    void *regs[ 8 ];
#else
    void *regs[ 14 ];
#endif
  // 栈大小
    size_t ss_size;
  // 栈指针
    char *ss_sp;
};

//----- --------
// 32 bit
// | regs[0]: ret |
// | regs[1]: ebx |
// | regs[2]: ecx |
// | regs[3]: edx |
// | regs[4]: edi |
// | regs[5]: esi |
// | regs[6]: ebp |
// | regs[7]: eax |
</code></pre>

<p>只关注x86架构下, <code>coctx_t</code>存放了8个CPU寄存器的值, 就是 <em>0.3.5.1 x86处理器中的寄存器</em> 那张图里的8个, 堆中协程栈的大小和起始位置</p>

<hr/>

<h3 id="toc_15">0.3.7 <code>coctx_t</code>结构体的相关操作</h3>

<h4 id="toc_16">0.3.7.1 <code>coctx_init</code>函数, 初始化<code>coctx_t</code>结构体</h4>

<p><code>coctx_init</code>源码</p>

<pre><code class="language-c">int coctx_init( coctx_t *ctx )
{
    memset( ctx,0,sizeof(*ctx));
    return 0;
}
</code></pre>

<hr/>

<h4 id="toc_17">0.3.7.1 <code>coctx_make</code>函数, 准备协程入口</h4>

<p><code>coctx_make</code>源码</p>

<pre><code class="language-c">enum
{
    kEIP = 0,
    kESP = 7,
};

int coctx_make(coctx_t *ctx, coctx_pfn_t pfn, const void *s, const void *s1)
{
    //make room for coctx_param
    char *sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(coctx_param_t);
  // 清空sp末位, (-16L == 0xfffffff0), 为了内存对齐
    sp = (char *)((unsigned long)sp &amp; -16L);

    coctx_param_t *param = (coctx_param_t *)sp;
    param-&gt;s1 = s;
    param-&gt;s2 = s1;

    memset(ctx-&gt;regs, 0, sizeof(ctx-&gt;regs));

    // sizeof(void*)是给pfn的形参预留的位置
    ctx-&gt;regs[kESP] = (char *)(sp) - sizeof(void *);
    ctx-&gt;regs[kEIP] = (char *)pfn;

    return 0;
}
</code></pre>

<p>调用<code>coctx_make</code>后, 堆中协程栈和<code>coctx_t</code>结构体状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.05.19.png" alt="屏幕快照 2017-09-15 下午4.05.19"/></p>

<hr/>

<h3 id="toc_18">0.3.8 跟踪<code>co_create_env</code></h3>

<p><code>co_create_env</code>用于申请协程结构体<code>stCoRoutine_t</code>的内存及协程栈的内存</p>

<pre><code class="language-c">struct stCoRoutine_t *co_create_env(stCoRoutineEnv_t *env, const stCoRoutineAttr_t *attr, pfn_co_routine_t pfn, void *arg)
{

    stCoRoutineAttr_t at;
    if (attr)
    {
        // 复制 stCoRoutineAttr_t 至 at 中
        memcpy(&amp;at, attr, sizeof(at));
    }
    if (at.stack_size &lt;= 0)
    {
        at.stack_size = 128 * 1024;
    }
    else if (at.stack_size &gt; 1024 * 1024 * 8)
    {
        at.stack_size = 1024 * 1024 * 8;
    }

    if (at.stack_size &amp; 0xFFF)
    {
        at.stack_size &amp;= ~0xFFF;
        at.stack_size += 0x1000;
    }

    stCoRoutine_t *lp = (stCoRoutine_t *) malloc( sizeof( stCoRoutine_t ));

    memset(lp, 0, (long)(sizeof(stCoRoutine_t)));

    lp-&gt;env = env;
    lp-&gt;pfn = pfn;
    lp-&gt;arg = arg;

    stStackMem_t *stack_mem = NULL;
    if (at.share_stack)
    {
        // 共享栈, 本章不关注
        stack_mem = co_get_stackmem(at.share_stack);
        at.stack_size = at.share_stack-&gt;stack_size;
    }
    else
    {
        // 为协程申请运行栈
        stack_mem = co_alloc_stackmem(at.stack_size);
    }
    // 以下均为初始化协程信息
    lp-&gt;stack_mem = stack_mem;

    lp-&gt;ctx.ss_sp = stack_mem-&gt;stack_buffer;
    lp-&gt;ctx.ss_size = at.stack_size;

    lp-&gt;cStart = 0;
    lp-&gt;cEnd = 0;
    lp-&gt;cIsMain = 0;
    lp-&gt;cEnableSysHook = 0;
    lp-&gt;cIsShareStack = at.share_stack != NULL;

    lp-&gt;save_size = 0;
    lp-&gt;save_buffer = NULL;

    return lp;
}
</code></pre>

<hr/>

<h2 id="toc_19">0.4 跟踪<code>co_resume</code></h2>

<p>协程的栈, 存放寄存器<code>coctx_t</code>结构体准备好了, 接下来是调用<code>co_resume</code>载入协程了.</p>

<pre><code class="language-c">void co_resume(stCoRoutine_t *co)
{
  // 获取协程全局环境
    stCoRoutineEnv_t *env = co-&gt;env;
  // 获取上一个协程
    stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[env-&gt;iCallStackSize - 1];
  // 检查协程是否已经执行过
    if (!co-&gt;cStart)
    {
        // 创建协程入口, coctx_make在上面讨论过
        // 注意这里 CoRoutineFunc
        coctx_make(&amp;co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, 0);
        co-&gt;cStart = 1;
    }
  // 增加 pCallStack 协程调用栈, 并设置为 co
    env-&gt;pCallStack[env-&gt;iCallStackSize++] = co;
  // 保存当前协程现场, 切换到 co 协程现场
    co_swap(lpCurrRoutine, co);
}
</code></pre>

<hr/>

<h3 id="toc_20">0.4.1 <code>CoRoutineFunc</code>协程入口函数</h3>

<p>在<code>co_resume</code>的<code>coctx_make</code>中, 并没有直接将需要运行的函数直接传递给<code>coctx_make</code>, 而是将另一个函数<code>CoRoutineFunc</code>和<code>co</code>传给它, 先看<code>CoRoutineFunc</code>的源码</p>

<pre><code class="language-c">// 我认为 void * 是为了兼容历史遗留的API
static int CoRoutineFunc(stCoRoutine_t *co, void *)
{
    if (co-&gt;pfn)
    {
        // 在此调用需要运行在协程中的函数
        co-&gt;pfn(co-&gt;arg);
    }
    // 将协程运行完成的标识置为1
    co-&gt;cEnd = 1;

    stCoRoutineEnv_t *env = co-&gt;env;
    // 直接跳到上一个协程, co_yield_env 后面会讨论, 无需返回
    co_yield_env(env);
    // return 0 不该发生, 否则引发 SIGSEGV
  // 因为没有构造返回地址
    return 0;
}
</code></pre>

<p>再看在调用<code>coctx_make(&amp;co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, 0);</code>后,   堆中协程栈和<code>coctx_t</code>结构体状态.<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.17.00.png" alt="屏幕快照 2017-09-15 下午4.17.00"/></p>

<hr/>

<h3 id="toc_21">0.4.2 回到<code>co_resume</code></h3>

<p>同样以<em>章节0.2 简单尝试</em>中实例代码为例, 标上行号</p>

<pre><code class="language-c">1  int main(int argc, char *argv[])
2  {
3     stCoRoutine_t *foo_co = NULL;
4     stCoRoutine_t *bar_co = NULL;
5     // 创建foo_co协程, 并且使用foo函数作为其入口函数
6     co_create(&amp;foo_co, NULL, foo, 0);
7     // 创建bar_co协程, 并且使用bar函数作为其入口函数
8     co_create(&amp;bar_co, NULL, bar, 0);
9     // 初次载入 foo_co 协程
10    co_resume(foo_co);
11    // 初次载入 bar_co 协程
12    co_resume(bar_co);
13    // 再次载入 foo_co 协程
14    co_resume(foo_co);
15    // 再次载入 bar_co 协程
16    co_resume(bar_co);
17  }
</code></pre>

<ol>
<li><p>在第10行初次载入<code>foo_co</code>之前, <code>env-&gt;pCallStack</code>的状态,<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png" alt="屏幕快照 2017-09-15 下午12.18.14"/></p></li>
<li><p>调用<code>co_resume</code>增加pCallStack栈大小之后的状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png" alt="屏幕快照 2017-09-15 下午12.16.52 1"/></p></li>
</ol>

<hr/>

<h3 id="toc_22">0.4.3 <code>co_swap</code>函数, 切换协程</h3>

<p><code>co_swap</code>是一个用汇编实现的方法</p>

<ul>
<li>它的签名</li>
</ul>

<pre><code class="language-c">extern void coctx_swap(coctx_t *, coctx_t *) asm(&quot;coctx_swap&quot;)
</code></pre>

<ul>
<li>它的实现</li>
</ul>

<pre><code>    leal 4(%esp), %eax //sp 
    movl 4(%esp), %esp 
    leal 32(%esp), %esp //parm a : &amp;regs[7] + sizeof(void*)

    pushl %eax //esp -&gt;parm a 

    pushl %ebp
    pushl %esi
    pushl %edi
    pushl %edx
    pushl %ecx
    pushl %ebx
    pushl -4(%eax)

    
    movl 4(%eax), %esp //parm b -&gt; &amp;regs[0]

    popl %eax  //ret func addr
    popl %ebx  
    popl %ecx
    popl %edx
    popl %edi
    popl %esi
    popl %ebp

    popl %esp
    pushl %eax //set ret func addr

    xorl %eax, %eax
    ret
</code></pre>

<p>对于<em>章节0.2 简单尝试</em>中初次<code>co_resume(foo_co)</code>中的<code>co_swap</code>来说, 可视化后的图</p>

<ol>
<li><p>保存<code>self</code>现场<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.23.57.png" alt="屏幕快照 2017-09-15 下午12.23.57"/></p></li>
<li><p>恢复<code>foo_co</code>现场<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%885.13.05.png" alt="屏幕快照 2017-09-15 下午5.13.05"/></p></li>
<li><p>CPU会自动从eip寄存器去下一条指令地址, 即此时载入<code>CoRoutineFunc</code>函数, 而<code>CoRoutineFunc</code>载入的协程<code>co</code>中记录的<code>foo</code>函数</p>

<hr/></li>
</ol>

<h2 id="toc_23">0.5 跟踪<code>co_yield_ct</code></h2>

<p>创建、载入协程都说完了, 然后就是挂起协程的<code>co_yield_ct</code>了吧</p>

<pre><code class="language-c">
void co_yield_ct()
{
    co_yield_env(co_get_curr_thread_env());
}

void co_yield_env(stCoRoutineEnv_t *env)
{
    // pCallStack 调用栈中, 调用co_resume(当前协程)的协程
    stCoRoutine_t *last = \
        env-&gt;pCallStack[env-&gt;iCallStackSize - 2];
    // 栈顶部的协程, 也就是当前协程
    stCoRoutine_t *curr = \
        env-&gt;pCallStack[env-&gt;iCallStackSize - 1];
    // 栈大小减1, 栈顶元素出栈
    env-&gt;iCallStackSize--;
    // 切换至 上一个协程
    co_swap(curr, last);
}
</code></pre>

<p>同样以<em>章节0.2 简单尝试</em>中实例代码为例</p>

<pre><code class="language-c">void *foo(void *args)
{
    printf(&quot;[foo] Before Yield ①\n&quot;);
    co_yield_ct();
    printf(&quot;[foo] After  Yield ②\n&quot;);
    return NULL;
}
</code></pre>

<ol>
<li><p><code>foo</code>函数在调用<code>co_yield_ct</code>前, pCallStack的状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png" alt="屏幕快照 2017-09-15 下午12.16.52 1"/></p></li>
<li><p>在调用<code>co_yield_ct</code>后, pCallStack的状态<br/>
<img src="media/15057205491515/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png" alt="屏幕快照 2017-09-15 下午12.18.14"/></p></li>
<li><p>然后调用<code>co_swap</code>回到<code>self</code>协程中保存的现场, 继续执行.</p>

<hr/>

<h2 id="toc_24">未解问题</h2>

<p>本章只探讨了libco中协程的基本操作, libco还有更多特性</p></li>
</ol>

<ul>
<li>协程共享栈</li>
<li>co_eventloop</li>
<li>系统钩子</li>
<li>闭包</li>
</ul>

<p>之后再探讨</p>

]]></content>
  </entry>
  
</feed>

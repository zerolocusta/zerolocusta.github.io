
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  zerolocust
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="locustchen的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="zerolocust" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">zerolocust</a></h1>
  
    <h2>locustchen的博客</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zerolocusta.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15101331051720.html">JavaScript高级程序设计 · 4、5、6 章</a></h1>
			<p class="meta"><time datetime="2017-11-08T17:25:05+08:00" 
			pubdate data-updated="true">2017/11/8 17:25 下午</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">第四章 变量、作用域和内存问题</h2>

<p>本章将探讨</p>

<ul>
<li>基本类型和引用类型的值</li>
<li>执行环境</li>
<li>垃圾回收</li>
</ul>

<h3 id="toc_1">基本类型和引用类型的值</h3>

<ul>
<li>基本类型包括<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>. 这五种基本数据类型是按值传递.</li>
<li>引用类型的值是保存在内存中的对象.由于JavaScript不允许直接操作内存, 在操作对象时, 实际上是在操作对象的引用.</li>
</ul>

<h4 id="toc_2">动态属性</h4>

<p>可以再对象创建后给对象添加新的属性</p>

<pre><code class="language-js">let person = new Object();
person.name = &#39;locust&#39;;
console.log(person.name) // &#39;locust&#39;
</code></pre>

<p>但无法给基础类型添加新的属性</p>

<pre><code class="language-js">let name = &#39;locust&#39;;
name.age = 21;
console.log(name.age) // undefined
</code></pre>

<h4 id="toc_3">复制变量值</h4>

<p>对于基本类型, 从一个变量复制另一个基本变量的值时, 会在变量对象上创建新的值<br/>
<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%888.49.58.png" alt="屏幕快照 2017-11-08 下午8.49.58"/></p>

<p>对于引用类型, 当一个变量复制另一个变量的值时, 会将引用复制一份到新的变量中, 并且指向相同的对象</p>

<pre><code class="language-js let">let obj2 = obj1;
obj2.name = &#39;locust&#39;;
console.log(obj.name) // locust
</code></pre>

<p><img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%889.46.10.png" alt="屏幕快照 2017-11-08 下午9.46.10"/></p>

<h4 id="toc_4">传递参数</h4>

<p>无论是基本类型或是引用类型, 对于函数传参都是按值传递的.</p>

<p>对于基本类型很容易理解</p>

<pre><code class="language-js">function addOne(num) {
    num += 1;
    return num;
}
let ten = 10;
console.log(addOne(ten)) // 11
console.log(ten) // 10
</code></pre>

<p>而对于引用类型, 是将<strong>引用</strong>复制到形参中, 形参和实参都同时指向内存中的对象.</p>

<pre><code class="language-js">function setName(obj) {
    obj.name = &#39;locust&#39;;
}

let person = new Object();
setName(person);
console.log(person.name) // locust
</code></pre>

<p>上面这段代码看似是按引用传递的, 但其实是将引用的值复制并传递<br/>
以下代码可以验证</p>

<pre><code class="language-js">function setName(obj) {
    obj = new Object();
    obj.name = &#39;locust&#39;;
}

let person = new Object();
person.name = &#39;Jason&#39;;
setName(person);
console.log(person.name) // Jason
</code></pre>

<h4 id="toc_5">检测类型</h4>

<ul>
<li><code>typeof</code>操作符: 对于基本类型, 能给出详细的类型信息, 但对于引用类型, 只能给出<code>object</code></li>
<li><code>instanceof</code> 用于检测一个变量中的值是否是某个类的实例</li>
</ul>

<h4 id="toc_6">执行环境和作用域</h4>

<ul>
<li><code>执行环境(execution context)</code>, 定义了变量或函数有权访问的其他数据.每个执行环境都有一个与之关联的<code>变量对象(variable object)</code>, 环境中定义的所有变量和函数都保存在这个对象中.</li>
<li><code>作用域链</code>, 当代码在一个环境中执行时, 会创建<code>变量对象(variable object)</code>的作用域链.</li>
<li><strong>标识符的搜索是沿着作用域链一级一级往上搜索</strong>.</li>
</ul>

<pre><code class="language-js">let color = &#39;blue&#39;;
  
function changeColor() {
    let anotherColor = &#39;red&#39;;
    
    function swapColors() {
        let tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
    }
    
    swapColors();
}
changeColor();

// 作用域链示例
window
├── color
└── changeColor()
    ├── anotherColor
    └── swapColor()
        └── tempColor
</code></pre>

<h4 id="toc_7">块级作用域</h4>

<ul>
<li><code>var</code>会导致<strong>提升(hoisting)</strong></li>
<li>ES6后建议使用<code>let</code>与<code>const</code></li>
</ul>

<h3 id="toc_8">垃圾收集</h3>

<p>JavaScript具有自动垃圾回收机制, 无需手动申请及释放内存空间.</p>

<h4 id="toc_9">标记请除(mark-and-sweep)</h4>

<p>当变量进入环境时,就将这个变量标记为<code>进入环境</code>, 不允许释放进入环境的变量.<br/>
当变量离开环境时,将其标记为<code>离开环境</code>.<br/>
垃圾收集器会根据标记找出无法再访问的变量并清除.</p>

<h4 id="toc_10">引用计数</h4>

<p>当引用类型被赋予某个变量时, 那么引用的对象引用计数将会加1. 当引用计数变成0时, 表示没有办法再次访问该对象, 将会被垃圾收集器清除.</p>

<h5 id="toc_11">循环引用</h5>

<p>两个对象互相包含对方的引用将会导致循环引用问题, 此时引用计数永远不会为0, 无法被回收.</p>

<pre><code class="language-js">let objA = new Object();
let objB = new Object();
 
objA.foo = objB;
objB.bar = objA;
</code></pre>

<p>想要解决循环引用问题, 需要手动<code>解除引用(dereferencing)</code></p>

<pre><code class="language-js">objA.foo = null;
objB.bar = null;
</code></pre>

<h2 id="toc_12">第五章 引用类型</h2>

<h3 id="toc_13"><code>Object</code>类型</h3>

<p>对象类型的行为与字典相似, 它的键全部都会被转换成字符串</p>

<pre><code class="language-js">let person = {
    hello : &#39;world&#39;,
    42: true
}
console.log(person.hello) // wrold
console.log(person[&#39;hello&#39;]) // wrold
console.log(person[&#39;42&#39;]) // true;
</code></pre>

<h3 id="toc_14"><code>Array</code>类型</h3>

<ul>
<li>创建数组的两种方法.</li>
</ul>

<pre><code class="language-js">// 通过构造函数
let foo = new Array();
// 通过数组字面量
let bar = [];
</code></pre>

<ul>
<li><p><code>length</code>属性</p>

<ul>
<li><code>length</code>属性用于指示数组长度, 并且它不是只读的.增加<code>length</code>属性会增加数组长度, 多出的部分为<code>undefined</code></li>
<li>当将一个值放在超出数组长度的位置上, <code>length</code>将会被重新计算, 为最后一个元素的索引位置加一.</li>
</ul></li>
<li><p>检测数组的方法: <code>Array.isArray()</code></p></li>
<li><p>栈方法: 支持<code>pop</code>和<code>push</code>方法</p></li>
<li><p>队列方法: 支持<code>shifg</code>和<code>push</code>方法</p></li>
<li><p>重排序方法: <code>sort</code>对数组排序, <code>reverse</code>翻转数组项.</p></li>
<li><p>迭代方法</p>

<ul>
<li><code>every()</code>:对数组每一项运行一个函数, 若该函数对所有项返回<code>true</code>, 则返回<code>true</code></li>
<li><code>some()</code>:对数组每一项运行一个函数, 若该函数对其中一项返回<code>true</code>, 则返回<code>true</code></li>
<li><code>filter()</code>:对数组每一项运行一个函数, 返回该函数返回true的项组成的数组.</li>
<li><code>map()</code>:对数组每一项运行一个函数, 返回每次函数调用结果组成的数组.</li>
<li><code>forEach()</code>:对数组每一项运行一个函数, 没有返回值.</li>
</ul></li>
</ul>

<h3 id="toc_15"><code>Date</code>类型</h3>

<pre><code class="language-js">let now = new Date();
</code></pre>

<h3 id="toc_16"><code>RegExp</code>类型</h3>

<p>正则表达式类型, 形如</p>

<pre><code class="language-js">let expression = / pattern / flag;
</code></pre>

<p>其中<code>pattern</code>是正则表达式, <code>flag</code>有下列三个标志</p>

<ul>
<li><code>g</code>: 表示全局模式, 即将模式应用于全部字符串,而非遇到第一个匹配项时即停止</li>
<li><code>i</code>: 忽略大小写</li>
<li><code>m</code>: 表示多行模式.</li>
</ul>

<h4 id="toc_17"><code>RegExp</code>的实例属性</h4>

<ul>
<li><code>global</code>: 布尔值, 表示是否设置了全局标志</li>
<li><code>ignoreCase</code>: 布尔值, 表示是否设置了忽略大小写标志.</li>
<li><code>multiline</code>: 布尔值, 表示是否开启了多行模式</li>
<li><code>lastIndex</code>: 整数, 表示开始搜索下一个匹配项的字符位置</li>
<li><code>source</code>: 正则表达式的字面量</li>
</ul>

<h4 id="toc_18"><code>RegExp</code>的实例方法</h4>

<ul>
<li><code>exec()</code>: 主要方法, 接收参数为需要应用模式的字符串, 返回包含第一个匹配项的数组, 匹配失败返回<code>null</code></li>
</ul>

<h3 id="toc_19"><code>Function</code>类型</h3>

<p>ECMAScript中的函数实际上是<code>Function</code>类型的实例. 函数名实际上是指向函数对象的引用</p>

<pre><code class="language-js">let sum = function(num1, num2) {
    return num1 + num2;
}
// 等价于

function sum(num1, num2) {
    return num1 + num2;
}
</code></pre>

<h4 id="toc_20">为何没有重载</h4>

<p>由于函数名实际上是指向函数对象的引用, 所以当尝试重载函数时, 是修改了变量上引用的值, 覆盖了之前声明的函数.</p>

<h4 id="toc_21">函数内部属性</h4>

<p>函数内部两个属性</p>

<ul>
<li><code>arguments</code>: 数组, 保存了函数的参数.</li>
<li><code>this</code>: 引用当前函数内部的执行环境.</li>
</ul>

<h4 id="toc_22">函数的属性和方法</h4>

<p>两个属性:</p>

<ul>
<li><p><code>length</code>: 表示函数希望接收形参的数量.</p></li>
<li><p><code>prototype</code>: 每个引用类型都拥有<code>prototype</code>属性,在第六章中将会深入分析.</p></li>
</ul>

<p>三个方法:</p>

<ul>
<li><code>apply</code>: 接收一个作用域引用和参数数组.</li>
</ul>

<pre><code class="language-js">function sum(num1, num2) {
    return num1 + num2;
}

function applySum(num1, num2) {
    return sum.apply(this, [num1, num2]);
}
</code></pre>

<ul>
<li><code>call</code>: 接收一个作用域引用和多个参数.</li>
</ul>

<pre><code class="language-js">function sum(num1, num2) {
    return num1 + num2;
}

function callSum(num1, num2) {
    return sum.call(this, num1, num2);
}
</code></pre>

<ul>
<li><code>bind</code>方法: 改变函数运行的环境</li>
</ul>

<pre><code class="language-js">let o = {
    color: &#39;blue&#39;
}

function printColor() {
    console.log(this.color);
}

let foo = printColor.bind(o);
foo() // &#39;blue&#39;
</code></pre>

<h4 id="toc_23">基本包装类型</h4>

<p>基本包装类型有三个: <code>String</code>, <code>Number</code>, <code>Boolean</code>, 用于方便开发者以对象的方式创建和操作基本类型.但要注意的是, 基本类型与基本类型对象是不一样的.<br/>
在使用时, 解释器会自动读取和写入对象的值</p>

<h5 id="toc_24"><code>Boolean</code>对象(<strong>不建议使用</strong>)</h5>

<pre><code class="language-js">// 利用 Boolean 对象创建布尔值
let falseObject = new Boolean(false)
// 与布尔值进行布尔操作
console.log(falseObject &amp;&amp; true) // true
</code></pre>

<p>由于所有对象在布尔表达式中都是<code>true</code>, 所以布尔对象当然也为<code>true</code></p>

<h5 id="toc_25"><code>Number</code>对象</h5>

<p><code>Number</code>对象时数字值对应的引用类型,创建其实例</p>

<pre><code class="language-js">let num = new Number(19);
</code></pre>

<p><code>Number</code>有几个值得注意的实例方法</p>

<ul>
<li><code>toFixed()</code>: 按照指定的小数位<strong>四舍五入</strong>返回数值的字符串表示.</li>
<li><code>toExponential()</code>: 按照指定的小数位<strong>四舍五入</strong>返回数值的字符串的科学计数法表示</li>
</ul>

<p>以及<code>Number</code>对象与<code>Number</code>基本类型在<code>typeof</code>操作符上的不同表象</p>

<pre><code class="language-js">let num1 = new Number(19);
alert(typeof num1) // &#39;object&#39;
let num2 = 19;
alert(typeof num2) // &#39;number&#39;
</code></pre>

<h5 id="toc_26"><code>String</code>对象</h5>

<p><code>String</code>类型是字符串类型的对象包装类型.<br/>
<code>String</code>的某些属性与实例方法:</p>

<ul>
<li><code>charAt()</code>: 接收一个参数, 返回字符串对应位置的字符(也可以通过<code>[]</code>操作符完成).</li>
<li><code>concat()</code>: 接收任意多个字符串参数, 返回拼接后的字符串.</li>
<li><code>slice()</code>: 对字符串进行切片</li>
<li><code>indexOf()</code>: 接收一个字符串参数, 返回该字符串在被搜索串中的第一次出现的索引, 不存在返回-1.</li>
<li><code>trim()</code>方法, 创建一个字符串副本, 删除前置及后缀的空格, 并返回结果.</li>
<li><code>replace()</code>: 用于根据正则表达式替换字符串</li>
</ul>

<h4 id="toc_27">单体内置对象</h4>

<p><code>单体内置对象</code>指由<code>ECMAScript</code>实现提供的, 不依赖宿主环境的. 这些对象在<code>ECMAScript</code>执行前就已经存在.</p>

<h5 id="toc_28"><code>Global</code>对象</h5>

<p><code>Global</code>对象处于所有作用域链的顶端, 在<code>ECMAScript</code>执行点就已经载入, 除了拥有之前提到的诸如<code>isNaN()</code>, <code>isFinite()</code>,<code>parseInt()</code>等都是<code>Global</code>对象的方法.<br/>
除此之外, 它还包含一些其他方法.</p>

<ul>
<li><p><code>URL编解码方法</code></p>

<ul>
<li><code>encodeURIComponent()</code>: 是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码.</li>
<li><code>encodeURI()</code>: 会替换所有的字符，但不包括以下字符<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-09%20%E4%B8%8B%E5%8D%888.56.13.png" alt="屏幕快照 2017-11-09 下午8.56.13"/></li>
<li><code>decodeURIComponent()</code>: 将已编码 URI 中所有能识别的转义序列转换成原字符</li>
<li><code>decodeURI()</code>: 将已编码 URI 中所有能识别的转义序列转换成原字符，但不能解码那些不会被 <code>encodeURI()</code>编码的内容</li>
</ul></li>
<li><p><code>eval()</code>方法: 将会解析传入的<code>JavaScript</code>脚本字符串并执行.</p></li>
<li><p><code>Global</code>对象的属性<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-09%20%E4%B8%8B%E5%8D%889.00.56.png" alt="屏幕快照 2017-11-09 下午9.00.56"/></p></li>
<li><p><code>window</code>对象: 在浏览器中, <code>window</code>对象扩展了<code>Global</code>对象, 并成为新的全局对象.</p></li>
</ul>

<hr/>

<h2 id="toc_29">第六章 面向对象的程序设计</h2>

<h3 id="toc_30">原始时期创建对象的方法</h3>

<pre><code class="language-js">let person = new Object();
person.name = &#39;locust&#39;;
person.sayName = function() {
    alert(this.name);
}
</code></pre>

<p>这个对象中添加了<code>name</code>属性和<code>sayName()</code>方法.</p>

<h3 id="toc_31">属性类型</h3>

<p>在<code>ES5</code>中定义了两种属性: 数据属性和访问器属性. 为了表示属性是内部值, 该规范将它们放在两对方括号中, 例如<code>[[Enumerable]]</code>.</p>

<h4 id="toc_32">数据属性</h4>

<ul>
<li><code>[[Configuralbe]]</code>: 表示能否通过<code>delete</code>删除属性从而重新定义属性, 能否修改属性的特性, 或者能否将属性修改为访问器属性.</li>
<li><code>[[Enumerable]]</code>: 表示能否通过<code>for-in</code>遍历.</li>
<li><code>[[Value]]</code>: 表示这个属性的值, 当修改当前属性时, 需要从这个位置修改.</li>
<li><code>[[Writable]]</code>: 表示该属性是否可写.</li>
</ul>

<p>例如:</p>

<pre><code class="language-js">let person = {
    name: &#39;locust&#39;
};
</code></pre>

<p>对于<code>person</code>对象中的<code>name</code>属性, <code>[[Value]]</code>被设置为<code>locust</code></p>

<h5 id="toc_33">修改属性默认特性的方法</h5>

<p><code>ES5</code>提供了修改默认属性特性的方法<code>Object.defineProperty(obj, prop, descriptor)</code>, 其中</p>

<ul>
<li><code>obj</code>: 表示属性所在的对象.</li>
<li><code>prop</code>: 表示属性的名字.</li>
<li><code>descriptor</code>: 用于描述属性对象特性的对象.</li>
</ul>

<p>例如</p>

<pre><code class="language-js">let person = new Object();
Object.defineProperty(person, &#39;name&#39;, {
    writalbe: false,
    value: &#39;locust&#39;
}
alert(person.name); // locust
// (在严格模式下, 向不可写属性复制会抛出异常)
person.name = &#39;jason&#39;;
alert(person.name); // locust
</code></pre>

<h4 id="toc_34">访问器属性</h4>

<ul>
<li><code>[[Configuralbe]]</code>: 表示能否通过<code>delete</code>删除属性从而重新定义属性, 能否修改属性的特性, 或者能否将属性修改为访问器属性.</li>
<li><code>[[Enumerable]]</code>: 表示能否通过<code>for-in</code>遍历.</li>
<li><code>[[Get]]</code>: 在读取属性时调用的函数, 默认值为<code>undefined</code></li>
<li><code>[[Set]]</code>: 在写入属性时调用的函数, 默认值为<code>undefined</code></li>
</ul>

<p>同样可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>修改访问器属性.</p>

<p>例如</p>

<pre><code class="language-js">let person = {
  _age: 21
}
Object.defineProperty(person, &#39;age&#39;, {
  set: function (newValue) {
    if (newValue &lt; 0) {
      this._age = 0;
      return;
    }
    this._age = newValue;
  }
});
</code></pre>

<h3 id="toc_35">创建对象</h3>

<h4 id="toc_36">工厂模式</h4>

<pre><code class="language-js">function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age  = age;
    o.job  = job;
    o.sayName = function() {
        alert(this.name);
    }
    return o;   
}
</code></pre>

<p>工厂模式可以解决创建对象的代码冗余问题, 但是仍然无法解决对象识别问题(<code>instanceof</code>)</p>

<h4 id="toc_37">构造函数模式</h4>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
    this.sayName = function() {
        alert(this.name);
    }
}

let person = new Person(&#39;locust&#39;, 21, &#39;Doctor&#39;);
</code></pre>

<p>这里使用了<code>new</code>操作符, 通过<code>new</code>调用构造函数会经历以下步骤:</p>

<ol>
<li>创建一个新的对象</li>
<li>将构造函数的作用域赋给新的对象(也就是<code>this</code>指向了新的对象)</li>
<li>执行构造函数中的代码(给新对象添加属性和方法)</li>
<li>返回新对象</li>
</ol>

<p>通过<code>new</code>操作符生成的实例还会拥有<code>constructor</code>属性, 该属性指向<code>Person</code>构造函数</p>

<pre><code class="language-js">alert(person.constructor === Person) // true
</code></pre>

<p>同时也可以使用<code>instanceof</code>操作符去识别对象</p>

<pre><code class="language-js">alert(person instanceof Object)  // true
alert(person instanceof Person); // true
</code></pre>

<h5 id="toc_38">构造函数的问题</h5>

<p>在通过构造函数实例化对象时, 其中的属性会创建新的副本, 然而多个相同方法的副本(<code>Function对象</code>)是没有必要的(例如<code>Person</code>中的<code>sayName()</code>), 如此一来就会造成内存浪费.</p>

<p>其中一个不太好的解决方法</p>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
    this.sayName = sayName;
}

function sayName() {
    alert(this.name);
}
</code></pre>

<h4 id="toc_39">原型模式</h4>

<p> 每一个函数都有一个名为<code>prototype(原型)</code>属性, 这个属性指向<strong>一个对象</strong>, <strong>而这个对象是包含由特定类型的所有实例共享的属性和方法</strong></p>

<pre><code class="language-js">function Person() {}

Person.prototype.name = &#39;locust&#39;;
Person.prototype.age  = 21;
Person.prototype.job  = &#39;Doctor&#39;;
Person.prototype.sayName = function() {
    alert(this.name);
}

let person = new Person();
</code></pre>

<h5 id="toc_40">理解原型对象</h5>

<p>每创建一个新函数,都会为该函数创建一个<code>prototype</code>属性,并且指向函数的原型对象.</p>

<p>默认情况下, 所有原型对象都会获得<code>constructor</code>属性, 其指向<code>prototype</code>属性所在的函数.</p>

<p>在通过构造函数实例化对象后, 该对象会包含一个内部属性<code>[[Prototype]]</code>, 该属性指向构造函数的原型对象.在某些实现中, 可以通过<code>__proto__</code>访问它</p>

<p>以<code>Person</code>为例<br/>
<img src="media/15101331051720/person.png" alt="person"/></p>

<h5 id="toc_41">对象中属性的搜索顺序</h5>

<p>每当代码读取对象中的属性时, 都会执行一次搜索, 首先从对象实例开始.如果找到了改名字对应的属性, 则返回该属性的值. 如果未找到, 则搜索实例的原型对象.</p>

<p>所以当我们的实例需要给属性赋予自己的值时</p>

<pre><code class="language-js">function Person() {}

Person.prototype.name = &#39;locust&#39;;
Person.prototype.age  = 21;
Person.prototype.job  = &#39;Doctor&#39;;
Person.prototype.sayName = function() {
    alert(this.name);
}

let person = new Person();
person.name = &#39;jason&#39;;
</code></pre>

<p>此时对象内部图示<br/>
<img src="media/15101331051720/pp.png" alt="pp"/></p>

<p>当我们需要判断某个实例的属性是来自原型对象, 还是来自对象自身, 可以使用<code>hasOwnProperty()</code>判断</p>

<pre><code class="language-js">let person = new Person();
alert(person.hasOwnProperty(&#39;name&#39;)); // false

person.name = &#39;jason&#39;;
alert(person.hasOwnProperty(&#39;name&#39;)); // true

delete person.name;
alert(person.hasOwnProperty(&#39;name&#39;)); // false
</code></pre>

<p>当我们需要判断某个实例的属性是否存在于原型对象中时, 可以使用<code>in</code>操作符</p>

<pre><code class="language-js">let person = new Person();
alert(&#39;name&#39; in person); // true
</code></pre>

<h5 id="toc_42">原型对象的问题</h5>

<ol>
<li>原型对象没有构造函数.</li>
<li>由于原型对象中的属性由所有实例共享, 当我们对原型对象中的引用类型实例进行操作时, 会影响到其他的实例.</li>
</ol>

<h4 id="toc_43">组合使用构造函数与原型对象</h4>

<p>对于面向对象编程来说, 多个实例中方法可以共享, 但属性应该是每个实例独有的. 由此我们可以利用构造函数的<code>this</code>引用存储属性, 利用<code>prototype</code>存放方法.</p>

<pre><code class="language-js">function Person(name, age, job) {
    this.name = name;
    this.age  = age;
    this.job  = job;
}

Person.prototype.sayName = function() {
    alert(this.name);
}
</code></pre>

<p>完美~</p>

<h3 id="toc_44">继承</h3>

<h4 id="toc_45">原型链</h4>

<p>利用原型让一个引用类型继承另一个引用类型的属性和方法.</p>

<p>根据<code>对象中属性的搜索顺序</code>, 只需要令子类的原型对象执行父类的实例, 就可以完成继承了</p>

<pre><code class="language-js">function SuperType() { 
    this.property = true;
}

SuperType.prototype.getSuperValue = function()   {
    return this.property;
};

function SubType() {
    this.subProperty = false;
}
// 继承 SuperType
SubType.property = new SuperType();

SubType.property.getSubValue = function() {
    return this.subProperty;
};

let subInstance = new SubType();
alert(subInstance.getSuberValue()); // true
</code></pre>

<p><img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-10%20%E4%B8%8B%E5%8D%8810.35.48.png" alt="屏幕快照 2017-11-10 下午10.35.48"/></p>

<h5 id="toc_46">原型链的顶端</h5>

<p>所有引用类型默认都继承了<code>Object</code>, 所以所有引用类型的原型链顶端均是<code>Object.prototype</code><br/>
<img src="media/15101331051720/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-10%20%E4%B8%8B%E5%8D%8810.36.36.png" alt="屏幕快照 2017-11-10 下午10.36.36"/></p>

<h5 id="toc_47">原型链继承的问题</h5>

<ol>
<li>父类的实例属性变成了子类的原型, 所有的子类实例都共享了父类的实力属性.</li>
<li>无法向父类构造函数传递参数.</li>
</ol>

<h4 id="toc_48">借用构造函数</h4>

<p>通过调用父类构造函数, 将父类的属性赋予到子类中,</p>

<pre><code class="language-js">function SuperType(name) {
    this.name = name;
}

function SubType(age) {
    // 调用父类构造函数, 将父类属性赋予子类
    SuperType.call(this, &#39;locust&#39;);
    this.age = age;
}

let subInstance = new SubType(21)
alert(subInstance.name); // locust
alert(subInstance.age); // 21
</code></pre>

<h5 id="toc_49">借用构造函数的问题</h5>

<p>只继承了父类的属性, 并未继承父类的方法</p>

<h4 id="toc_50">组合继承</h4>

<p>组合继承融合了原型链继承和借用构造函数继承的方法, <code>原型链继承</code>用于继承父类<strong>方法</strong>, <code>借用构造函数继承</code>用于继承父类<strong>属性</strong>.</p>

<pre><code class="language-js">function SuperType(name) {
    this.name = name;
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    // 继承父类属性
    SuperType.call(this, name);
    this.age = age;
}
// 继承父类方法
SubType.prototype = new SuperType();

SubType.prototype.sayAge = function() {
    alert(this.age);
}
</code></pre>

<h4 id="toc_51">ES5中的<code>Object.create</code>继承</h4>

<p><code>Object.create(proto[, propertiesObject])</code>方法以<code>proto</code>和<code>propertiesObject</code>创建新的对象;</p>

<p>继承实例</p>

<pre><code class="language-js">function SuperType(name) {
    this.name = name;
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    // 继承父类属性
    SuperType.call(this, name);
    this.age = age;
}

// 继承父类方法
SubType.prototype = Object.create(SuperType.prototype);

// 重定向构造函数
SubType.prototype.constructor = SubType
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15096777193883.html">Node.js设计模式 · 第七章</a></h1>
			<p class="meta"><time datetime="2017-11-03T10:55:19+08:00" 
			pubdate data-updated="true">2017/11/3 10:55 上午</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Wiring Modules</h2>

<blockquote>
<p>模块之间的编排设计</p>
</blockquote>

<h3 id="toc_1">Modules and dependencies</h3>

<p>大多数项目中都是多个模块聚合而成的,随着版本迭代,模块的依赖会越来越多,程序越发复杂.如果前期没规划好,那么项目的技术债就会马曼出现,从而变得难以维护和改动.</p>

<p>Node.js模块系统的特性提供了非常优秀的模块组织功能, 将模块作为对象导入的特性很方便将两个相互依赖的模块通过<code>DI</code>, <code>Locator</code>之类的技术进行解耦</p>

<h4 id="toc_2">Cohesion and coupling</h4>

<ul>
<li><code>Cohesion(内聚)</code>: 指机能相关的程序组合成一模块的程度, 或是各机能凝聚的状态或程度</li>
<li><code>Coupling(耦合)</code>: 指组件与组件之间的相互依赖程度.</li>
</ul>

<p>一般来说, 一个组件应该拥有高内聚低耦合的特性.</p>

<h4 id="toc_3">Stateful modules</h4>

<blockquote>
<p>拥有状态的模块</p>
</blockquote>

<p>由于<code>JavaScript</code>中所有元素,包括模块也是对象, 所以创建带有状态的对象也非常简单</p>

<h5 id="toc_4">The Singleton pattern in Node.js</h5>

<blockquote>
<p>单例模式</p>
</blockquote>

<p>得益于<code>Node.js</code>中的模块加载系统, 相同的模块只会加载并缓存一次的特性, 只需要通过<code>module.exports</code>导出对象实例就可以满足单例模式的需求.</p>

<p>例如在<code>db.js</code>中导出</p>

<pre><code class="language-js">// db.js
module.exports = new Database(&#39;mydb&#39;);
</code></pre>

<p>然后在其他模块中只需<code>require(&#39;db.js&#39;)</code>, 就可以获得<code>new Database(&#39;mydb&#39;)</code>的单例.</p>

<p>然而, 并不是所有情况下在整个项目中都能获取到同一个实例, 考虑如下项目目录结构<br/>
<img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-05%20%E4%B8%8A%E5%8D%8811.03.03.png" alt="屏幕快照 2017-11-05 上午11.03.03"/><br/>
在<code>packageA</code>和<code>packageB</code>中, 他们各自的<code>node_modules</code>中都存在<code>mydb</code>模块,根据<code>require.resolve算法</code>的特点, 两个<code>package</code>中的文件分别会说获取到各自<code>node_modules</code>中的不同实例,从而导致整个应用中出现了两个单例, 破坏了单例模式的特性.</p>

<blockquote>
<p>引用第二章中模块引入方法的查找特性.</p>

<h4 id="toc_5">The resolving algorithm</h4>

<p><code>require.resolve算法的实现功能点</code><br/>
resolve算法主要解决三种模块引入的路径问题<br/>
        * 文件模块 <br/>
            * 如果模块名由<code>/</code>开头的话, 那么几乎说明这是模块的绝对路径, 直接返回即可. 如果模块名以<code>./</code>或是<code>../</code>那么就认为是相对路径, 开始查找模块<br/>
        * 核心模块<br/>
            * 如果模块名无法标识这是一个核心模块, 那么就会去Node的内嵌核心模块中找, 例如<code>fs</code><br/>
        * 包模块<br/>
            * 如果上述两种方式都找不到该模块, 那么Node会从最相近的目录中查找<code>node_modules</code>这个目录, 如果找不到, 那么继续往上级目录查找, 直到操作系统的根目录.</p>

<p>而文件模块和包模块又有一个模块查找顺序:<br/>
        1. 查找<code>&lt;moduleName&gt;.js</code><br/>
        2. 查找<code>&lt;moduleName&gt;/index.js</code><br/>
        3. 从<code>&lt;moduleName&gt;/package.json</code>中的<code>main</code>属性中指定的文件中查找</p>
</blockquote>

<p>解决这个问题的方法之一, 可以使用<code>global</code>变量去存放单例例如</p>

<pre><code class="language-js">global.db = new Database(&#39;mydb&#39;)
</code></pre>

<p>然而除非必要, 完全不建议修改<code>global</code>变量, 况且很多应用中严格的单例模式不是必须, 在之后的<code>Patterns for wiring modules</code>会介绍另一种模式用于实现严格的单例模式</p>

<h3 id="toc_6">Patterns for wiring modules</h3>

<blockquote>
<p>模块结构的设计模式</p>
</blockquote>

<p>这一节将会通过建立一个HTTP认证服务, 并以此为蓝本将详述各种模块设计模式.</p>

<h4 id="toc_7">Hardcoded dependency</h4>

<p><code>Hardcoded dependency</code>是最常用的模块依赖解决方式, 各模块的状态在模块编写时已经被硬编码.</p>

<h5 id="toc_8">Building an authentication server using hardcoded dependencies</h5>

<p>本节建立的HTTP认证服务以<code>Express</code>作为Http框架, <code>levelup</code>用于存储信息, 并通过<code>JWT</code>生成用户登录态token.</p>

<p>认证服务的模块依赖:<br/>
<img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-05%20%E4%B8%8B%E5%8D%8811.03.44.png" alt="屏幕快照 2017-11-05 下午11.03.44"/></p>

<p>并且通过两个<code>HTTP</code>接口进行用户认证:</p>

<ul>
<li><code>POST /login</code>: <code>/login</code>接口通过<code>POST</code>方法接收一个带有<code>username</code>和<code>password</code>的JSON结构, 通过查询<code>leveldb</code>验证用户合法性, 最后将信息用户态以JWT加密返回.</li>
<li><code>GET /checklogin</code>: 从url参数中获取记录用户登录态的<code>token</code>, 验证用户信息.</li>
</ul>

<h6 id="toc_9">The db module</h6>

<p>首先建立从`存储用户信息的数据库接口</p>

<pre><code class="language-js">// db.js
const level = require(&#39;level&#39;);
const sublevel = require(&#39;level-sublevel&#39;);

module.exports = sublevel(
  level(&#39;example-db&#39;, {valueEncoding: &#39;json&#39;})
);
</code></pre>

<p><code>db.js</code>模块导出了一个<code>leveldb</code>实例.</p>

<h6 id="toc_10">The authService module</h6>

<p><code>authService</code>建立用户密码认证与数据之间的连接服务</p>

<pre><code class="language-js const">const bcrypt = require(&#39;bcrypt&#39;);

const db = require(&#39;./db&#39;);
// 从db中获取users集合
const users = db.sublevel(&#39;users&#39;);
// salt
const tokenSecret = &#39;SHHH!&#39;;

exports.login = (username, password, callback) =&gt; {
  // 尝试从数据库中获取用户信息
  users.get(username, (err, user) =&gt; {
    if(err) return callback(err);
    // 将加密后的password与数据库中加密后的密码进行比对
    bcrypt.compare(password, user.hash, (err, res) =&gt; {
      if(err) return callback(err);
      if(!res) return callback(new Error(&#39;Invalid password&#39;));
      // 登陆成功生成登陆态token
      let token = jwt.encode({
        username: username,
        expire: Date.now() + (1000 * 60 * 60) //1 hour
      }, tokenSecret);
      // 回传token
      callback(null, token);
    });
  });
};

exports.checkToken = (token, callback) =&gt; {
  let userData;
  try {
    //利用密钥解开token
    userData = jwt.decode(token, tokenSecret);
    if (userData.expire &lt;= Date.now()) {
      // 检查token是否超时
      throw new Error(&#39;Token expired&#39;);
    }
  } catch(err) {
    return process.nextTick(callback.bind(null, err));
  }
  // 检查username是否存在
  users.get(userData.username, (err, user) =&gt; {
    if (err) return callback(err);
    callback(null, {username: userData.username});
  });
};
</code></pre>

<h6 id="toc_11">The authController module</h6>

<p>最后是将HTTP请求中的用户参数提取, 并调用<code>authService</code>验证用户.</p>

<pre><code class="language-js">const authService = require(&#39;./authService&#39;);

exports.login = (req, res, next) =&gt; {
  // 从Http Request 中获取username和password
  // 通过authService验证用户
  authService.login(req.body.username, req.body.password,
    (err, result) =&gt; {
      if (err) {
        // 登陆失败, 返回异常
        return res.status(401).send({
          ok: false,
          error: &#39;Invalid username/password&#39;
        });
      }
      // 验证成功返回用户登录态token
      res.status(200).send({ok: true, token: result});
    }
  );
};

exports.checkToken = (req, res, next) =&gt; {
  // 从 HTTP Request 的 URL 参数中获取token
  // 通过authService检测token
  authService.checkToken(req.query.token,
    (err, result) =&gt; {
      if (err) {
        return res.status(401).send({
          ok: false,
          error: &#39;Token is invalid or expired&#39;  
        });
      }
      res.status(200).send({ok: &#39;true&#39;, user: result});
    }
  );
};
</code></pre>

<h6 id="toc_12">The app module</h6>

<p>三个用于支撑用户验证逻辑的模块已经就绪了, 接下来是用于支撑HTTP服务的app模块</p>

<pre><code class="language-js">const Express = require(&#39;express&#39;);
const bodyParser = require(&#39;body-parser&#39;);
const errorHandler = require(&#39;errorhandler&#39;);
const http = require(&#39;http&#39;);

const authController = require(&#39;./lib/authController&#39;);

// 初始化Express实例
let app = module.exports = new Express();
// 添加bodyParser中间件
app.use(bodyParser.json());
// 对接http接口与认证控制器
app.post(&#39;/login&#39;, authController.login);
app.get(&#39;/checkToken&#39;, authController.checkToken);

app.use(errorHandler());
http.createServer(app).listen(3000, () =&gt; {
  console.log(&#39;Express server started&#39;);
});

</code></pre>

<p>至此, HTTP认证服务基本完成, 抽离出<code>Hardcoded dependency</code>的部分</p>

<pre><code class="language-js">// db.js 中
module.exports = sublevel(
  // 数据库文件名被硬编码在此 
  level(&#39;example-db&#39;, {valueEncoding: &#39;json&#39;})
);

// authService.js 中
const db = require(&#39;./db&#39;);
const tokenSecret = &#39;SHHH!&#39;; // token被写死

// authController.js 中
const authService = require(&#39;./authService&#39;); // authService 模块被写死
</code></pre>

<p>目前的模块间依赖<br/>
<img src="media/15096777193883/untitled1.png" alt="untitled1"/></p>

<p>硬编码模式优势在于清晰, 模块之间的关系更容易理解, 也是最直观的, 但是考虑以下问题</p>

<ul>
<li>用于存放用户数据的数据库被局限为<code>example-db</code></li>
<li><code>authService</code>使用的数据库局限在<code>level-db</code>, 同时<code>token</code>被写在代码中</li>
<li><code>authController</code>的逻辑也被局限于<code>authService</code>模块</li>
</ul>

<p>实际项目开发中, 测试是很重要的一环, 但是测试和实际生产环境的数据要分开, 当我们要替换数据库进行测试, 或是希望分离并单独测试<code>authService</code>或是<code>authController</code>时, 就需要重新修改代码了.</p>

<h4 id="toc_13">Dependency Injection</h4>

<p>为了解决相关模块之间强依赖性问题, 引入依赖注入作为设计模块的模式.</p>

<p>将上面的三个用于认证服务的<code>db.js</code>, <code>authService.js</code>及<code>authController</code>稍作修改</p>

<ul>
<li><code>db.js</code></li>
</ul>

<pre><code class="language-js">// dbName 从硬编码 转换成通过外部注入
module.exports = function (dbName) {
  return sublevel(
    level(dbName, {
      valueEncoding: &#39;json&#39;
    })
  );
};
</code></pre>

<ul>
<li><code>authService.js</code></li>
</ul>

<pre><code class="language-js">// 数据库与密钥均由外部注入 
module.exports = (db, tokenSecret) =&gt; {
  const users = db.sublevel(&#39;users&#39;);
  const authService = {};
  
  authService.login = ...

  authService.checkToken = ...
  
  return authService;
};
</code></pre>

<ul>
<li><code>authController.js</code> </li>
</ul>

<pre><code class="language-js">// authService 由外部注入
module.exports = (authService) =&gt; {
  const authController = {};
  
  authController.login = ...

  authController.checkToken = ...
  
  return authController;
};
</code></pre>

<p>最后在<code>app.js</code>中整合多个组件</p>

<pre><code>const dbFactory = require(&#39;./lib/db&#39;);
const authServiceFactory = require(&#39;./lib/authService&#39;);
const authControllerFactory = require(&#39;./lib/authController&#39;);

const db = dbFactory(&#39;example-db&#39;);
const authService = authServiceFactory(db, &#39;SHHH!&#39;);
const authController = authControllerFactory(authService);
</code></pre>

<p>将<code>db</code>, <code>authService</code>, <code>authController</code>改为依赖注入后, 解决了原来各模块之间强耦合的问题, 同时也能替换三个模块中的组件, 从而进行分离测试.</p>

<p>目前的模块间依赖(由自底向上组织变为自顶向下聚合)<br/>
<img src="media/15096777193883/untitled0.png" alt="untitled0"/></p>

<h4 id="toc_14">Service locator</h4>

<p><code>Service locator</code>类似于桩服务, 各模块通过<code>Service locator</code>以名字为索引将所有相关模块连接起来, </p>

<p><code>Service locator</code>有几种类型, 分别是</p>

<ul>
<li>基于硬编码的服务定位器: 直接在定位器编写时将依赖名与依赖对象硬编码进去, 每次增删依赖时都会直接操作底层, 非常不推荐使用这类<code>Service locator</code>.</li>
<li>基于依赖注入的服务定位器: 各个模块预留注入接口, 最后在应用入口处填充<code>Servic locator</code>, 并注入到各个模块中.</li>
<li>全局服务定位器: 不通过依赖注入的方法注入<code>Service locator</code>, 而是全局引用一个单例, <code>require</code>当然也是一个全局服务定位器.</li>
</ul>

<h5 id="toc_15">Refactoring the authentication server to use a service locator</h5>

<blockquote>
<p>通过<code>service locator</code>改造HTTP认证服务器</p>
</blockquote>

<p>在改造各个模块之前, 首先要编写用于定位和发现服务的中心模块</p>

<ul>
<li><code>serviceLocator.js</code>(这里的实现使用了惰性初始化的模式, 在获取依赖时才生成实例)</li>
</ul>

<pre><code class="language-js">module.exports = () =&gt; {
  // 用于存放依赖名与依赖实例
  const dependencies = {};
  // 存放依赖名和生成依赖实例的工厂函数
  const factories = {};
  const serviceLocator = {};
  
  serviceLocator.factory = (name, factory) =&gt; {
    // 注册工厂函数
    factories[name] = factory;
  };
  
  serviceLocator.register = (name, instance) =&gt; {
    // 注册依赖实例
    dependencies[name] = instance;
  };
  // 用于获取依赖实例
  serviceLocator.get = (name) =&gt; {
    if (!dependencies[name]) {
      // 假如所需依赖未初始化
      const factory = factories[name];
      // 通过工厂函数初始化实例
      dependencies[name] = factory &amp;&amp; factory(serviceLocator);
      if (!dependencies[name]) {
        throw new Error(&#39;Cannot find module: &#39; + name);
      }
    }
    return dependencies[name];
  };

  return serviceLocator;
};
</code></pre>

<p>随后分别改动<code>db</code>, <code>authService</code>和<code>authController</code></p>

<ul>
<li><code>db.js</code></li>
</ul>

<pre><code class="language-js">module.exports = (serviceLocator) =&gt; {
  // 通过serviceLocator.get获取数据库文件名
  const dbName = serviceLocator.get(&#39;dbName&#39;);

  return sublevel(
    level(dbName, {valueEncoding: &#39;json&#39;})
  );
};

</code></pre>

<ul>
<li><code>authService</code></li>
</ul>

<pre><code class="language-js">module.exports = (serviceLocator) =&gt; {
  // 通过serviceLocator获取数据库实例及salt
  const db = serviceLocator.get(&#39;db&#39;);
  const tokenSecret = serviceLocator.get(&#39;tokenSecret&#39;);
  
  const users = db.sublevel(&#39;users&#39;);
  const authService = {};
  
  authService.login = ...

  authService.checkToken = ...
  
  return authService;
};
</code></pre>

<ul>
<li><code>authController</code></li>
</ul>

<pre><code class="language-js">module.exports = (serviceLocator) =&gt; {
  const authService = serviceLocator.get(&#39;authService&#39;);
  const authController = {};
  
  authController.login = ...

  authController.checkToken = ...
  
  return authController;
};
</code></pre>

<ul>
<li>最后在<code>app.js</code>出聚合多个模块</li>
</ul>

<pre><code class="language-js">const svcLoc = require(&#39;./lib/serviceLocator&#39;)();

svcLoc.register(&#39;dbName&#39;, &#39;example-db&#39;);
svcLoc.register(&#39;tokenSecret&#39;, &#39;SHHH!&#39;);
svcLoc.factory(&#39;db&#39;, require(&#39;./lib/db&#39;));
svcLoc.factory(&#39;authService&#39;, require(&#39;./lib/authService&#39;));
svcLoc.factory(&#39;authController&#39;, require(&#39;./lib/authController&#39;));

const authController = svcLoc.get(&#39;authController&#39;);
</code></pre>

<p>目前的项目结构变成了<br/>
<img src="media/15096777193883/untitled3.png" alt="untitled3"/></p>

<h4 id="toc_16">Dependency Injection container</h4>

<p>在<code>Dependency Injection</code>与<code>Service locator</code>两种模式中, 都要手动将多个模块关联起来, <code>Service locator</code>模式还需要给多个模块注入<code>Service locator</code><br/>
本节利用<code>Dependency Injection</code>模式并添加依赖注入容器, 根据参数名自动注入依赖</p>

<p><code>db</code>, <code>authService</code>, <code>authController</code>三个模块的代码与<code>Dependency Injection</code>章节的代码一模一样.</p>

<p>需要编写新的<code>diContainer</code>模块</p>

<ul>
<li><code>diContainer.js</code></li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;
// fnArgs 模块用于解析参数的名称
const fnArgs = require(&#39;parse-fn-args&#39;);

module.exports = () =&gt; {
  // 存放依赖实例
  const dependencies = {};
  const factories = {};
  const diContainer = {};

  diContainer.factory = (name, factory) =&gt; {
    factories[name] = factory;
  };

  diContainer.register = (name, dep) =&gt; {
    dependencies[name] = dep;
  };

  diContainer.get = (name) =&gt; {
    if (!dependencies[name]) {
      const factory = factories[name];
      // 利用inject函数生成模块实例
      dependencies[name] = factory &amp;&amp;
        diContainer.inject(factory);
      if (!dependencies[name]) {
        throw new Error(&#39;Cannot find module: &#39; + name);
      }
    }
    return dependencies[name];
  };
  // 自动依赖注入函数
  diContainer.inject = (factory) =&gt; {
    // fnArgs(factory) 返回一个参数名称列表
    const args = fnArgs(factory)
      .map(function (dependency) {
        // 根据参数名获取依赖实例
        return diContainer.get(dependency);
      });
    return factory.apply(null, args);
  };

  return diContainer;
};
</code></pre>

<h4 id="toc_17">小结</h4>

<ul>
<li>Hardcoded dependency

<ul>
<li>优点: 直观, 容易编写</li>
<li>缺点: 不便于分离测试, 模块间相互依赖强</li>
</ul></li>
<li>Dependency Injection

<ul>
<li>优点: 模块之间松耦合</li>
<li>缺点: 不够直观, 增加了复杂度, 需要手动注入依赖</li>
</ul></li>
<li>Service Locator

<ul>
<li>优点: 模块间通过Locator解耦合</li>
<li>缺点: 过度依赖Service Locator, 随时需要确保可用性, 模块间关系不清晰</li>
</ul></li>
<li>Dependency Injection Container

<ul>
<li>优点: 松耦合, 自动注入</li>
<li>缺点: 不够直观<br/></li>
</ul></li>
</ul>

<h3 id="toc_18">Wiring plugins</h3>

<p>插件是一种非常完美的模块组织方法, 拥有最小化的功能和最自由的可组合性<br/>
本节将探讨</p>

<ul>
<li>以插件的形式提供<code>service</code></li>
<li>如何将<code>plugin</code>插入到应用的工作流中</li>
</ul>

<h4 id="toc_19">Plugins as packages</h4>

<p>将插件作为npm package发布到npm上, 并利用npm进行插件版本管理和分发, 像<code>Express</code>和它的中间件使用的就是这种模式.这样做有几点好处</p>

<ul>
<li>npm包能很好管理插件的版本和依赖</li>
<li>每个插件都能有自己的私有的包</li>
<li>在插件中使用其他插件式依赖结构清晰

<ul>
<li>试想在没有使用package管理插件的情况下, 项目结构如下<img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%884.19.56.png" alt="屏幕快照 2017-11-08 下午4.19.56"/>
当<code>moduleA</code>需要使用<code>moduleB</code>时, <code>require(&#39;../../componentB/moduleB&#39;);</code>, 而当<code>component</code>作为<code>npm package</code>发布时, 只需要使用<code>require(&#39;componentB/module&#39;);</code>即可.</li>
</ul></li>
</ul>

<h4 id="toc_20">Plugin-controlled vs application-controlled extension</h4>

<p>插件的使用方法设计也有两种不同的方法, </p>

<ul>
<li>Explicit extension(显式扩展)</li>
<li>Extension through Inversion of Control (控制反转)</li>
</ul>

<blockquote>
<p><img src="media/15096777193883/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-08%20%E4%B8%8B%E5%8D%885.04.54.png" alt="屏幕快照 2017-11-08 下午5.04.54"/><br/>
通过插件(组件)接受者和提供者的关系区分显示扩展还是控制反转</p>
</blockquote>

<p>1.<code>Explicit extension</code>对应的是<code>Plugin-controlled</code><br/>
2.<code>Extension through Inversion of Control</code>对应的是<code>application-controlled extension</code></p>

<p>两段代码展示这两种概念:</p>

<ul>
<li><code>Plugin-controlled</code></li>
</ul>

<pre><code class="language-js">//在 app.js 中
const app = express();
const plugin = require(&#39;thePlugin&#39;);
plugin(app);

//在 thePlugin.js 中
module.exports = function plugin(app) {
  app.get(&#39;/newRoute&#39;, function (req, res) { ...
  })
};
</code></pre>

<ul>
<li><code>Application-controlled extension</code></li>
</ul>

<pre><code class="language-js">//在 app.js 中的代码
const app = express();
const plugin = require(&#39;thePlugin&#39;)();
app[plugin.method](plugin.route, plugin.handler); 

//在 thePlugin.js 中的代码
module.exports = function plugin() {
  return {
    method: &#39;get&#39;,
    route: &#39;/newRoute&#39;,
    handler: function (req, res) { ...
    }
  }
}
</code></pre>

<p><code>Plugin-controlled</code> 与 <code>Application-controlled extension</code>的区别:</p>

<ul>
<li><code>Plugin-controlled</code>模式的设计更直观, 而且能更好地扩展插件的功能</li>
<li><code>Application-controlled extension</code>模式依赖于主框架提供能添加插件的API</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15093607735574.html">JavaScript高级程序设计 · 1、2、3、20章</a></h1>
			<p class="meta"><time datetime="2017-10-30T18:52:53+08:00" 
			pubdate data-updated="true">2017/10/30 18:52 下午</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">第一章 JavaScript简介</h2>

<p>JavaScript 与 ECMAScript 的关系<br/>
<img src="media/15093607735574/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%888.13.13.png" alt="屏幕快照 2017-10-30 下午8.13.13"/></p>

<p>完整的<code>JavaScript</code>标准由一下三部分组成</p>

<ul>
<li>核心(<code>ECMAScript</code>)</li>
<li>文档对象模型(<code>DOM</code>)</li>
<li>浏览器对象模型(<code>BOM</code>)</li>
</ul>

<h3 id="toc_1">ECMAScript</h3>

<p><code>ECMAScript</code>是一门语言, 由<code>ECMA-262</code>标准定义, ECMA-262标准规定了这门语言的以下组成部分:</p>

<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象</li>
</ul>

<p>而<code>JavaScript</code>实现并扩展了<code>ECMAScript</code></p>

<h5 id="toc_2">ECMAScript兼容</h5>

<p><code>ECMA-262</code>标准给出了<code>ECMAScript</code>兼容的定义</p>

<ol>
<li>支持<code>ECMA-262</code>描述的所有<strong>类型</strong>, <strong>值</strong>, <strong>对象</strong>, <strong>属性</strong>, <strong>函数</strong>以及<strong>程序句法</strong>和<strong>语义</strong></li>
<li>支持<code>Unicode</code>字符标准</li>
</ol>

<h3 id="toc_3">文档对象模型(DOM)</h3>

<p><code>DOM</code>是针对<code>XML</code>或<code>HTML</code>的应用程序编程接口, <code>DOM</code>把文档中各个节点映射成树形对象.</p>

<h4 id="toc_4">DOM级别</h4>

<h5 id="toc_5">DOM1级</h5>

<ul>
<li><code>DOM核心</code>: 规定如<strong>映射</strong>何基于<code>XML</code>的文档结构, 以便简化对文档中任意部分的访问和操作</li>
<li><code>DOM HTML</code>: 在<code>DOM核心</code>基础上加以扩展, 添加了针对<code>HTML</code>的对象和方法</li>
</ul>

<h5 id="toc_6">DOM2级</h5>

<ul>
<li><code>DOM视图</code>: 定义了跟踪不同文档(如,应用CSS之前和之后的文档)视图的接口.</li>
<li><code>DOM事件</code>: 定义了事件和事件处理的接口</li>
<li><code>DOM样式</code>: 定义了基于CSS为元素应用样式的接口</li>
<li><code>DOM遍历和范围</code>: 定义了遍历和操作文档树的接口</li>
</ul>

<h5 id="toc_7">DOM3级</h5>

<ul>
<li><code>DOM加载和保存</code>: 引入统一方式加载和保存文档的方式</li>
<li><code>DOM验证</code>: 定义了验证文档的方法</li>
</ul>

<h3 id="toc_8">浏览器对象模型(BOM)</h3>

<p>由于不存在BOM标准, 习惯上将所有针对浏览器的JavaScript扩展算作BOM的一部分</p>

<ul>
<li>弹出新浏览器窗口的功能</li>
<li>移动、缩放和关闭浏览器窗口的功能</li>
<li>提供浏览器详细信息的<code>navigator</code>对象</li>
<li>提供浏览器所加载页面的详细信息的<code>location</code>对象</li>
<li>提供用户显示器分辨率详细信息的<code>screen</code>对象</li>
<li>对<code>cookies</code>的支持</li>
<li>像<code>XMLHttpRequest</code>和IE的<code>ActiveXObject</code>这样的自定义对象</li>
</ul>

<h3 id="toc_9">总结</h3>

<p>JavaScript由下列三个不同的部分组成</p>

<ul>
<li><code>ECMAScript</code>, 有<code>ECMA-262</code>定义, 提供核心语言功能</li>
<li>文档对象模型(DOM), 提供访问和操作网页内容的方式和接口</li>
<li>浏览器对象模型(BOM), 提供与浏览器交互的方法和接口</li>
</ul>

<hr/>

<h2 id="toc_10">第二章 在HTML中使用JavaScript</h2>

<h3 id="toc_11"><code>&lt;script&gt;</code>元素</h3>

<p>向<code>HTML</code>页面插入<code>JavaScript</code>的主要方法是使用<code>&lt;script&gt;</code>元素, <code>HTML 4.01</code>规范为其定义了下列6个属性</p>

<ul>
<li><code>async</code>:可选. 表示应该立即下载脚本, 但不应在下载期间阻塞其他操作</li>
<li><code>charset</code>:可选. 表示通过<code>src</code>属性指定的代码的字符集.</li>
<li><code>defer</code>:可选. 表示脚本可以延迟到文档完全被解析和显示之后再执行.只对外部脚本文件有效</li>
<li><code>src</code>: 可选. 表示包含要执行代码的外部文件</li>
<li><code>language</code>: 已废弃.</li>
<li><code>type</code>: 可选. 表示编写代码使用的脚本语言和内容类型.默认值为<code>type/javascript</code></li>
</ul>

<p>使用<code>&lt;script&gt;</code>的两种方式:</p>

<p>1.直接在<code>&lt;script&gt;</code>元素嵌入JavaScript代码</p>

<pre><code class="language-js">&lt;script&gt;
    function sayHi() {
        alert(&quot;Hi!&quot;);
    }
&lt;/script&gt;
</code></pre>

<p>2.通过<code>src</code>属性引入外部<code>JavaScript</code>文件</p>

<pre><code class="language-js">&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
或者
&lt;script src=&quot;example.js&quot; /&gt;
</code></pre>

<p>需要注意的是, 带有<code>src</code>属性的<code>&lt;script&gt;</code>元素不应在其<code>&lt;script&gt;</code>he<code>&lt;/script&gt;</code>之前再嵌入额外的代码.如果包含了额外的代码, 那么只会下载执行外部文件, 嵌入的代码会被忽略.</p>

<h4 id="toc_12">放置<code>&lt;script&gt;</code>标签的位置</h4>

<ul>
<li>放置于<code>&lt;head&gt;</code>元素中, 例如</li>
</ul>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example&lt;/title&gt;
        &lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p>这种做法是吧所有外部文件的引用都放在<code>&lt;head&gt;</code>元素中, 但是在<code>&lt;head&gt;</code>元素中包含所有<code>JavaScript</code>文件, 意味着必须等到全部<code>JavaScript</code>代码都被下载、解析和执行完成后, 才能开始呈现页面的内容. 从而导致可能出现明显的延迟.</p>

<ul>
<li>放置在<code>&lt;body&gt;</code>元素中</li>
</ul>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这样, 在解析包含的<code>JavaScript</code>代码之前, 页面内容将完全呈现在浏览器中.</p>

<h4 id="toc_13">延迟脚本(<code>defer</code>属性)</h4>

<p>当<code>&lt;script&gt;</code>中定义了<code>defer</code>属性后, 脚本在执行时不会影响页面的构造, 也就是说, 脚本会被延迟到整个页面都解析完毕后在运行.</p>

<p>在<code>HTML5</code>规范中, 要求脚本按照它们出现的先后顺序执行, 而这些延迟执行脚本会先于<code>DOMContentLoaded</code>事件执行. 但在实际实现中, 延迟脚本不一定会完全遵从此标准, 因此最好只包含一个延迟脚本.</p>

<p>并且, 延迟脚本只适用于外部脚本.</p>

<h4 id="toc_14">异步脚本(<code>async</code>属性)</h4>

<p><code>async</code>属性与<code>defer</code>属性类似, 旨在改变处理脚本的行为, 目的是为了不让页面脚本的下载和执行, 但<code>async</code>属性不确保多个脚本文件之间的执行顺序.</p>

<h4 id="toc_15">嵌入代码与外部文件</h4>

<p>在使用<code>&lt;script&gt;</code>标签时, 应该倾向于使用外部文件, 使用外部文件由如下优点</p>

<ul>
<li><strong>可维护性</strong> : 使用嵌入代码时, <code>JavaScript</code>代码分散在多个<code>HTML</code>页面中, 容易造成维护困难. 而使用外键可以将所有<code>JavaScript</code>文件都放在用一个文件夹中.</li>
<li><strong>可缓存</strong> : 浏览器能够跟去外部脚本文件的位置, 将相同的文件缓存下来, 从而加快未来页面的加载速度.</li>
</ul>

<hr/>

<h2 id="toc_16">第三章 基本概念</h2>

<h3 id="toc_17">语法</h3>

<ul>
<li>区分大小写</li>
<li>标识符

<ul>
<li>第一个字符必须是一个字母、下划线(<code>_</code>)或是美元符号(<code>$</code>)</li>
<li>其他字符可以是字母、下划线、美元符号或数字</li>
<li>建议使用驼峰命名法</li>
</ul></li>
<li>注释</li>
</ul>

<pre><code class="language-js">// 单行注释

/*
 * 这是一个多行
 * 注释
 */
</code></pre>

<ul>
<li>严格模式: ES5中引入了严格模式的概念, 在该模式下, ES3中一些不确定的行为将得到处理, 尔对于某系不安全的操作也会抛出错误. 使用严格模式只需在脚本文件顶部加入<code>&quot;use strict&quot;;</code></li>
</ul>

<h3 id="toc_18">数据类型</h3>

<h4 id="toc_19"><code>typeof</code>操作符</h4>

<p><code>typeof</code>操作符用于检测变量的数据类型, 对一个值使用<code>typeof</code>操作符可能返回下列某个字符串</p>

<ul>
<li><code>undefined</code>, 表示这个值未定义</li>
<li><code>boolean</code>, 表示这是个布尔值</li>
<li><code>string</code>, 字符串</li>
<li><code>number</code>, 数值</li>
<li><code>object</code>, 对象或<code>null</code></li>
<li><code>function</code>, 函数</li>
</ul>

<h4 id="toc_20">Undefined 类型</h4>

<p>已声明但未对其初始化的值为<code>undefined</code></p>

<pre><code class="language-js">let msg;
console.log(msg) // undefined
console.log(msg === undefined); // true
</code></pre>

<p>对未声明的变量使用<code>typeof</code>也会返回<code>undefined</code></p>

<pre><code class="language-js">console.log(typeof age) // undefined
</code></pre>

<h4 id="toc_21">Null 类型</h4>

<p><code>null</code>表示一个空对象指针, 所以对其使用<code>typeof</code>操作符时会返回<code>object</code>.<br/>
由于<code>undefined</code>派生自<code>null</code>值, <code>ECMA-262</code>规定对他们的相等性测试要返回<code>true</code></p>

<pre><code class="language-js">console.log(null == undefined); // true
</code></pre>

<h4 id="toc_22">Boolean 类型</h4>

<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为<code>true</code>的值</th>
<th>转换为<code>false</code>的值</th>
</tr>
</thead>

<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>&quot;&quot;(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>/</td>
<td>undefined</td>
</tr>
</tbody>
</table>

<h4 id="toc_23">Number 类型</h4>

<ul>
<li>进制表示</li>
</ul>

<pre><code class="language-js">let intNum   = 35;    十进制整数
let octalNum = 070;   八进制整数
let hexNum   = 0x1f;  十六进制整数
</code></pre>

<ul>
<li>浮点数</li>
</ul>

<pre><code class="language-js">let floatNum1 = 1.1;
let floatNum2 = .1; // 表示0.1, 但不推荐

let floatNum3 = 1.; // 小数点后没有数字, 解析为整数1
let floatNum4 = 10.0; // 整数, 解析为10

Number.isInteger(1.) // true
Number.isInteger(10.0) // true

// 科学计数法
let floatNum5 = 3.14e2 // 整数, 3.14乘以10的平方, 314
</code></pre>

<p>由于浮点数值的最高进度是17位小数, 在进行算数计算时会出现精度问题, 例如, <code>0.1 + 0.2</code>答案并不是<code>0.3</code>, 而是<code>0.30000000000000004</code>, 所以, <strong>不要对特定的浮点数值进行测试</strong></p>

<ul>
<li>数值范围</li>
</ul>

<p><code>ECMAScript</code>能表示的数值范围在<code>Number.MIN_VALUE</code>与<code>Number.MAX_VALUE</code>之间, 在Chrome中, <code>Number.MIN_VALUE = 5e-324</code>, 而<code>Number.MAX_VALUE = 1.7976931348623157e+308</code>, 超出这个范围的数值会被转化成特殊的<code>Infinity</code>值, 如果这个数是负数,则会被转换成<code>-Infinity</code>.<br/>
要确定一个数是不是<strong>有穷</strong>的, 可以使用<code>isFinite()</code>函数</p>

<pre><code class="language-js">isFinite(Number.MAX_VALUE + Number.MAX_VALUE) // false
</code></pre>

<ul>
<li><code>NaN(Not a Number)</code></li>
</ul>

<p>用于表示要返回数值的操作数未返回数值的情况, 任何涉及<code>NaN</code>的算数操作都会返回<code>NaN</code>, 其次<code>NaN</code>与任何数值都不相等, 包括<code>NaN</code>本身</p>

<pre><code class="language-js">NaN ==  NaN // false
NaN === NaN // false
</code></pre>

<p>可以使用<code>isNaN()</code>函数判断一个参数是否&quot;不是数值&quot;</p>

<pre><code class="language-js">isNaN(NaN)    // true
isNaN(10)     // false
isNaN(&quot;10&quot;)   // false, &quot;10&quot;可被转换成数值10
isNaN(&quot;blue&quot;) // true, 不能被转换成数值
isNaN(true)   // false 可被转换成数值1
</code></pre>

<ul>
<li>数值转换</li>
</ul>

<p>将非数值转换为数值有三个函数:</p>

<ul>
<li><code>Number()</code>, 可用于任何数据类型, 转换规则如下

<ul>
<li>如果是<code>Boolean</code>值, <code>true</code>和<code>false</code>将分别被转换为<code>1</code>和<code>0</code><br/></li>
<li>如果是数字值, 简单的传入和返回</li>
<li>如果是<code>null</code>值, 返回0</li>
<li>如果是<code>undefined</code>, 返回<code>NaN</code></li>
<li>如果是字符串, 则遵循下列规则

<ul>
<li>如果字符串中只包含数字, 则直接转换为十进制数, 并忽略前导0</li>
<li>如果字符串包含有成效的浮点格式, 则转换为对应的浮点数值</li>
<li>如果字符串中包含有效的十六进制格式, 则将其转换为相同大小的十进制数值</li>
<li>对于空字符串, 转换为0</li>
<li>包含上述格式以外的字符, 转换为<code>NaN</code></li>
</ul></li>
<li>如果是对象, 则调用对象的<code>valueOf()</code>方法, 并将返回值按照前面的规则转换.如果转换的结果是<code>NaN</code>, 则调用对象的<code>toString()</code>方法, 然后再依照前面的规则返回转换的字符串值.</li>
</ul></li>
<li><code>parseInt()</code>, 将字符串转换为整数.</li>
<li><code>parseFloat()</code> , 将字符串转换为浮点数.</li>
</ul>

<h4 id="toc_24">String 类型</h4>

<ol>
<li><code>EMCAScript</code>支持使用双引号和单引号表示字符串.</li>
<li>字符串不可变</li>
<li>通过调用对象的<code>toString()</code>方法获得对象的字符串表示.</li>
<li><code>null</code>和<code>undefined</code>没有<code>toString()</code>方法</li>
</ol>

<p><code>String()</code>函数也能用于将变量转换为字符串,并遵从下列转换规则</p>

<ul>
<li>如果值有<code>toString()</code>方法, 则调用该方法并返回相应结果</li>
<li>如果值是<code>null</code>, 则返回<code>&quot;null&quot;</code></li>
<li>如果值是<code>undefined</code>, 则返回<code>&quot;undefined&quot;</code></li>
</ul>

<h4 id="toc_25">Object 类型</h4>

<p>每个<code>Object</code>都有下列属性和方法:</p>

<ul>
<li><code>Constructor</code>, 构造函数</li>
<li><code>hasOwnProperty(propertyName)</code>, 用于检查给定对象实例中是否存在<code>propertyName</code>的属性.</li>
<li><code>isPrototypeOf(object)</code>, 用于检测传入的对象是否是另一个对象的原型.</li>
<li><code>propertIsEnumerable(propertyName)</code>, 用于检查给定的属性是否能够使用<code>for-in</code>语句来枚举.</li>
<li><code>toString()</code>, 返回对象的字符串表示.</li>
<li><code>valueOf()</code>, 返回对象的字符串,数值,或布尔值表示.</li>
</ul>

<h3 id="toc_26">操作符</h3>

<p>需要注意的几种操作符</p>

<ul>
<li><p>位操作符, <code>ECMAScript</code>中所有数值都已<code>IEEE-756 64位</code>格式存储, 但位操作符并不直接操作64位的值.而是先将<strong>64位的值转换为32位的整数, 然后执行操作, 最后将结果转换回64位的值</strong></p></li>
<li><p>相等操作符</p>

<ul>
<li>全等操作符(<code>===</code>), 只在两个操作数在<strong>未经转换</strong>就相等的情况下返回<code>true</code></li>
<li>不全等操作符(<code>==</code>), 会对操作数进行转换后比较.</li>
</ul></li>
</ul>

<h3 id="toc_27">函数</h3>

<ol>
<li>参数, ES中并不在乎函数的参数个数和参数列表, 即使函数定义了两个参数, 也未必一定要传入两个参数, 因为参数在内部是用<strong>一个数组</strong>来表示的, 函数接收到的始终都是这个数组(<code>arguments</code>)</li>
<li>重载, 由于ES中并不在意函数的参数类型和葛叔, ES中没有重载的概念, 如果同时定义了两个名字相同的函数, 则改名字只属于后定义的函数.</li>
</ol>

<hr/>

<h2 id="toc_28">第二十章 JSON</h2>

<p>JSON语法可以表示一下三种类型:</p>

<ul>
<li><code>简单值</code>: 适用于JavaScript相同的语法, 可以在JSON中表示字符串、数值、布尔值和<code>null</code>. 但不支持<code>undefined</code>.</li>
<li><code>对象</code>: 一组有序的键值对, 每个键值对的值可以简单值, 也可以是复杂数据类型的值.</li>
<li><code>数组</code>: 表示一组有序的值的列表.</li>
</ul>

<h3 id="toc_29">序列化</h3>

<p>在序列化JavaScript对象时, 所有的函数及原型成员都会被忽略, 并且值为<code>undefined</code>的属性也会被跳过.</p>

<h4 id="toc_30">序列化选项</h4>

<ul>
<li>过滤结果</li>
</ul>

<p>如果过滤器参数是数组, 那么 <code>JSON.stringify()</code>的结果中将只包含数组中列出的属性, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    }
JSON.stringify(book, [&quot;title&quot;])
// 输出结果: &#39;{&quot;title&quot;:&quot;hello world&quot;}&#39;
</code></pre>

<p>如果过滤器参数是函数, 那么会讲对象中属性和值传入签名为<code>function (key, value)</code>的函数, 并且将函数的返回值作为相对应键的值, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    }
JSON.stringify(book, function(key, value) {
    if (key === &quot;year&quot;)
        return 5000;
    return value;    
})
// 输出结果:&#39;{&quot;title&quot;:&quot;hello world&quot;,&quot;edition&quot;:3,&quot;year&quot;:5000}&#39;
</code></pre>

<ul>
<li>字符串缩进与空白符</li>
</ul>

<p><code>JSON.stringify()</code>函数的第三个参数用于控制结果中的缩进和空白符, 例如</p>

<pre><code class="language-js">console.log(JSON.stringify(book, null, 4))
/* 打印出结果
 * {
 * &quot;title&quot;: &quot;hello world&quot;,
 * &quot;edition&quot;: 3,
 * &quot;year&quot;: 2011
 * }
 */
 console.log(JSON.stringify(book, null, &quot;--&quot;))
/* 打印出结果
 * {
 * --&quot;title&quot;: &quot;hello world&quot;,
 * --&quot;edition&quot;: 3,
 * --&quot;year&quot;: 2011
 * }
 */
 
</code></pre>

<ul>
<li><code>toJSON()</code>方法</li>
</ul>

<p><code>JSON.stringify()</code>会调用对象上的<code>toJSON()</code>方法, 从而可以满足对某些对象的自定义序列化需求, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    toJSON: function(){
        return this.title
        }
    }
JSON.stringify(book) // &quot;hello world&quot;
</code></pre>

<h4 id="toc_31">解析选项</h4>

<p><code>JSON.parse()</code>也可以接收第二个参数, 该参数是一个函数, 将在每对键值对上调用, 与序列化时的函数过滤器类似, 例如</p>

<pre><code class="language-js">let book = {
    title: &#39;hello world&#39;,
    edition: 3,
    year: 2011,
    releaseDate: new Date()
};

let bookJSON = JSON.stringify(book);

console.log(JSON.parse(bookJSON));

console.log(JSON.parse(bookJSON, function(key, value) {
    if (key === &#39;releaseDate&#39;)
        return new Date(value);
    return value;
}))
</code></pre>

<p>运行结果<br/>
<img src="media/15093607735574/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-01%20%E4%B8%8B%E5%8D%886.06.06.png" alt="屏幕快照 2017-11-01 下午6.06.06"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15087314678145.html">Node.js设计模式 · 第六章</a></h1>
			<p class="meta"><time datetime="2017-10-23T12:04:27+08:00" 
			pubdate data-updated="true">2017/10/23 12:4 下午</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Design Patterns</h2>

<blockquote>
<p>经典设计模式在JS中的实现与应用</p>
</blockquote>

<h2 id="toc_1">摘要</h2>

<ul>
<li>Factory</li>
<li>Revealing constructor pattern</li>
<li>Proxy</li>
<li>Decorator</li>
<li>Adapter</li>
<li>Strategy</li>
<li>State</li>
<li>Template</li>
<li>Middleware</li>
<li>Command</li>
</ul>

<h3 id="toc_2">Factory</h3>

<blockquote>
<p>工厂模式</p>
</blockquote>

<p>经典工厂模式, 根据不同参数返回不同的示例</p>

<pre><code class="language-js">// Image 基类
class Image {
  constructor(path) {
    this.path = path;
  }
};
// 继承自 Image, 用于表示 Gif 图像
class ImageGif extends Image {
  constructor(path) {
    if (!path.match(/\.gif/)) {
      throw new Error(`${path} is not a GIF image`);
    }
    super(path);
  }
};
// 继承自 Image, 用于表示 Jpg 图像
class ImageJpg extends Image {
  constructor(path) {
    if (!path.match(/\.jpe?g$/)) {
      throw new Error(`${path} is not a JPEG image`);
    }
    super(path);
  }
};
// 继承自 Image, 用于表示 Png 图像
class ImagePng extends Image {
  constructor(path) {
    if (!path.match(/\.png$/)) {
      throw new Error(`${path} is not a PNG image`);
    }
    super(path);
  }
};
// 工厂函数, 根据不同的文件名创建相应的图像实例
function createImage(name) {
  if(name.match(/\.jpe?g$/)) {
    return new ImageJpeg(name);
  } else if(name.match(/\.gif$/)) {
    return new ImageGif(name);
  } else if(name.match(/\.png$/)) {
    return new ImagePng(name);
  } else {
    throw new Exception(&#39;Unsupported format&#39;);
  }
}
</code></pre>

<h4 id="toc_3">A mechanism to enforce encapsulation</h4>

<blockquote>
<p>利用工厂模式将封装性引入JavaScript</p>
</blockquote>

<ul>
<li>利用闭包特性, 对外部属性进行封装, 避免通过对象直接访问私有属性</li>
</ul>

<pre><code class="language-js">function createPerson(name) {
  // privateProperties 用于存放私有变量
  const privateProperties = {};
  // person 用于模拟类
  const person = {
    // 通过Getter 和 Setter访问外部
    // privateProperties属性
    setName: name =&gt; {
      if (!name) throw new Error(&#39;A person must have a name&#39;);
      privateProperties.name = name;
    },
    getName: () =&gt; {
      return privateProperties.name;
    }
  };
  
  person.setName(name);
  return person;
}
// 利用 createPerson 工厂函数创建person实例
const person = createPerson(&#39;James Joyce&#39;);
console.log(person.getName(), person);
</code></pre>

<h4 id="toc_4">Composable factory functions</h4>

<blockquote>
<p>利用第三方库<code>stampit</code>创建及组合工厂函数</p>
</blockquote>

<p>这章节里将一个对象的各种元素, 例如属性, 方法, 拆分为多个模块, 最后将他们组合起来, 利用工厂模式创建实例.</p>

<p><code>stampit</code>有几个主要方法用于创建模块化的类</p>

<ul>
<li><code>init(...args)</code>: 用于指示创建出的模块构造函数的参数</li>
<li><code>props(...args)</code>: 用于表示模块中拥有的属性</li>
<li><code>methods(...args)</code>: 用于表示模块中拥有的方法</li>
</ul>

<p>附上<code>stampit</code>的<a href="https://github.com/stampit-org/stampit/blob/master/docs/API.md">API</a>文档地址</p>

<p>使用示例:<br/>
   通过<code>stampit</code>组合创造出具有多种技能的人物.</p>

<pre><code class="language-js">const stampit = require(&#39;stampit&#39;);
// 创建角色模块
const character = stampit().
props({
  name: &#39;anonymous&#39;,
  lifePoints: 100,
  x: 0,
  y: 0
});
// mover, 具有移动的方法
const mover = stampit().
methods({
  move(xIncr, yIncr) {
    this.x += xIncr;
    this.y += yIncr;
    console.log(`${this.name} moved to [${this.x}, ${this.y}]`);
  }
});
// slasher, 类似于攻击的属性
const slasher = stampit().
methods({
  // 添加 slash 方法
  slash(direction) {
    console.log(`${this.name} slashed to the ${direction}`);
  }
});
// 射击
const shooter = stampit().
props({
  // 添加bullets属性
  bullets: 6
}).
methods({
  // 添加shoot方法
  shoot(direction) {
    if (this.bullets &gt; 0) {
      --this.bullets;
      console.log(`${this.name} shoot to the ${direction}`);
    }
  }
});
// 类似于多继承, 利用compose方法将多个特性组合起来
const runner = stampit.compose(character, mover);
const samurai = stampit.compose(character, mover, slasher);
const sniper = stampit.compose(character, shooter);
const gunslinger = stampit.compose(character, mover, shooter);
const westernSamurai = stampit.compose(gunslinger, samurai);

const gojiro = westernSamurai();
gojiro.name = &#39;Gojiro Kiryu&#39;;
gojiro.move(1, 0);
gojiro.slash(&#39;left&#39;);
gojiro.shoot(&#39;right&#39;);
</code></pre>

<p><code>stampit.compose</code>将多个模块组合起来, 创建出新的工厂方法, 与类的多继承类似.</p>

<h3 id="toc_5">Revealing constructor pattern</h3>

<blockquote>
<p>在构造函数中传入<code>executor</code>, 并在构造函数中马上执行</p>
</blockquote>

<p><code>Promise</code>就是<code>Revealing constructor pattern</code>的一种</p>

<pre><code class="language-js">const p = new Promise(function(resolve, reject){
    ...
})
</code></pre>

<p>在<code>Promise</code>被构造出来的那一刻, 传入构造函数的函数就会被马上执行, 并通过<code>resolve</code>和<code>reject</code>改变和传递<code>promise</code>的状态和结果</p>

<h4 id="toc_6">A read-only event emitter</h4>

<blockquote>
<p>构造一个以<code>Revealing constructor pattern</code>为原型的只读事件订阅类</p>
</blockquote>

<ul>
<li>创建<code>Roee(Read-only Event Emitter)</code></li>
</ul>

<pre><code class="language-js">const EventEmitter = require(&#39;events&#39;);

class Roee extends EventEmitter {
  constructor(executor) {
    super();
    // 保存emit函数
    const emit = this.emit.bind(this);
    // 将 this.emit 置为 undefined
    // 防止外部使用
    this.emit = undefined;
    // 执行executor
    // 只能在 executor 中执行 emit 函数
    executor(emit);
  }
};
</code></pre>

<ul>
<li>利用<code>Roee</code>创建一个<code>ticker</code></li>
</ul>

<pre><code class="language-js">const ticker = new Roee((emit) =&gt; {
  let tickCount = 0;
  // 每秒向 listener 发送 tickCount
  setInterval(() =&gt; emit(&#39;tick&#39;, tickCount++), 1000);
});

ticker.on(&#39;tick&#39;, (tickCount) =&gt; console.log(tickCount, &#39;TICK&#39;));
</code></pre>

<h3 id="toc_7">Proxy</h3>

<blockquote>
<p>代理模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-26%20%E4%B8%8B%E5%8D%885.47.55.png" alt="屏幕快照 2017-10-26 下午5.47.55"/></p>

<h4 id="toc_8">Techniques for implementing proxies</h4>

<blockquote>
<p>在JavaScript上实现代理模式的方法</p>
</blockquote>

<h5 id="toc_9">实现代理模式的技巧</h5>

<ul>
<li>利用操纵原型链的方法实现代理模式, 两个重要的方法

<ul>
<li><code>Object.getPrototypeOf</code>: 获取对象/实例的原型</li>
<li><code>Object.create</code>: 通过原型创建出新的对象, 常用于模拟类的继承</li>
</ul></li>
</ul>

<pre><code class="language-js">function createProxy(subject) {
  // 获取对象原型
  const proto = Object.getPrototypeOf(subject);
  // 创建 Proxy 类
  function Proxy(subject) {
    this.subject = subject;
  }
  // Proxy 继承 subject 的原型
  Proxy.prototype = Object.create(proto);
  // 代理 subject.hello 方法
  Proxy.prototype.hello = function(){
    return this.subject.hello() + &#39; world!&#39;;
  };
  
  // 返回代理对象实例
  return new Proxy(subject);
}

class Greeter {
  hello() {
    return &#39;Hello&#39;;
  }

  goodbye() {
    return &#39;Goodbye&#39;;
  }
}

const greeter = new Greeter();
const proxy = createProxy(greeter);

console.log(proxy.hello());
console.log(proxy.goodbye());
</code></pre>

<p>运行结果<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-26%20%E4%B8%8B%E5%8D%887.19.47.png" alt="屏幕快照 2017-10-26 下午7.19.47"/></p>

<h5 id="toc_10">ES6中的<code>Proxy</code>类</h5>

<p>ES6中提供了<code>Proxy</code>类, 这个<code>Proxy</code>与我们所说的代理模式并不是同一样事物, <code>Proxy</code>虽然实现了部分代理的特性, 但是更多是用于对<code>Object</code>的元编程中. </p>

<p><code>Proxy(target, handler)</code>, <code>Proxy</code>的构造函数, <code>target</code>表示需要被代理的类, <code>handler</code>用于设置代理行为.</p>

<p><code>handler</code>提供了相当多的属性用于描述代理的行为, 例如</p>

<ul>
<li><code>get</code>: 在读取对象中属性时调用</li>
<li><code>set</code>: 在写入对象属性时调用</li>
<li><code>has</code>: 对应<code>in</code>操作符</li>
</ul>

<p>等等方法用于对应语言层面的行为<br/>
使用示例:</p>

<pre><code class="language-js">const scientist = {
  name: &#39;nikola&#39;,
  surname: &#39;tesla&#39;
};

const uppercaseScientist = new Proxy(scientist, {
  // 修改读取对象内属性的行为
  // 对对象属性的值调用 toUpperCase() 并返回
  get: (target, property) =&gt; target[property].toUpperCase()
});
// 运行结果 NIKOLA TESLA
console.log(uppercaseScientist.name, uppercaseScientist.surname);
</code></pre>

<h3 id="toc_11">Decorator</h3>

<blockquote>
<p>装饰器模式</p>
</blockquote>

<p>相比起代理模式在原对象的方法进行行为的修改, 装饰器模式是在原对象上添加属性或方法.<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-26%20%E4%B8%8B%E5%8D%8811.00.29.png" alt="屏幕快照 2017-10-26 下午11.00.29"/></p>

<h4 id="toc_12">Techniques for implementing Decorators</h4>

<blockquote>
<p>在JavaScript上实现装饰器模式的方法</p>
</blockquote>

<h5 id="toc_13">实现装饰器模式的技巧</h5>

<p>与实现代理模式类似, 利用操纵原型链的方法为被代理实例添加方法</p>

<pre><code class="language-js">function decorate(component) {
  const proto = Object.getPrototypeOf(component);
  
  function Decorator(component) {
    this.component = component;
  }
  
  Decorator.prototype = Object.create(proto);
  
  //添加新方法
  Decorator.prototype.greetings = function() {
    return &#39;Hi!&#39;;
  };
  return new Decorator(component);
}

class Greeter {
  hello(subject) {
    return `Hello ${subject}`;
  }
}

const decoratedGreeter = decorate(new Greeter());
console.log(decoratedGreeter.hello(&#39;world&#39;));
console.log(decoratedGreeter.greetings());
</code></pre>

<h3 id="toc_14">Adapter</h3>

<blockquote>
<p>适配器模式<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-28%20%E4%B8%8B%E5%8D%888.22.45.png" alt="屏幕快照 2017-10-28 下午8.22.45"/></p>
</blockquote>

<p><code>Adapter</code>充当中间层, 模拟<code>Adaptee</code>的行为, 以减少对客户端代码原用于调用<code>Adaptee</code>部分的修改.</p>

<h4 id="toc_15">Techniques for implementing Adapters</h4>

<blockquote>
<p>适配器模式在JavaScript并没有什么需要用到元编程技巧的地方</p>
</blockquote>

<p>本节展示了一个用于模拟<code>fs</code>模块的<code>Adapter</code>, 而<code>Adapter</code>内部将<code>fs</code>主要方法重定向至访问数据库,并模拟<code>fs</code>模块的行为</p>

<pre><code class="language-js">module.exports = function createFsAdapter(db) {
  const fs = {};
  // 模拟 fs.readFile 函数
  fs.readFile = (filename, options, callback) =&gt; {
    // 处理 callback come last
    if (typeof options === &#39;function&#39;) {
      callback = options;
      options = {};
    } else if(typeof options === &#39;string&#39;) {
      options = {encoding: options};
    }
    // 通过 path.resolve 处理文件路径
    // 从数据库中获取文件数据
    db.get(path.resolve(filename), {
        valueEncoding: options.encoding
      },
      // 传入 callback
      (err, value) =&gt; {
        if(err) {
          // 模拟fs模块的异常信息
          if(err.type === &#39;NotFoundError&#39;) {
            err = new Error(`ENOENT, open &quot;${filename}&quot;`);
            err.code = &#39;ENOENT&#39;;
            err.errno = 34;
            err.path = filename;
          }
          return callback &amp;&amp; callback(err);
        }
        callback &amp;&amp; callback(null, value);
      }
    );
  };
  // 模拟fs.writeFile
  fs.writeFile = (filename, contents, options, callback) =&gt; {
    if(typeof options === &#39;function&#39;) {
      callback = options;
      options = {};
    } else if(typeof options === &#39;string&#39;) {
      options = {encoding: options};
    }
    // 同样通过path.resolve解析文件路径
    // 将文件放入数据库中
    db.put(path.resolve(filename), contents, {
      valueEncoding: options.encoding
    }, callback);
  };
  // 返回包装后的文件模块
  return fs;
};
</code></pre>

<h3 id="toc_16">Strategy</h3>

<blockquote>
<p>策略模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%8812.16.50.png" alt="屏幕快照 2017-10-29 下午12.16.50"/></p>

<p>策略模式对外暴露相同的接口, 但对于不同类型的数据, 客户端可以选择不同的处理策略.</p>

<h4 id="toc_17">Techniques for implementing Strategy</h4>

<p>这一节展示利用策略模式, 对不同格式的配置文件<code>ini</code>及<code>json</code>进行读取和写入</p>

<pre><code class="language-js">const fs = require(&#39;fs&#39;);
const ini = require(&#39;ini&#39;);
const objectPath = require(&#39;object-path&#39;);

class Config {
  // 构造方法处传入需要使用的策略对象
  constructor(strategy) {
    // 存放解析成对象后的配置
    this.data = {};
    // 用于存放策略对象, 对象需要实现 deserialize 及 serialize 方法
    this.strategy = strategy;
  }

  get(path) {
    // 获取对象内对应路径的数据
    return objectPath.get(this.data, path);
  }

  set(path, value) {
    // 设置对象内对应路径的数据
    return objectPath.set(this.data, path, value);
  }

  read(file) {
    console.log(`Deserializing from ${file}`);
    // 根据不同的策略, 使用不同的解析器对配置文件进行解析
    this.data = this.strategy.deserialize(fs.readFileSync(file, &#39;utf-8&#39;));
  }

  save(file) {
    console.log(`Serializing to ${file}`);
    fs.writeFileSync(file, this.strategy.serialize(this.data));
  }
}

strategies = {};
// 用于解析JSON文件的策略
strategies.json = {
  deserialize: data =&gt; JSON.parse(data),
  serialize: data =&gt; JSON.stringify(data, null, &#39;  &#39;)
};
// 用于解析INI文件的策略
strategies.ini = {
  deserialize: data =&gt; ini.parse(data),
  serialize: data =&gt; ini.stringify(data)
};
</code></pre>

<h3 id="toc_18">State</h3>

<blockquote>
<p>状态模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%8812.55.39.png" alt="屏幕快照 2017-10-29 下午12.55.39"/><br/>
上面的策略模式选择策略的方式是开发者根据状况,在编写代码时选择不同的策略<br/>
而状态模式是将对象编写成<strong>自动</strong>根据上下文去改变处理策略.</p>

<h4 id="toc_19">Techniques for implementing State</h4>

<p>本节展示一种自动切换状态的<code>socket</code>, 通过tcp协议传输JSON, 在连接失败时切换至<code>offline</code>状态, 并存储下需要发送的数据, 在连接成功时切换至<code>online</code>状态.</p>

<ul>
<li><code>offlineState</code>,用于处理连接断开时的状态</li>
</ul>

<pre><code class="language-js"> class OfflineState {

  constructor(failsafeSocket) {
    this.failsafeSocket = failsafeSocket;
  }

  send(data) {
    // 连接断开时无法发送数据
    // 利用 queue 暂存数据
    this.failsafeSocket.queue.push(data);
  }

  activate() {
    // retry 函数
    const retry = () =&gt; {
      setTimeout(() =&gt; this.activate(), 500);
    };
    // 连接到对端 socket
    this.failsafeSocket.socket = jot.connect(
      this.failsafeSocket.options,
      () =&gt; {
        // 连接完成时移除可能未被触发的 retry listener
        this.failsafeSocket.socket.removeListener(&#39;error&#39;, retry);
        // 连接完成时切换至 online 状态
        this.failsafeSocket.changeState(&#39;online&#39;);
      }
    );
    // 订阅 error 事件
    this.failsafeSocket.socket.once(&#39;error&#39;, retry);
  }
};
</code></pre>

<ul>
<li><code>onlineState</code>, 处理连接成功时正常发送数据的状态</li>
</ul>

<pre><code class="language-js">class OnlineState {
  constructor(failsafeSocket) {
    this.failsafeSocket = failsafeSocket;
  }

  send(data) {
    this.failsafeSocket.socket.write(data);
  };

  activate() {
    // 遍历并发送处于 offline 状态时未发送完成的数据
    this.failsafeSocket.queue.forEach(data =&gt; {
      this.failsafeSocket.socket.write(data);
    });
    // 清空队列
    this.failsafeSocket.queue = [];
    // 订阅 error 事件
    // 出现异常时切换至 offline 状态
    this.failsafeSocket.socket.once(&#39;error&#39;, () =&gt; {
      this.failsafeSocket.changeState(&#39;offline&#39;);
    });
  }
};
</code></pre>

<ul>
<li><code>FailsafeSocket</code>, 整合<code>online</code>与<code>offline</code>两种状态</li>
</ul>

<pre><code class="language-js">class FailsafeSocket {
  constructor(options) {
    this.options = options;
    this.queue = [];
    this.currentState = null;
    this.socket = null;
    this.states = {
      // FailsafeSocket 所具有的两种状态
      offline: new OfflineState(this),
      online: new OnlineState(this)
    }; 
    // 初始状态为 offline
    this.changeState(&#39;offline&#39;);
  }

  changeState(state) {
    console.log(&#39;Activating state: &#39; + state);
    this.currentState = this.states[state];
    // 激活状态对应的处理器
    this.currentState.activate();
  }

  send(data) {
    // 通过当前状态处理器发送数据
    this.currentState.send(data);
  }
}
</code></pre>

<h3 id="toc_20">Template</h3>

<blockquote>
<p>模板模式</p>
</blockquote>

<p>与C++中重写父类虚方法类似, JS中模板模式中, 通过继承模板类并重写模板方法.</p>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8A%E5%8D%8810.51.43.png" alt="屏幕快照 2017-10-30 上午10.51.43"/></p>

<h4 id="toc_21">Techniques for implementing Template</h4>

<p>以文件配置解析器为例, 留下<code>_serialize</code>与<code>_deserialize</code>给子类实现</p>

<pre><code class="language-js">const fs = require(&#39;fs&#39;);
const objectPath = require(&#39;object-path&#39;);

class ConfigTemplate {
  read (file) {
    console.log(`Deserializing from ${file}`);
    // 调用虚方法解析配置文件
    this.data = this._deserialize(fs.readFileSync(file, &#39;utf-8&#39;));
  }

  save (file) {
    console.log(`Serializing to ${file}`);
    // 调用虚方法序列化配置文件
    fs.writeFileSync(file, this._serialize(this.data));
  }

  get (path) {
    return objectPath.get(this.data, path);
  }

  set (path, value) {
    return objectPath.set(this.data, path, value);
  }

  _serialize () {
    // 如果子类未实现虚方法则抛出错误
    throw new Error(&#39;_serialize() must be implemented&#39;);
  }

  _deserialize () {
    throw new Error(&#39;_deserialize() must be implemented&#39;);
  }
}
</code></pre>

<ul>
<li>子类继承模板类并重写模板方法</li>
</ul>

<pre><code class="language-js">class JsonConfig extends ConfigTemplate {

  _deserialize (data) {
    return JSON.parse(data);
  };

  _serialize (data) {
    return JSON.stringify(data, null, &#39;  &#39;);
  }
}
</code></pre>

<h3 id="toc_22">Middleware</h3>

<blockquote>
<p>中间件模式</p>
</blockquote>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%8812.44.47.png" alt="屏幕快照 2017-10-30 下午12.44.47"/></p>

<p>中间件模式利用中间件管理器(<code>Middleware Manager</code>), 链式传递输入, 通过多个中间件过滤形成输出.</p>

<p>以<code>koa</code>框架为例, 通过<code>app.use</code>传入一个<code>async函数</code>作为中间件处理并输出HTTP请求</p>

<p>在<code>koa</code>中, 中间件函数的签名应该为<code>async functiong(ctx, next)</code>, 其中</p>

<ul>
<li><code>ctx</code>, 表示 <code>HTTP Response</code> 与 <code>HTTP Request</code></li>
<li><code>next</code>, 表示中间件链中下一个中间件</li>
</ul>

<p>以<code>koa</code>官方实例为例</p>

<pre><code class="language-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.use(async(ctx, next) =&gt; {
  // 记录开始时间
  const start = Date.now();
  // await 下一个中间件
  await next();
  // 记录处理结束时间
  const ms = Date.now() - start;
  // 将处理事件设置在HTTP Response头部
  ctx.set(&#39;X-Response-Time&#39;, `${ms}ms`);
});

app.use(async(ctx, next) =&gt; {
  // 记录开始时间
  const start = Date.now();
  // await 下一个中间件
  await next();
  // 记录处理结束时间
  const ms = Date.now() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}`);
});

app.use(async ctx =&gt; {
  // 设置 HTTP Response 的 Body
  ctx.body = &#39;Hello World&#39;;
});

app.listen(3000);
</code></pre>

<p>整个中间件执行顺序为</p>

<p><img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%881.12.05.png" alt="屏幕快照 2017-10-30 下午1.12.05"/></p>

<h3 id="toc_23">Command</h3>

<blockquote>
<p>命令模式</p>
</blockquote>

<p>命令模式通过将对 对象的操作包括对操作的回放, 撤销等 封装起来作为命令, 客户端只需执行该命令即可操纵目标对象<br/>
<img src="media/15087314678145/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%883.43.12.png" alt="屏幕快照 2017-10-30 下午3.43.12"/></p>

<ul>
<li><code>Client</code>:  命令的创建及通过<code>Invoker</code>执行命令的对象</li>
<li><code>Command</code>: 封装了对<code>Target</code>的执行命令</li>
<li><code>Invoker</code>: 缓存历史和向<code>Target</code>发送命令</li>
<li><code>Target</code>:  执行命令的对象</li>
</ul>

<p>通过命令模式执行操作而不是直接操作对象有以下优势</p>

<ul>
<li>命令可以被从新调整计划或是延后执行</li>
<li>命令可以被序列化然后通过网络传输</li>
<li>命令的执行历史可被保存, 并且在真正执行前可被撤销</li>
<li>由于命令可被缓存以及调整, 在某些算法中非常适合用于数据同步</li>
<li>多个命令可被组合, 执行过程可以被原子化</li>
</ul>

<h4 id="toc_24">Techniques for implementing Command</h4>

<p>本节展示一个简单的Map服务, 通过<code>Command</code>设置其中键值对</p>

<ul>
<li><code>Target</code>组件</li>
</ul>

<pre><code class="language-js">// Target对象
const statusUpdateService = {
  // 存储服务状态
  statusUpdates: {},
  // 模拟远程对象发送状态
  sendUpdate: function(status) {
    console.log(&#39;Status sent: &#39; + status);
    // 随机获取ID
    let id = Math.floor(Math.random() * 1000000);
    // 设置状态
    statusUpdateService.statusUpdates[id] = status;
    // 返回操作ID, 用于撤回操作
    return id;
  },
  // 根据ID撤回操作
  destroyUpdate: id =&gt; {
    console.log(&#39;Status removed: &#39; + id);
    delete statusUpdateService.statusUpdates[id];
  }
};
</code></pre>

<ul>
<li><code>Command</code>对象</li>
</ul>

<pre><code class="language-js">//封装命令参数的 Command 对象
function createSendStatusCmd(service, status) {
  let postId = null;
  // 创建Command对象
  const command = () =&gt; {
    postId = service.sendUpdate(status);
  };
  // undo方法用于撤销操作
  command.undo = () =&gt; {
    if(postId) {
      service.destroyUpdate(postId);
      postId = null;
    }
  };
  // 命令的序列化方法
  command.serialize = () =&gt; {
    return {type: &#39;status&#39;, action: &#39;post&#39;, status: status};
  };
  
  return command;
}
</code></pre>

<ul>
<li><code>Invoker</code>对象</li>
</ul>

<pre><code class="language-js">//Invoker 对象
class Invoker {
  constructor() {
    // 用于保存命令操作历史
    this.history = [];
  }

  run (cmd) {
    // 保存命令执行历史
    this.history.push(cmd);
    // 执行命令
    cmd();
    console.log(&#39;Command executed&#39;, cmd.serialize());
  }

  delay (cmd, delay) {
    // 延时执行命令
    setTimeout( () =&gt; {
      this.run(cmd);
    }, delay)
  }

  undo () {
    // 从命令历史中 pop出历史命令
    const cmd = this.history.pop();
    // 撤销命令
    cmd.undo();
    console.log(&#39;Command undone&#39;, cmd.serialize());
  }
  // 用于演示命令序列化并在远程执行
  runRemotely (cmd) {
    request.post(&#39;http://localhost:3000/cmd&#39;,
      {json: cmd.serialize()},
      err =&gt; {
        console.log(&#39;Command executed remotely&#39;, cmd.serialize());
      }
    );
  }
}
</code></pre>

<p>最后是作为<code>Client</code>, 通过<code>Invoker</code>执行命令</p>

<pre><code class="language-js">const invoker = new Invoker();
const command = createSendStatusCmd(statusUpdateService, &#39;HI!&#39;);
invoker.run(command);
invoker.delay(command, 1000 * 60 * 60);
invoker.undo();
invoker.runRemotely(command);
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15078961128669.html">Node.js设计模式 · 第五章</a></h1>
			<p class="meta"><time datetime="2017-10-13T20:01:52+08:00" 
			pubdate data-updated="true">2017/10/13 20:1 下午</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Coding with Streams</h2>

<blockquote>
<p>Stream作为Node.js中非常重要的概念, 在Node.js的官方库中有着广泛的体现(fs, socket, child_process等), 这一章将会阐述Stream的理念及使用方法</p>
</blockquote>

<h2 id="toc_1">摘要</h2>

<ul>
<li><code>Stream</code> 之于 <code>Node.js</code></li>
<li><code>Stream</code> 的使用方法</li>
</ul>

<h2 id="toc_2">Buffering versus streaming</h2>

<blockquote>
<p><code>Buffer</code> 与 <code>Stream</code> 的区别</p>
</blockquote>

<ul>
<li><code>Buffer</code>模式的特性</li>
</ul>

<p>大部分的异步API都是使用<code>Buffer</code>模式, 当数据<strong>接收完成</strong>的时候将它传递给<code>callback</code><br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8A%E5%8D%8810.39.50.png" alt="屏幕快照 2017-10-14 上午10.39.50"/></p>

<blockquote>
<p>在<code>t1</code>时刻, 系统仅收到<code>Hello N</code>几个字符, 还未收到一个完整的数据, 而在<code>t2</code>时刻系统接收到剩下的数据, 组成了完成的包<code>Hello Node.js</code>, 此时才把他提交给消费者</p>
</blockquote>

<p>特点: 使用<code>Buffer</code>模式的API在完成与未完成的状态之间有着完整的界限</p>

<ul>
<li><code>Stream</code>模式的特性</li>
</ul>

<p><code>Stream</code>模式与<code>Buffer</code>模式最大的不同是在<strong>接收到数据时, <code>Stream</code>模式的API会不断往消费者提交数据</strong><br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8A%E5%8D%8811.08.37.png" alt="屏幕快照 2017-10-14 上午11.08.37"/></p>

<blockquote>
<p>在<code>t1</code>时刻, 系统接收到了<code>Hello N</code>, 马上提交给消费者, 然后在接收到剩下的<code>ode.js</code>, 也马上提交到消费者</p>
</blockquote>

<p><code>Stream</code>相对于<code>Buffer</code>的优势</p>

<ul>
<li>更小的空间复杂度: <code>Buffer</code>需要开辟出一块空间用于存储接收到的数据, 在接收完毕时提交到消费者处, 而<code>Stream</code>在接收到数据后马上提交到消费者除, 空间的消耗小了很多.</li>
<li>更紧凑的时间: 相当于给后续函数提供了增量解析数据的可能性</li>
<li>可组合性: 利用<code>Stream</code>提供的<code>pipe</code>管道将多个流组合起来 </li>
</ul>

<h3 id="toc_3">Spatial efficiency</h3>

<p>V8引擎有一个限制, <code>buffer</code>大小在32位机器上不能大于<code>1GB - 1 Byte</code>, 64位系统上不能大于<code>2GB - 1 bytes</code>. (截止目前8.0版本)</p>

<p>下面给出两段代码, 演示<code>Buffer</code>与<code>Stream</code>两种不同风格下如何对文件进行压缩处理</p>

<h4 id="toc_4">Gzipping using a buffered API</h4>

<pre><code class="language-js">&quot;use strict&quot;;

const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

const file = process.argv[2];

// 读入文件
fs.readFile(file, (err, buffer) =&gt; {
  // 压缩文件
  zlib.gzip(buffer, (err, buffer) =&gt; {
    // 将压缩后文件写入硬盘
    fs.writeFile(file + &#39;.gz&#39;, buffer, err =&gt; {
      console.log(&#39;File successfully compressed&#39;);
    });
  });
});
</code></pre>

<p>在压缩大于2GB的文件时(测试环境: MacOS 10.13, 内存 16GB), 无法正确压缩文件</p>

<h4 id="toc_5">Gzipping using streams</h4>

<pre><code class="language-js">fs.createReadStream(file)
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream(file + &#39;.gz&#39;))
  .on(&#39;finish&#39;, () =&gt; console.log(&#39;File successfully compressed&#39;))
;
</code></pre>

<ul>
<li><code>fs.createReadStream</code>创建了具有<code>stream.Readable</code>特性的对象(<code>trait</code>)</li>
<li><code>zlib.createGzip</code>返回的<code>Gzip</code>实例具有<code>stream.Transform</code>的特性, 这个特性是同时具有可读和科协的流</li>
<li><code>fs.createWriteStream</code>创建了具有<code>stream.Writeable</code>特性的对象</li>
</ul>

<p>相当于<code>fs.createReadStream file | zlib.createGzip | fs.createWriteStream file.gz</code></p>

<p>由此突破了v8中对<code>Buffer</code>的限制, 经测试, 压缩大于2GB的文件并未出现问题</p>

<h3 id="toc_6">Time efficiency</h3>

<p>由于<code>Stream</code>能做到增量处理, 在时间的利用率上也非常有优势</p>

<p>设计一个CS服务</p>

<ul>
<li><code>Client</code> : 读取文件, 压缩文件, 发送文件</li>
<li><code>Server</code> : 接收文件, 解压文件, 保存文件</li>
</ul>

<p>如果这套逻辑采用<code>Buffer</code>模式实现, 读取,压缩,发送都要等待文件完成读入<code>Buffer</code>, 随后才能进行下一步操作, 虽然得益于<code>Node.js</code>的事件循环机制, 多个用户并不会因此阻塞, 但从单个用户来看, 处理时间变长了许多.</p>

<ul>
<li><code>Server</code> 的 <code>Stream</code> 模式实现</li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

// 创建HTTP服务
const server = http.createServer((req, res) =&gt; {
  // 从HTTP头部读取文件名
  const filename = req.headers.filename;
  console.log(&#39;File request received: &#39; + filename);
  req
    // 解压文件的流
    .pipe(zlib.createGunzip())
    // 创建写入文件的流
    .pipe(fs.createWriteStream(filename))
    .on(&#39;finish&#39;, () =&gt; {
      res.writeHead(201, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
      res.end(&#39;That\&#39;s it\n&#39;);
      console.log(`File saved: ${filename}`);
    });
});

server.listen(3000, () =&gt; console.log(&#39;Listening&#39;));

</code></pre>

<ul>
<li><code>Client</code> 的 <code>Stream</code> 模式实现 </li>
</ul>

<pre><code class="language-js">const options = {
  hostname: server,
  port: 3000,
  path: &#39;/&#39;,
  method: &#39;PUT&#39;,
  headers: {
    // 设置HTTP请求头部
    filename: path.basename(file),
    &#39;Content-Type&#39;: &#39;application/octet-stream&#39;,
    &#39;Content-Encoding&#39;: &#39;gzip&#39;
  }
};

const req = http.request(options, res =&gt; {
  console.log(&#39;Server response: &#39; + res.statusCode);
});
// 创建可写 Stream
fs.createReadStream(file)
  // 创建压缩文件的流
  .pipe(zlib.createGzip())
  // HttpClient 继承了 Stream.Writeable
  // 此处将压缩后的数据写入HTTP请求中
  .pipe(req)
  .on(&#39;finish&#39;, () =&gt; {
    console.log(&#39;File successfully sent&#39;);
  })
;
</code></pre>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-15%20%E4%B8%8B%E5%8D%887.19.51.png" alt="屏幕快照 2017-10-15 下午7.19.51"/></p>

<h3 id="toc_7">Composability</h3>

<blockquote>
<p>得益于<code>Stream</code>中的<code>pipe</code>方法, 多个流组合起来非常方便简洁</p>
</blockquote>

<p>对于上面的CS压缩文件传输模型, 加入加密传输功能对于<code>Stream</code>来说非常简单</p>

<ul>
<li><code>Client</code></li>
</ul>

<pre><code class="language-js">fs.createReadStream(file)
  .pipe(zlib.createGzip())
  // 对压缩后文件进行加密
  .pipe(crypto.createCipher(&#39;aes192&#39;, &#39;a_shared_secret&#39;))
  .pipe(req)
  .on(&#39;finish&#39;, () =&gt; {
    console.log(&#39;File successfully sent&#39;);
  });
</code></pre>

<ul>
<li><code>Server</code></li>
</ul>

<pre><code class="language-js">const server = http.createServer((req, res) =&gt; {
  const filename = req.headers.filename;
  console.log(&#39;File request received: &#39; + filename);
  req
    // 对收到的请求进行解密
    .pipe(crypto.createDecipher(&#39;aes192&#39;, &#39;a_shared_secret&#39;))
    .pipe(zlib.createGunzip())
    .pipe(fs.createWriteStream(filename))
    .on(&#39;finish&#39;, () =&gt; {
      res.writeHead(201, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
      res.end(&#39;That\&#39;s it\n&#39;);
      console.log(`File saved: ${filename}`);
    })
  ;
});
</code></pre>

<p>的确只以非常小的改动, 添加上加解密的功能, 但个人认为对于<code>async/await</code>来说, 在工程组合上<code>Stream</code>并无太大优势.</p>

<hr/>

<h3 id="toc_8">Getting started with streams</h3>

<blockquote>
<p>到目前为止, 我们只是看到了如何使用已有的<code>Stream</code>模块, 接下来介绍如何创建自己的<code>Stream</code>模块</p>
</blockquote>

<p>不难看出, 上面的<code>fs.createReadStream</code>和<code>fs.createWriteStream</code>都会返回一个<code>Stream</code>对象, 而在<code>Node.js</code>官方库中, <code>Stream</code>模块中具有几个可被继承的对象</p>

<ul>
<li><code>stream.Readable</code></li>
<li><code>stream.Writable</code></li>
<li><code>stream.Duplex</code></li>
<li><code>stream.Transform</code></li>
</ul>

<p>以上的类均继承了<code>EventEmitter</code>, 实现了<code>end</code>事件, <code>error</code>事件等</p>

<p><code>Stream</code>除了能像<code>fs.createReadFile</code>之类处理IO的二进制流之外(二进制流以Chunk的形式体现), <code>Stream</code>也能传递<code>Object</code>, 能从上一个<code>Stream</code>不断生成<code>Object</code>传递到下一个<code>Stream</code>中, 所以<code>Stream</code>不仅能应用于IO处理中, 普通的对象处理也能得到<code>Stream</code>的好处.</p>

<hr/>

<h3 id="toc_9">Readable streams</h3>

<blockquote>
<p>可读流的使用和创建</p>
</blockquote>

<p><code>Readable streams</code>有两种从中读取数据的方法, <code>non-flowing mode</code>和<code>flowing mode</code></p>

<h4 id="toc_10">The non-flowing mode</h4>

<p><code>non-flowing mode</code>很直白, 从可读流中读取数据直到无数据可读, 由于监听<code>readable</code>后是<code>listener</code>主动从流中读取数据, 相对于<code>flowing mode</code>, 数据并未从事件监听器流入<code>listener</code></p>

<pre><code class="language-js">process.stdin
  // 订阅了 readable
  // 当流变的可读取时调用回调函数
  .on(&#39;readable&#39;, () =&gt; {
    let chunk;
    console.log(&#39;New data available&#39;);
    // 不断循环读取数据直至结束
    while ((chunk = process.stdin.read()) !== null) {
      console.log(
        `Chunk read: (${chunk.length}) &quot;${chunk.toString()}&quot;`
      );
    }
  })
  .on(&#39;end&#39;, () =&gt; process.stdout.write(&#39;End of stream&#39;));
</code></pre>

<p>运行结果</p>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8A%E5%8D%8810.21.07.png" alt="屏幕快照 2017-10-16 上午10.21.07"/></p>

<h4 id="toc_11">Flowing mode</h4>

<p>还有一种从<code>Stream</code>中读取数据的方式是通过监听<code>data</code>事件, </p>

<p><code>stream</code>同时提供了<code>data</code>事件, 每当<code>Readable Stream</code>接收到新的数据时, <code>listener</code>就会被触发, 同时数据以形参的形式传递到<code>listener</code>中</p>

<pre><code class="language-js">process.stdin
  .on(&#39;data&#39;, chunk =&gt; {
    console.log(&#39;New data available&#39;);
    console.log(
      `Chunk read: (${chunk.length}) &quot;${chunk.toString()}&quot;`
    );
  })
  .on(&#39;end&#39;, () =&gt; process.stdout.write(&#39;End of stream&#39;));
</code></pre>

<h4 id="toc_12">Implementing Readable streams</h4>

<blockquote>
<p>创建自己的<code>Readable Stream</code></p>
</blockquote>

<p>创建自己的<code>Readable Stream</code>类的时候, 需要继承<code>stream.Readable</code>, 并实现<code>_read</code>方法, 通过<code>stream.Readable.push</code>方法往<code>Stream</code>内部提供的<code>Buffer</code>推入数据.</p>

<p>书里提供了一个利用<code>chance</code>库生成随机字符串, 并且将生成的字符串作为流输出<br/>
 <strong>(往流中推入<code>null</code>表示流的结束)</strong></p>

<pre><code class="language-js"> class RandomStream extends stream.Readable {
  constructor(options) {
    super(options);
  }
  // 实现 _read 接口
  _read(size) {
    // 生成随机字符串
    const chunk = chance.string();
    console.log(`Pushing chunk of size: ${chunk.length}`);
    // 将随机串推入内部buffer
    this.push(chunk, &#39;utf8&#39;);
    // 有 5% 的概率出现 true
    if (chance.bool({
        likelihood: 5
      })) {
      this.push(null);
    }
  }
}
</code></pre>

<p><code>RandomStream</code>使用示例</p>

<pre><code class="language-js">const randomStream = new RandomStream();

randomStream
  // 订阅 data 事件
  .on(&#39;data&#39;, (chunk) =&gt; {
    console.log(`Chunk received: ${chunk.toString()}`);
  })
  .on(&#39;end&#39;, () =&gt; {
    process.stdout.write(&#39;End of stream\n&#39;)
  });
</code></pre>

<hr/>

<h3 id="toc_13">Writable streams</h3>

<h4 id="toc_14">Writing to a stream</h4>

<blockquote>
<p>如何往<code>Writable Stream</code>中写入数据</p>
</blockquote>

<p><code>stream.Writable</code>中有两个主要方法</p>

<ul>
<li><code>writable.write(chunk[, encoding][, callback])</code>: 往<code>Writable Stream</code>中写入<code>chunk</code></li>
<li><code>writable.end([chunk][, encoding][, callback])</code>: 结束流</li>
</ul>

<p>示例:</p>

<pre><code>往HTTP回包中写入数据
</code></pre>

<pre><code class="language-js">const Chance = require(&#39;chance&#39;);
const chance = new Chance();

require(&#39;http&#39;).createServer((req, res) =&gt; {
  // 写入 HTTP 回包请求头部
  res.writeHead(200, {
    &#39;Content-Type&#39;: &#39;text/plain&#39;
  });
  while (chance.bool({
      likelihood: 95
    })) {
    // 往 HTTP 回包请求中写入随机字符串
    res.write(chance.string() + &#39;\n&#39;);
  }
  // 关闭流
  res.end(&#39;\nThe end...\n&#39;);
  res.on(&#39;finish&#39;, () =&gt; console.log(&#39;All data was sent&#39;)); //[5]
}).listen(8080, () =&gt; console.log(&#39;Listening on http://localhost:8080&#39;));    
</code></pre>

<p>回应结果:<br/>
 <img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8B%E5%8D%887.50.35.png" alt="屏幕快照 2017-10-16 下午7.50.35"/></p>

<h4 id="toc_15">Back-pressure</h4>

<blockquote>
<p>负反馈</p>
</blockquote>

<p><strong>当我们往<code>Writable Stream</code>内部的<code>Buffer</code>写入数据, 而<code>Buffer</code>的大小是有限制的, 写入数据如果过多而消费者未及时取出数据的话, 缓存很容易出现溢出现象</strong></p>

<p>为了解决缓存过载的问题, <code>stream.Writable</code>在内部设置了<code>highWaterMark</code>属性(默认是16KB), 当内部缓存无法容纳更多的数据的时候<code>writable.write</code>将会返回<code>false</code>(<code>Readable Stream</code>内部也有相似的机制)</p>

<p>应用负反馈后的<code>Http Stream</code></p>

<pre><code class="language-js">require(&#39;http&#39;).createServer((req, res) =&gt; {
  res.writeHead(200, {
    &#39;Content-Type&#39;: &#39;text/plain&#39;
  });

  function generateMore() {
    // 有 95% 的概率返回ture
    while (chance.bool({
        likelihood: 95
      })) {
      // 写入一段超长的字符串
      let shouldContinue = res.write(
        chance.string({
          length: (16 * 1024) - 1
        })
      );
      // 当
      if (!shouldContinue) { //[3]
        console.log(&#39;Backpressure&#39;);
        // 如果buffer已经触及极限, 那么订阅 drain 事件
        return res.once(&#39;drain&#39;, generateMore);
      }
    }
    
    res.end(&#39;\nThe end...\n&#39;, () =&gt; console.log(&#39;All data was sent&#39;));
  }
  generateMore();
  
}).listen(8080, () =&gt; console.log(&#39;Listening on http://localhost:8080&#39;));
</code></pre>

<p>这段代码有两个重点:</p>

<ul>
<li>创建了<code>generateMore</code>函数用于在缓存已满的情况下注册为<code>listener</code></li>
<li>在<code>writable stream</code>上监听了<code>drain</code>事件, 根据官方文档的说法, 当<code>writable stream</code>从不可写变为可写时, 注册在<code>drain</code>事件上的<code>listener</code>将会被触发</li>
</ul>

<h4 id="toc_16">Implementing Writable streams</h4>

<blockquote>
<p>实现自己的可写流</p>
</blockquote>

<p>书中示例创建一个传递<code>Object</code>的<code>Stream</code>, 与实现<code>Readable Stream</code>相似, 只需继承<code>stream.Writable</code>后实现<code>_write</code>方法即可</p>

<pre><code class="language-js">class ToFileStream extends stream.Writable {
  constructor() {
    // 启用 object 模式
    super({objectMode: true});
  }
  // chunk 实为 
  // {
  //   path: &lt;path to file&gt;,
  //   content : &lt; content of file&gt;
  // }
  // 的对象
  _write (chunk, encoding, callback) {
    // 创建目录
    mkdirp(path.dirname(chunk.path), err =&gt; {
      if (err) {
        return callback(err);

      }
      // 写入文件
      fs.writeFile(chunk.path, chunk.content, callback);
    });
  }
}
</code></pre>

<p>使用示例</p>

<pre><code class="language-js">let tfs = new ToFileStream();

tfs.write({path: &quot;file1.txt&quot;, content: &quot;Hello&quot;});
tfs.write({path: &quot;file2.txt&quot;, content: &quot;Node.js&quot;});
tfs.write({path: &quot;file3.txt&quot;, content: &quot;Streams&quot;});
tfs.end(() =&gt; console.log(&quot;All files created&quot;));
</code></pre>

<hr/>

<h3 id="toc_17">Duplex streams</h3>

<p><code>Duplex streams</code>表示一种双向的流, 同时继承了<code>Readable Stream</code> 和 <code>Writable Stream</code>, 适合用于具有双向通信功能的实现(例如Socket)<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8B%E5%8D%8811.41.05.png" alt="屏幕快照 2017-10-16 下午11.41.05"/></p>

<h3 id="toc_18">Transform streams</h3>

<p><code>Transform streams</code>是特殊的<code>Duplex streams</code>, 在<code>Readable Stream</code>和<code>Writable Stream</code> 之间提供额外的桥梁<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-17%20%E4%B8%8A%E5%8D%8811.21.06.png" alt="屏幕快照 2017-10-17 上午11.21.06"/></p>

<h4 id="toc_19">Implementing Transform streams</h4>

<p><code>stream.Transform</code>类中有两个需要子类实现的方法</p>

<ul>
<li><code>_transform</code> : 用于在<code>write</code>时调用并写入内部缓存</li>
<li><code>_flust</code>: 在<code>end</code>方法调用时将剩余数据推入内部缓存中</li>
</ul>

<p>示例: 往<code>Transform streams</code>写入字符串, 替换目标字符串并输出</p>

<pre><code class="language-js">class ReplaceStream extends stream.Transform {
  constructor(searchString, replaceString) {
    super();
    this.searchString = searchString;
    this.replaceString = replaceString;
    this.tailPiece = &#39;&#39;;
  }

  _transform(chunk, encoding, callback) {
    // 利用 String.prototype.split 提取出所有目标字符串
    const pieces = (this.tailPiece + chunk)
      .split(this.searchString);
    // 获取分片后字符串数组的末尾元素
    const lastPiece = pieces[pieces.length - 1];
    // 由于写入流的数据不一定是工整的,
    // 需要从输入的流中读取至少searchString.length - 1个字符
    // 用于与后续输入的数据进行拼接搜索
    const tailPieceLen = this.searchString.length - 1;
    // 从末尾切分出 tailPieceLen 长度的字符串
    this.tailPiece = lastPiece.slice(-tailPieceLen);
    // 去除 his.tailPiece 部分的字符串, 以免重复
    pieces[pieces.length - 1] = lastPiece.slice(0, -tailPieceLen);
    // pieces 是由 searchString 分割的字符串数组
    // 经过slice去掉 searchString 后通过 replaceString
    // 拼接字符串数组, 得到替换后的字符串
    // 推入 Readable Stream 中
    this.push(pieces.join(this.replaceString));
    callback();
  }
  // 当流结束时, 切割下来的 tailPiece 仍未推入内部缓存
  // 通过_flush将最后的字符串推入内部缓存
  _flush(callback) {
    this.push(this.tailPiece);
    callback();
  }
}
</code></pre>

<p>使用示例:</p>

<pre><code class="language-js const">// 指定替换的字符串
const rs = new ReplaceStream(&#39;World&#39;, &#39;Node.js&#39;);
// 订阅 Readable Stream 一侧上的 data 事件
// 接收到数据时输出到终端
rs.on(&#39;data&#39;, chunk =&gt; console.log(chunk.toString()));
// 往 Writable Stream 一侧上写入数据
rs.write(&#39;Hello W&#39;);
rs.write(&#39;orld!&#39;);
rs.end();
</code></pre>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-18%20%E4%B8%8B%E5%8D%884.41.13.png" alt="屏幕快照 2017-10-18 下午4.41.13"/></p>

<p>运行结果的输出对应了<code>ReplaceStream</code>的实现所映射出的<code>push数据</code>的行为.</p>

<h4 id="toc_20">Through and from for working with streams</h4>

<p>两个用于快速生成<code>Transform Stream</code> 和 <code>Readable Stream</code>的库</p>

<ul>
<li>through2 , 用于生成<code>Transform Stream</code></li>
</ul>

<pre><code class="language-js">const transform = through2([options], [_transform], [_flush])
</code></pre>

<ul>
<li>from , 用于生成<code>Readable Stream</code>的库</li>
</ul>

<pre><code class="language-js">const readable = from2([options], _read)
</code></pre>

<h3 id="toc_21">Asynchronous control flow with streams</h3>

<blockquote>
<p>实际代码中如何使用<code>Stream</code><br/>
之前的<code>spider</code>实例相似, 分别以<code>Sequential execution</code>和<code>Parallel execution</code>为例</p>
</blockquote>

<h4 id="toc_22">Sequential execution</h4>

<p>以<code>Stream</code>实现一个线性执行拼接文件的功能.</p>

<pre><code class="language-js">const fromArray = require(&#39;from2-array&#39;);
const through = require(&#39;through2&#39;);
const fs = require(&#39;fs&#39;);

function concatFiles(destination, files, callback) {
  // 创建用于存放拼接后文件的 Writable Stream
  const destStream = fs.createWriteStream(destination);
  // fromArray.obj 将会遍历 files
  // 将多个文件名通过 pipe 传递到下一个 Stream
  fromArray.obj(files)
    // 利用 through2 创建一个 Transform Stream
    .pipe(through.obj((file, enc, done) =&gt; {
      //  通过文件名创建 Readable Stream
      const src = fs.createReadStream(file);
      // 往目标文件中写入数据
      // 由于 pipe 在完成时会自动调用end函数
      // 但destStream并未将所有文件拼接完成,
      // 此处将 end 设为 false
      src.pipe(destStream, {
        end: false,
      });
      // 当前文件拼接完毕时调用done函数
      // 以供 fromArray 向 pipe 传递下一个文件名
      src.on(&#39;end&#39;, done);
    }))
    // 在所有文件遍历完毕时
    // 介素 Writable Stream
    .on(&#39;finish&#39;, () =&gt; {
      destStream.end();
      callback();
    });
}
</code></pre>

<p><code>Stream</code>风格的串行执行和上两章中的串行执行风格其实有很多相似的地方</p>

<ul>
<li><code>fromArray.obj</code>逐个遍历文件名并传递到下个流中, 而<code>through.obj</code>中的回调函数在处理完单个文件时, 通过调用<code>done</code>触发下个文件的处理, 类似于上两章串行执行风格中的<code>next</code>函数, 以控制任务遍历的速度</li>
<li>在所有文件处理完毕时, <code>destStream.end</code>标识处理结束, 与上两章串行执行风格中, 执行完毕调用<code>callback</code>相似</li>
</ul>

<h4 id="toc_23">Unordered parallel execution</h4>

<blockquote>
<p>利用<code>Stream</code>实现非顺序的并行执行任务</p>
</blockquote>

<pre><code class="language-js">class ParallelStream extends stream.Transform {
  constructor(userTransform) {
    super({
      objectMode: true
    });
    // userTransform 存放处理任务的函数
    // 也就是用于处理任务的 worker 函数
    this.userTransform = userTransform;
    // 用于记录当前正在运行任务数
    this.running = 0;
    this.terminateCallback = null;
  }

  _transform(chunk, enc, done) {
    this.running++;
    // 将数据传递到 worker 函数
    this.userTransform(chunk, enc, this._onComplete.bind(this), this.push.bind(this));
    // 由于是并发执行 userTransform
    // 我们有自己的_onComplete函数处理worker函数完成事件
    // 需要调用done触发流中下一个任务
    done();
  }

  _flush(done) {
    if (this.running &gt; 0) {
      // 在流结束时还有任务运行时
      // 暂不结束当前流
      this.terminateCallback = done;
    } else {
      done();
    }
  }

  _onComplete(err) {
    // 减少运行任务数
    this.running--;
    if (err) {
      // 往 error 事件发送错误
      return this.emit(&#39;error&#39;, err);
    }
    // _onComplete在每次task完成都会触发
    if (this.running === 0) {
      this.terminateCallback &amp;&amp; this.terminateCallback();
    }
  }
}
</code></pre>

<p><code>Stream</code>的并行执行模式有几点重要的地方</p>

<ul>
<li>利用<code>Stream</code>中的<code>done</code>函数, 强制<code>Stream</code>处理下一个元素</li>
<li>通过<code>running</code>记录正在执行的任务</li>
<li>任务完成时调用<code>_onComplete</code>函数, 触发完成事件.</li>
</ul>

<h4 id="toc_24">Unordered limited parallel execution</h4>

<p>在并行执行中加入并发任务数限制</p>

<pre><code class="language-js">class LimitedParallelStream extends stream.Transform {
  // 加入 concurrency 限制并发数
  constructor(concurrency, userTransform) {
    super({objectMode: true});
    this.concurrency = concurrency;
    this.userTransform = userTransform;
    this.running = 0;
    this.terminateCallback = null;
    this.continueCallback = null;
  }

  _transform(chunk, enc, done) {
    this.running++;
    this.userTransform(chunk, enc,  this.push.bind(this), this._onComplete.bind(this));
    if(this.running &lt; this.concurrency) {
      // 未触及并发上限
      // 调用 done 促使 Stream 传入下一个任务
      done();
    } else {
      // 当某个任务完成时,
      // 调用的 _onComplete 函数的时候将会调用continueCallback
      // 此时触发Stream 传入下一个任务
      this.continueCallback = done;
    }
  }

  _flush(done) {
    if(this.running &gt; 0) {
      this.terminateCallback = done;
    } else {
      done();
    }
  }

  _onComplete(err) {
    this.running--;
    if(err) {
      return this.emit(&#39;error&#39;, err);
    }
    // 由continueCallback指示是否存在等待执行的任务
    const tmpCallback = this.continueCallback;
    this.continueCallback = null;
    tmpCallback &amp;&amp; tmpCallback();
    if(this.running === 0) {
      this.terminateCallback &amp;&amp; this.terminateCallback();
    }
  }
}
</code></pre>

<ul>
<li>这里利用了<code>Stream</code>的机制来充当任务队列, 任务存储在<code>pipe</code>中的上一个<code>Stream</code>中, 而任务控制通过<code>done</code>来控制任务流入的速度</li>
</ul>

<hr/>

<h3 id="toc_25">Piping patterns</h3>

<blockquote>
<p>利用<code>pipe</code>设计和组合<code>Stream</code></p>
</blockquote>

<h4 id="toc_26">Combining streams</h4>

<p>将多个<code>Stream</code>组合起来, 对外只暴露成一个<code>Stream</code><br/>
将<code>Stream</code>组合起来有多个优点</p>

<ul>
<li>将多个流简化, 对外暴露单个接口</li>
<li>流的错误处理简化, 所有被组合的流的错误信息被重定向到组合后的流的错误事件里, 对外接口只需订阅组合后流的错误时间即可</li>
</ul>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8A%E5%8D%8811.28.49.png" alt="屏幕快照 2017-10-20 上午11.28.49"/></p>

<p>组合多个流基于两个原则:</p>

<ul>
<li>当我们往一个组合后的流写入数据时, 实际上是往组合中的第一个流写入数据</li>
<li>当我们往一个组合后的流读取数据时, 实际上是往组合中的最后一个流读取数据</li>
</ul>

<p>基于上述的原则, 利用<code>Duplex Stream</code>或<code>Transform Stream</code>能很轻松做到组合多个流, 而在这里使用第三方库<code>multipipe</code></p>

<pre><code class="language-js">const zlib = require(&#39;zlib&#39;);
const crypto = require(&#39;crypto&#39;);
const combine = require(&#39;multipipe&#39;);

module.exports.compressAndEncrypt = password =&gt; {
  // 返回一个组合后的流
  return combine(
    // 压缩数据
    zlib.createGzip(),

    // 加密数据
    crypto.createCipher(&#39;aes192&#39;, password)
  );
};

module.exports.decryptAndDecompress = password =&gt; {
  return combine(
    // 解密数据
    crypto.createDecipher(&#39;aes192&#39;, password),
    // 解压数据
    zlib.createGunzip()
  );
};
</code></pre>

<p>组合后的<code>Stream</code>使用方法与普通<code>Stream</code>无异.</p>

<h4 id="toc_27">Forking streams</h4>

<p>针对<code>Readable Stream</code>能fork出多个流, 提供给后续多个pipe的数据<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8B%E5%8D%884.48.39.png" alt="屏幕快照 2017-10-20 下午4.48.39"/></p>

<p>而实现方法也非常简单, 直接在同一个<code>Readable Stream</code>实例上分别调用<code>pipe</code>方法.</p>

<ul>
<li>对输入的文件同时进行<code>sha1</code>与<code>md5</code>哈希计算</li>
</ul>

<pre><code class="language-js">const fs = require(&#39;fs&#39;);
const crypto = require(&#39;crypto&#39;);

const sha1Stream = crypto.createHash(&#39;sha1&#39;);
sha1Stream.setEncoding(&#39;base64&#39;);

const md5Stream = crypto.createHash(&#39;md5&#39;);
md5Stream.setEncoding(&#39;base64&#39;);

const inputFile = process.argv[2];
const inputStream = fs.createReadStream(inputFile);
// 在同一个inputStream实例上调用pipe
// 完成 Fork Stream
inputStream
  .pipe(sha1Stream)
  .pipe(fs.createWriteStream(inputFile + &#39;.sha1&#39;));

inputStream
  .pipe(md5Stream)
  .pipe(fs.createWriteStream(inputFile + &#39;.md5&#39;));
</code></pre>

<h4 id="toc_28">Merging streams</h4>

<blockquote>
<p>整个多个流</p>
</blockquote>

<p><img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8B%E5%8D%8810.27.15.png" alt="屏幕快照 2017-10-20 下午10.27.15"/></p>

<p>实现方法:</p>

<ul>
<li>在多个留上使用<code>pipe</code>方法导向同一个流, 并把<code>pipe</code>方法的自动结束<code>Stream</code>设为<code>false</code>({end: false})</li>
<li>订阅多个流的<code>end</code>事件, 应用自定义的处理<code>end</code>事件函数</li>
</ul>

<p>示例: 将多个文件流导向同一个压缩处理流中</p>

<pre><code class="language-js">const tar = require(&#39;tar&#39;);
const fstream = require(&#39;fstream&#39;);
const path = require(&#39;path&#39;);

const destination = path.resolve(process.argv[2]);
const sourceA = path.resolve(process.argv[3]);
const sourceB = path.resolve(process.argv[4]);

// 获取压缩流(Writable Stream)
const pack = tar.Pack();
// 将压缩后的流写入文件中
pack.pipe(fstream.Writer(destination));

let endCount = 0;
// 用于在多个流处理结束后
// 关闭 压缩流
function onEnd() {
  if(++endCount === 2) {
    pack.end();
  }
}

const sourceStreamA = fstream.Reader({type: &quot;Directory&quot;, path: sourceA})
  .on(&#39;end&#39;, onEnd);

const sourceStreamB = fstream.Reader({type: &quot;Directory&quot;, path: sourceB})
  .on(&#39;end&#39;, onEnd);

// 两个流重定向至 pack
sourceStreamA.pipe(pack, {end: false});
sourceStreamB.pipe(pack, {end: false});
</code></pre>

<h4 id="toc_29">Multiplexing and demultiplexing</h4>

<blockquote>
<p>复用单个流写入多个数据, 在另一端从单个流中解离出多个数据<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-20%20%E4%B8%8B%E5%8D%8811.13.06.png" alt="屏幕快照 2017-10-20 下午11.13.06"/><br/>
在两段利用对称的<code>mux</code>和<code>demux</code>函数融合与分离多个流</p>
</blockquote>

<p>示例: 创建CS服务, <code>Server</code>接收数据并写入文件中(log服务), <code>Client</code>发送日志数据.</p>

<ul>
<li><code>Client</code></li>
</ul>

<pre><code class="language-js">const child_process = require(&#39;child_process&#39;);
const net = require(&#39;net&#39;);

// multiplexChannels 用于将多个流(sources)
// 同时写入同一个流(destination)中
function multiplexChannels(sources, destination) {
  let totalChannels = sources.length;
  // 遍历sources数组中的多个流
  for (let i = 0; i &lt; sources.length; i++) {
    sources[i]
      // 订阅 readable 事件
      .on(&#39;readable&#39;, function () {
        let chunk;
        // 利用 Non-Flowing 模式
        while ((chunk = this.read()) !== null) {
          const outBuff = new Buffer(1 + 4 + chunk.length);
          // 每一个buffer头部
          // 8 bits用于标识数据的ID
          outBuff.writeUInt8(i, 0);
          // 紧接着的32 bits用于记录当前chunk的长度
          outBuff.writeUInt32BE(chunk.length, 1);
          // 将 chunk 复制到 outBuffer 中
          chunk.copy(outBuff, 5);
          console.log(&#39;Sending packet to channel: &#39; + i);
          // 将数据写入 destination 流中
          destination.write(outBuff);
        }
      })
      .on(&#39;end&#39;, () =&gt; {
        // 在所有sources上订阅end事件
        if (--totalChannels === 0) {
          // 当所有流处理完毕,
          // 关闭 destination
          destination.end();
        }
      });
  }
}

const socket = net.connect(3000, () =&gt; {
  const child = child_process.fork(
    process.argv[2],
    process.argv.slice(3), {
      silent: true
    }
  );
  multiplexChannels([child.stdout, child.stderr], socket);
});
</code></pre>

<p><code>Client</code>中使用<code>Non-Flowing</code>模式非常重要, 每次往<code>destination</code>中写入一个完整的<code>Chunk</code>, 不会导致多个<code>Chunk</code>交错在一起.</p>

<ul>
<li><code>Server</code></li>
</ul>

<pre><code class="language-js">&quot;use strict&quot;;

const net = require(&#39;net&#39;);
const fs = require(&#39;fs&#39;);

function demultiplexChannel(source, destinations) {
  let currentChannel = null;
  let currentLength = null;
  source
    // 订阅 readable 事件
    .on(&#39;readable&#39;, () =&gt; {
      let chunk;
      if (currentChannel === null) {
        // 从source中读取 8 bits, 获得管道的ID
        chunk = source.read(1);
        currentChannel = chunk &amp;&amp; chunk.readUInt8(0);
      }

      if (currentLength === null) {
        // 从source中读取 32 bits, 获的Chunk的长度
        chunk = source.read(4);
        // 转换字节序
        currentLength = chunk &amp;&amp; chunk.readUInt32BE(0);
        if (currentLength === null) {
          // 如果 currentLength 获取失败
          // 表明 tcp 流在传输过程中被切分
          // 在下次可读事件时重新读取
          return;
        }
      }
      // 从source中读取chunk长度的数据
      chunk = source.read(currentLength);
      if (chunk === null) {
        // 如果currentLength长度的数据读取失败
        // 说明TCP流被拆包
        // 也需要在下次可读事件时再重新读取
        return;
      }

      console.log(&#39;Received packet from: &#39; + currentChannel);

      // 往 destinations 中写入chunk
      destinations[currentChannel].write(chunk);
      // 写入完成后复原头部数据
      currentChannel = null;
      currentLength = null;
    })
    .on(&#39;end&#39;, () =&gt; {
      destinations.forEach(destination =&gt; destination.end());
      console.log(&#39;Source channel closed&#39;);
    });
}

net.createServer(socket =&gt; {
    const stdoutStream = fs.createWriteStream(&#39;stdout.log&#39;);
    const stderrStream = fs.createWriteStream(&#39;stderr.log&#39;);
    demultiplexChannel(socket, [stdoutStream, stderrStream]);
  })
  .listen(3000, () =&gt; console.log(&#39;Server started&#39;));
</code></pre>

<p><code>Server</code>利用了<code>Client</code>中<code>Chunk</code>串行写入与TCP协议的实现中按序移交到用户态的特性, 按序读取<code>Chunk</code>并写入文件中.</p>

<p>运行结果<br/>
<img src="media/15078961128669/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-21%20%E4%B8%8A%E5%8D%8812.14.05.png" alt="屏幕快照 2017-10-21 上午12.14.05"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15064131114315.html">Node.js设计模式 · 第四章</a></h1>
			<p class="meta"><time datetime="2017-09-26T16:05:11+08:00" 
			pubdate data-updated="true">2017/9/26 16:5 下午</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Asynchronous Control Flow Patterns with ES2015 and Beyond</h2>

<blockquote>
<p>本章主要讲述了ES6中的Promise, Generator特性与使用方法, 以及稍微探讨了async/await</p>
</blockquote>

<hr/>

<h2 id="toc_1">摘要</h2>

<ul>
<li>Promise</li>
<li>Generator</li>
<li>async / await</li>
</ul>

<hr/>

<h2 id="toc_2">Promise</h2>

<p>除了上一章的CPS风格之外, 在JS中实现异步编程还有另外一些风格, 例如ES6新加入的Promise</p>

<h3 id="toc_3">What is a promise?</h3>

<blockquote>
<p>在JavaScript中, <code>Promise</code>按照<a href="https://promisesaplus.com/">Promise a+</a>标准实现</p>
</blockquote>

<p><code>Promise</code>指的是对异步操作的抽象, 而<code>Promise</code>又有多种状态</p>

<ul>
<li>当<code>Promise</code>操作未完成时状态称为<code>pending</code></li>
<li>当<code>Promise</code>操作成功完成时状态称为<code>fulfilled</code></li>
<li>当<code>Promise</code>操作失败时状态称为<code>rejected</code></li>
<li>无论<code>Promise</code>操作成功或者失败, 状态都叫<code>settled</code></li>
</ul>

<p>在JavaScript中, <code>Promise</code>被实现为一个对象, <strong>实例中</strong>提供了<code>then</code>方法用于接收异步事件的完成状态</p>

<ul>
<li><code>promise.then(onFulfilled[, onRejected])</code>: <code>onFulfilled</code>和<code>onRejected</code>都是接收一个形参的函数,<code>onFulfilled</code>用于接收<code>Promise</code>成功执行之后的结果, 而<code>onRejected</code>用于接收<code>Promise</code>执行失败的结果, 返回值为<strong>另一个</strong>处于<code>pending</code>状态的<code>Promise</code>实例</li>
</ul>

<p>和异步CPS风格作对比</p>

<pre><code class="language-js">// CPS风格
asyncOperation(arg, (err, result) =&gt; {
    if (err) { 
        //处理错误
        return;
    } 
    // 正常处理流程 
});

// Promise风格, 假设asyncOperation返回一个Promise的实例
// 传入了两个函数用于处理 正常事件 和 异常事件
asyncOperation(arg).then(result =&gt; { 
    //do stuff with result   
}, err =&gt; {
    //handle error   
});
</code></pre>

<p><code>then()</code>方法还有一些很重要的属性</p>

<ol>
<li><code>then()</code>必然返回另外一个<code>Promise</code>实例, 只有当第一个<code>Promise</code>解决或被拒绝后, 第二个<code>Promise</code>才会被解决 (<code>then</code>方法是异步的, 但返回的另一个<code>Promise</code>只有在第一个<code>Promse</code>解决或被拒绝后才开始执行)</li>
<li>由于<code>then()</code>函数返回另一个<code>Promise</code>实例, 有可能形成一个<code>Promise</code>链, <code>onFulfilled</code>或<code>onRejected</code>的返回值会在<code>Promise</code>链中传递

<ul>
<li>当<code>onFulfilled</code>或<code>onRejected</code>的返回值为<code>Promise</code>实例<strong>以外</strong>的值时, 以此返回值作为下一个<code>Promise</code>中传递给<code>onFulfilled</code>函数的值</li>
<li>当<code>onFulFilled</code>返回一个<code>Promise</code>实例时, <code>then()</code>方法的返回值会替换为<code>onFulFilled</code>的返回值, 但是当第一个<code>Promise</code>被拒绝时, 第二个<code>Promise</code>的<code>onFulfilled</code>方法将不会被调用</li>
</ul></li>
</ol>

<p>由于上述的特性, 我们可以非常容易实现一个串行执行的<code>Promise</code>链</p>

<pre><code class="language-js">asyncOperation(arg).then(result1 =&gt; {
    // asyncOperation返回另一个Promise实例 
    return asyncOperation(arg2);
}).then(result2 =&gt; {
    // 返回一个普通的值  
    return &#39;done&#39;;
}).then(undefined, err =&gt; {
    // 利用 onRejected 函数捕抓异常
});
</code></pre>

<p><img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-26%20%E4%B8%8B%E5%8D%889.34.16.png" alt="屏幕快照 2017-09-26 下午9.34.16"/></p>

<h4 id="toc_4">Promise对象</h4>

<ol>
<li>构造函数<code>Constructor (new Promise(function(resolve, reject) {}))</code>

<ul>
<li><code>resolve(obj)</code>: 会将<code>Promise</code>置为<code>Fulfilled</code>状态</li>
<li><code>reject(err)</code> : 会将<code>Promise</code>置为<code>Rejected</code>状态</li>
</ul></li>
<li>静态方法

<ul>
<li><code>Promise.resolve(obj)</code>: 将会创建一个已解决的<code>Promise</code>实例</li>
<li><code>Promise.reject(err)</code> : 将会创建一个被拒绝的<code>Promise</code>实例</li>
<li><code>Promise.all(iterable)</code> : 返回一个新的<code>Promise</code>实例, 并且在<code>iterable</code>中<strong>所有</strong><code>Promise</code>状态为<code>Fulfilled</code>时, 返回的<code>Promise</code>实例状态会被置为<code>Fulfilled</code>, 如果<code>iterable</code>中至少有一个<code>Promise</code>状态为<code>Rejected</code>时, 返回的<code>Promise</code>实例状态也会被置为<code>Rejected</code>并且拒因为<strong>第一个</strong>被拒绝<code>Promise</code>的拒因</li>
<li><code>Promise.race(iterable)</code> : 返回一个<code>Promise</code>实例, 当<code>iterable</code>中任何一个<code>Promise</code>解决或被拒绝时, 返回的<code>Promise</code>实例以同样的原因完成.</li>
</ul></li>
<li>实例方法

<ul>
<li><code>promise.then(onFulfilled, onRejected)</code> : 已经介绍过了</li>
<li><code>promise.catch(onRejected)</code> : 是<code>promise.then(undefined, onRejected)</code>的语法糖</li>
</ul></li>
</ol>

<h4 id="toc_5">Promisifying a Node.js style function</h4>

<blockquote>
<p>创建一个工具函数将CPS风格函数转换为Promise</p>
</blockquote>

<p>遵循了JavaScript编程风格(Callbacks come last 和 Error come First)的函数是很容易被转换成Promise的, 而且<code>util.promisify</code>也提供了这样的函数, 书中也给出了一个实现</p>

<pre><code class="language-js">module.exports.promisify = function (callbackBasedApi) {
    // 包裹 callbackBasedApi, 返回一个新函数
    return function promisified() {
        // Function.arguments 是 Function 实例中存储着形参对象
        // 仅在 Node.js下生效

        // 将 arguments 对象 转换为数组
        const args = [].slice.call(arguments);
        // 创建一个Promise实例
        return new Promise((resolve, reject) =&gt; {
            // 按照callback come last的约定在形参末尾推入回调函数
            args.push((err, result) =&gt; { 
                if (err) {
                    return reject(err);
                }
                if (arguments.length &lt;= 2) {
                    resolve(result);
                } else {
                    resolve([].slice.call(arguments, 1));
                }
            });
            // 调用 callbackBasedApi, callback被替换
            callbackBasedApi.apply(null, args);
        });
    }
};
</code></pre>

<p>这段代码将<code>reject</code>和<code>resolve</code>置入需要被包裹的函数的回调形参中, 令函数完成调用callback时, 触发<code>Promise</code>状态的变换.</p>

<h3 id="toc_6">Sequential execution</h3>

<blockquote>
<p>串行执行的<code>spider</code>网络爬虫, 以<code>Promise</code>的风格实现</p>
</blockquote>

<p>首先把之前的CPS风格函数用<code>promisify</code>将其Promise风格化</p>

<pre><code class="language-js">const utilities = require(&#39;./utilities&#39;);
const request = utilities.promisify(require(&#39;request&#39;));
const mkdirp = utilities.promisify(require(&#39;mkdirp&#39;));
const fs = require(&#39;fs&#39;);
const readFile = utilities.promisify(fs.readFile);
const writeFile = utilities.promisify(fs.writeFile);
</code></pre>

<p>对<code>download</code>函数<code>Promise</code>化</p>

<pre><code class="language-js">function download(url, filename) {
    console.log(`Downloading ${url}`);
    let body;
    return request(url)
    .then(response =&gt; {
        body = response.body;
        // 返回新的Promise
        return mkdirp(path.dirname(filename));
    })
    .then(
        // writeFile 同样返回一个Promise
        () =&gt; writeFile(filename, body)
    )
    .then(() =&gt; {
        console.log(`Downloaded and saved: ${url}`);
        return body;
    });
}
</code></pre>

<p>对<code>spider</code>函数<code>Promise</code>化</p>

<pre><code class="language-js">function spider(url, nesting) {
  let filename = utilities.urlToFilename(url);
  // 先从本地查找此URL是否已被下载
  return readFile(filename, &#39;utf8&#39;)
    .then(
      // 如果已存在则直接从文件中查找其他链接
      (body) =&gt; (spiderLinks(url, body, nesting)),
      // 不存在则下载URL
      (err) =&gt; {
        if (err.code !== &#39;ENOENT&#39;) {
          throw err;
        }

        return download(url, filename)
          .then(body =&gt; spiderLinks(url, body, nesting));
      }
    );
}
</code></pre>

<h4 id="toc_7">Sequential iteration</h4>

<p>还记得串行模式的核心是控制遍历的速度, 也就是通过自制的<code>iterator</code>函数去遍历任务, 而<code>spider</code>中是由<code>spiderLinks</code>去控制多个URL下载</p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting) {
  // 初始化用于控制串行流的Promise
  let promise = Promise.resolve();
  if (nesting === 0) {
    return promise;
  }
  // 获取页面内链接
  const links = utilities.getPageLinks(currentUrl, body);
  links.forEach(link =&gt; {
    // 利用Promise只有在上一个Promise执行成功, 下一个Promise才会执行的特性
    // 串行执行多个Promise实例
    promise = promise.then(() =&gt; spider(link, nesting - 1));
  });

  return promise;
}
</code></pre>

<p>利用链式调用<code>Promise</code>只有在上一个<code>Promise</code>完成后才会执行下一个<code>Promise</code>的特性, 串行执行</p>

<p>执行结果<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-27%20%E4%B8%8B%E5%8D%888.06.48.png" alt="屏幕快照 2017-09-27 下午8.06.48"/></p>

<h4 id="toc_8">Sequential iteration – the pattern</h4>

<blockquote>
<p>串行遍历在<code>Promise</code>风格下的经典模式</p>
</blockquote>

<pre><code class="language-js">// 构造任务队列
let tasks = [ /* ... */ ]
// 初始化 Promise 链
let promise = Promise.resolve();
// 构造 Promise 任务链
tasks.forEach(task =&gt; {
  promise = promise.then(() =&gt; {
    return task();
  });
});
// 启动 Promise
promise.then(() =&gt; {
  //All tasks completed 
});
</code></pre>

<p>而这里遍历<code>task</code>就是一个对任务队列的<strong>化约</strong>操作, 也可以用<code>reduce</code>函数代替</p>

<pre><code class="language-js">// 构造任务队列
let tasks = [ /* ... */ ]
let promise = tasks.reduce((prev, task) =&gt; {
  // 利用 reduce 形成 Promise 链
  return prev.then(() =&gt; {
    return task();
  });
}, Promise.resolve());
// 启动 Promise
promise.then(() =&gt; {
  //All tasks completed 
});
</code></pre>

<hr/>

<h3 id="toc_9">Parallel execution</h3>

<blockquote>
<p>并行执行的<code>spider</code>网络爬虫, 以<code>Promise</code>的风格实现</p>
</blockquote>

<p>只需要修改<code>spiderLink</code>并利用<code>Promise.all</code>并行运行多个任务就可以了</p>

<pre><code class="language-js">function spiderLinks(currentUrl, body, nesting) {
  //  爬取深度
  if (nesting === 0) {
    return Promise.resolve();
  }
  // 获取页面内所有链接
  const links = utilities.getPageLinks(currentUrl, body);
  // 构造Promise任务列表
  const promises = links.map(link =&gt; spider(link, nesting - 1));
  // 并行运行多个promise
  return Promise.all(promises);
}
</code></pre>

<h3 id="toc_10">Limited parallel execution</h3>

<p>在上一章的<strong>Limited parallel execution</strong>小节中, 构造了一个<code>TaskQueuee</code>用于限制和管理任务, 这里用<code>Promise</code>风格实现一遍</p>

<p>修改<code>TaskQueue</code></p>

<pre><code class="language-js"> class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.running = 0;
    // 队列中存储着多个promise
    this.queue = [];
  }

  pushTask(task) {
    this.queue.push(task);
    // 同样充当在任务推入队列后Notify的作用
    this.next();
  }

  next() {
    while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {
      // 获取 queue 中第一个 promise
      const task = this.queue.shift();
      // 设置promise完成后减少running, 让出资源
      task().then(() =&gt; {
        this.running--;
        this.next();
      });
      this.running++;
    }
  }
};
</code></pre>

<p>修改<code>spiderLinks</code>, 接入<code>TaskQueue</code></p>

<pre><code class="language-js">// 构造任务队列, 限制并发数为2
let downloadQueue = new TaskQueue(2);

function spiderLinks(currentUrl, body, nesting) {
  // 达到爬取深度, 返回 Fulfilled 状态的 Promise
  if(nesting === 0) {
    return Promise.resolve();
  }
  // 获取页面内所有链接
  const links = utilities.getPageLinks(currentUrl, body);
  // 如果页面内没有链接, 返回一个 Fulfilled 的Promise
  if(links.length === 0) {
    return Promise.resolve();
  }
  // 返回一个Promise实例
  return new Promise((resolve, reject) =&gt; {
    let completed = 0;
    let errored = false;
    links.forEach(link =&gt; {
      let task = () =&gt; {
        // task 返回一个 promise 实例
        return spider(link, nesting - 1)
          .then(() =&gt; {
            // 当所有链接爬取完毕时Promise置为Fulfilled状态
            if(++completed === links.length) {
              resolve();
            }
          })
          .catch(() =&gt; {
            // 出现异常时
            if (!errored) {
              errored = true;
              reject();
            }
          })
        ;
      };
      // 将Promise任务推入任务队列
      downloadQueue.pushTask(task);
    }); 
  });
}
</code></pre>

<h3 id="toc_11">Exposing callbacks and promises in public APIs</h3>

<blockquote>
<p>在使用优秀的第三方库的时候, 很多函数都会同时提供<code>callback</code>风格和<code>Promise</code>风格的API<br/>
一是为了兼容旧的API接口, 又能同时提供<code>Promise</code>风格的新接口</p>
</blockquote>

<p>书中的示例</p>

<pre><code class="language-js"> function asyncDivision(dividend, divisor, cb) {
  return new Promise((resolve, reject) =&gt; { // [1]
    // 注意到函数名是 asyncDivision, 
    // 利用 process.nextTick 使函数异步执行
    process.nextTick(() =&gt; {
      const result = dividend / divisor;
      if (isNaN(result) || !Number.isFinite(result)) {
        const error = new Error(&#39;Invalid operands&#39;);
        // 除了 reject Promise, 
        // 也要将错误传递到 callback 中
        if (cb) {
          cb(error);
        }
        return reject(error);
      }
      // 正常调用callback
      if (cb) {
        cb(null, result);
      }
      // 同时将promise置为Fulfilled状态
      resolve(result);
    });
  });
};
</code></pre>

<p>使用的时候, 如果我们不传递<code>callback</code>形参, 那么<code>cb</code>此时为<code>undefined</code>, 表明使用者需要的是<code>Promise</code>风格的接口, 反之则是需要CPS风格的接口</p>

<p>然而我个人认为这断代码存在问题, 在出现异常时不仅调用<code>cb(error)</code>传递异常, 还调用<code>reject(error)</code>将<code>Promise</code>置为<code>Reject</code>状态, 这样会导致使用者就算意图只使用<code>callback</code>风格的API时, 没对返回的<code>Promise</code>调用<code>promise.catch</code>捕抓错误的话就会引发Node告警<br/>
例如</p>

<pre><code class="language-js">asyncDivision(10, 0, (error, result) =&gt; {
  if (error) {
    return console.error(error);
  }
  console.log(result);
});
</code></pre>

<p>发生除零错误, 而且已经在<code>callback</code>中处理了错误, 但由于没有对返回的<code>Promise</code>进行错误捕抓, Node也会进行告警<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-30%20%E4%B8%8A%E5%8D%8811.23.19.png" alt="屏幕快照 2017-09-30 上午11.23.19"/><br/>
    这明显不是我们所需要的结果, 所以对函数改良一下</p>

<pre><code class="language-js">function asyncDivision(dividend, divisor, cb) {
  if (cb) {
    return process.nextTick(() =&gt; {
      const result = dividend / divisor;
      if (isNaN(result) || !Number.isFinite(result)) {
        const error = new Error(&#39;Invalid operands&#39;);
        return cb(error);
      }
      cb(null, result);
    })
  }
  return new Promise((resolve, reject) =&gt; {
    asyncDivision(dividend, divisor, (err, result) =&gt; {
      if (err)
        return reject(err)
      return resolve(result);
    })
  })
};
</code></pre>

<p>在传入了<code>callback</code>情况下无需返回一个<code>Promise</code>实例, 从而分离两种风格, 就不会导致Node对异常告警了</p>

<p><img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-30%20%E4%B8%8A%E5%8D%8811.40.27.png" alt="屏幕快照 2017-09-30 上午11.40.27"/></p>

<h2 id="toc_12">Generators</h2>

<blockquote>
<p>ES6中的生成器, 类似于Python中的生成器, 实现状态的暂存和通信</p>
</blockquote>

<p>生成器一般用于模拟协程, 或者用于无限长度的流</p>

<pre><code class="language-js">// ES6 中利用 function* 标识生成器函数
function* fruitGenerator() {
  // yield用于挂起生成器
  yield &#39;apple&#39;;
  yield &#39;orange&#39;;
  return &#39;watermelon&#39;;
}
</code></pre>

<p>使用生成器</p>

<pre><code class="language-js">// 实例化生成器
const newFruitGenerator = fruitGenerator();
// Generator.next用于 载入/恢复 生成器
console.log(newFruitGenerator.next());
console.log(newFruitGenerator.next());
console.log(newFruitGenerator.next());
</code></pre>

<p>运行结果<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-30%20%E4%B8%8B%E5%8D%8810.03.53.png" alt="屏幕快照 2017-09-30 下午10.03.53"/></p>

<p>当生成器函数返回时, 状态<code>Done</code> 为真.</p>

<h3 id="toc_13">Generators as iterators</h3>

<blockquote>
<p>遍历生成器</p>
</blockquote>

<p>利用<code>done</code>指示生成器遍历进度</p>

<pre><code class="language-js">function* iteratorGenerator(num) {
  for (let i = 0; i &lt;num; i++) {
    yield i;
  }
}

// 初始化生成器
const iterator = iteratorGenerator(3);

let currentItem = iterator.next();
// 遍历生成器
while (!currentItem.done) {
  console.log(currentItem.value);
  currentItem = iterator.next();
}
</code></pre>

<p>运行结果<br/>
<img src="media/15064131114315/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-01%20%E4%B8%8B%E5%8D%8812.17.14.png" alt="屏幕快照 2017-10-01 下午12.17.14"/></p>

<h3 id="toc_14">Passing values back to a generator</h3>

<blockquote>
<p>生成器的数据流是双向的, 不仅可以从生成器得到数据, 还可以向生成器发送数据</p>
</blockquote>

<pre><code class="language-js">&quot;use strict&quot;;

function* twoWayGenerator() {
  const what = yield null;
  console.log(&#39;Hello &#39; + what);
}

const twoWay = twoWayGenerator();
// 第一次 next() 返回 null
twoWay.next();
// 第二次 next() 将数据传递至 what, 并结束生成器
twoWay.next(&#39;world&#39;);
</code></pre>

<p>运行结果将会打印出<code>Hello world</code></p>

<h3 id="toc_15">Asynchronous control flow with generators</h3>

<blockquote>
<p>既然生成器能做到控制流的暂停和恢复, 那么用于模拟协程暂停与恢复就很容易了</p>
</blockquote>

<pre><code class="language-js">function asyncFlow(generatorFunction) {
  // 嵌套声明的 callback 函数
  function callback(err) {
    if (err) { 
      return generator.throw(err); 
    }
    // 通过 Functions.arguments 获取 callback 的形参
    // 剔除掉err, 也就是 callback 的结果
    const results = [].slice.call(arguments, 1);
    // 恢复协程, 并将结果返回至挂起点
    generator.next(results.length &gt; 1 ? results : results[0]); 
  }
  // 实例化深层器
  const generator = generatorFunction(callback);
  // 启动生成器
  generator.next(); 
}
</code></pre>

<p><code>asyncFlow</code>函数通过传入生成器函数, 并在<code>callback</code>中恢复和传递生成器的结果从而达到操作完成时恢复生成器的功能.</p>

<p>用例: 复制一个文件<br/>
<code>js<br/>
// 创建匿名生成器函数<br/>
asyncFlow(function* (callback) {<br/>
  const fileName = path.basename(__filename);<br/>
  // 替换callback<br/>
  const myself = yield fs.readFile(fileName, &#39;utf8&#39;, callback);<br/>
  yield fs.writeFile(`clone_of_${fileName}`, myself, callback);<br/>
  console.log(&#39;Clone created&#39;);<br/>
});<br/>
</code></p>

<h4 id="toc_16">JavaScript 中的 Chunk</h4>

<blockquote>
<p>JS中的Chunk其实是将典型的CPS函数<code>柯里化</code>成为只剩下<code>callback</code>参数的函数, 例如</p>

<pre><code class="language-js">function readFileChunk(filename, options) {
 return (callback) =&gt; {
  fs.readFile(filename, options, callback)
 }
}
</code></pre>

<p><code>readFileChunk</code>函数将<code>fs.readFile</code>柯里化成为仅接受<code>callback</code>的函数</p>
</blockquote>

<ul>
<li><p>Thunk的作用<br/>
注意到上面的<code>asyncFlow</code>函数, 传入的形参是带<code>callback</code>的生成器函数, 而在使用<code>yield</code>时, 仍需要往CPS风格函数传入<code>callback</code>, 这看起来并不简约, 于是出现了新的<code>asyncFlow</code>生成器控制函数及<code>Thunk</code>技术, 解决生成器函数风格问题.</p></li>
<li><p>基于<code>Chunk</code>的<code>asyncFlow</code></p></li>
</ul>

<pre><code class="language-js">function asyncFlowWithThunks(generatorFunction) {
  function callback(err) {
    if (err) {
      return generator.throw(err);
    }
    const results = [].slice.call(arguments, 1);
    const thunk = generator.next(results.length &gt; 1 ? results : results[0]).value;
    // 检查 Thunk 并且传入 callback
    thunk &amp;&amp; thunk(callback);
  }
  // 初始化生成器
  const generator = generatorFunction();
  // 生成器函数将会返回一个 Thunk
  const thunk = generator.next().value;
  // 检查 Thunk 并且传入 callback
  thunk &amp;&amp; thunk(callback);
}
</code></pre>

<ul>
<li>函数<code>Thunk</code>化</li>
</ul>

<pre><code class="language-js">const readFileThunk = (filename, options) =&gt; {
  return (cb) =&gt; {
    fs.readFile(filename, options, cb);
  }
};

const writeFileThunk = (filename, options) =&gt; {
  return (cb) =&gt; {
    fs.writeFile(filename, options, cb);
  }
};
</code></pre>

<p>使用示例</p>

<pre><code class="language-js">asyncFlowWithThunks(function* () {
  const fileName = path.basename(__filename);
  const myself = yield readFileThunk(fileName, &#39;utf8&#39;);
  yield writeFileThunk(`clone_of_${fileName}`, myself);
  console.log(&#39;Clone created&#39;);
});
</code></pre>

<p>如此一来, 整个生成器流控制函数就简练很多了.</p>

<h4 id="toc_17">thunkify</h4>

<p>就像之前的<code>promisify</code>一样, <code>thunkify</code>能方便将普通的CPS风格函数转换为<code>Thunk</code>风格函数, 方便应用到生成器中</p>

<pre><code class="language-js">function thunkify(fn) {
  assert(&#39;function&#39; == typeof fn, &#39;function required&#39;);

  return function () {
    let args = [].slice.call(arguments)
    let ctx = this;
    // 返回一个 Thunk 化后的函数
    // done 代表 callback 函数
    return function (done) {
      let called;
      // 在形参末尾推入 callback
      args.push(function () {
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });
      // 调用fn
      try {
        fn.apply(ctx, args);
      } catch (err) {
        done(err);
      }
    }
  }
}
</code></pre>

<h4 id="toc_18">Generator-based control flow using co</h4>

<p><code>co</code>是Node.js中一个控制异步流程的库, 支持</p>

<ul>
<li>Thunks</li>
<li>Promises</li>
<li>Arrays</li>
<li>Objects</li>
<li>Generators</li>
<li>Generator functions</li>
</ul>

<h4 id="toc_19">Sequential execution</h4>

<blockquote>
<p>利用<code>co</code>与<code>Thunk</code>技术实现串行执行</p>
</blockquote>

<p>同样是以<code>spider</code>为例</p>

<ul>
<li>首先利用<code>thunkify</code>将普通函数转化为<code>Thunk</code>风格</li>
</ul>

<pre><code class="language-js">const co = require(&#39;co&#39;);
const request = thunkify(require(&#39;request&#39;));
const fs = require(&#39;fs&#39;);
const mkdirp = thunkify(require(&#39;mkdirp&#39;));
const readFile = thunkify(fs.readFile);
const writeFile = thunkify(fs.writeFile);
const nextTick = thunkify(process.nextTick);
</code></pre>

<ul>
<li>利用生成器改造函数</li>
</ul>

<pre><code class="language-js">// 将 download 改造成生成器函数
function* download(url, filename) {
  console.log(&#39;Downloading &#39; + url);
  const response = yield request(url);
  const body = response[1];
  // 等待 mkdirp 完成
  yield mkdirp(path.dirname(filename));
  // 等待 writeFile 完成
  yield writeFile(filename, body);
  console.log(`Downloaded and saved: ${url}`);
  return body;
}

// 将 spider 改造成生成器函数
function* spider(url, nesting) {
  const filename = utilities.urlToFilename(url);
  let body;
  try {
    // readFile 已被 Thunk 化, 返回文件 body
    body = yield readFile(filename, &#39;utf8&#39;);
  } catch (err) {
    if (err.code !== &#39;ENOENT&#39;) {
      throw err;
    }
    body = yield download(url, filename);
  }
  yield spiderLinks(url, body, nesting);
}

// 以及 Sequential execution 最重要的
// 控制任务载入速度的 spiderLinks
function* spiderLinks(currentUrl, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getPageLinks(currentUrl, body);
  for (let i = 0; i &lt; links.length; i++) {
    yield spider(links[i], nesting - 1);
  }
}

</code></pre>

<ul>
<li>利用<code>co</code>库启动生成器</li>
</ul>

<pre><code class="language-js co(function*">  try {
    yield spider(process.argv[2], 1);
    console.log(&#39;Download complete&#39;);
  } catch (err) {
    console.log(err);
  }
});
</code></pre>

<h4 id="toc_20">Parallel execution</h4>

<ul>
<li> 利用<code>co</code>能并发载入生成器数组中元素的特性, 改造<code>spiderLinks</code>即可</li>
</ul>

<pre><code class="language-js">function* spiderLinks(currentUrl, body, nesting) {
  if (nesting === 0) {
    return nextTick();
  }

  const links = utilities.getPageLinks(currentUrl, body);
  // spide 函数返回一个生成器实例
  const tasks = links.map(link =&gt; spider(link, nesting - 1));
  // 返回一个生成器数组
  yield tasks;
}
</code></pre>

<h4 id="toc_21">Limited parallel execution</h4>

<ul>
<li>以<code>生产者-消费者</code>模式, 控制并发任务数</li>
</ul>

<pre><code class="language-js">class TaskQueue {
  constructor(concurrency) {
    this.concurrency = concurrency;
    this.taskQueue = [];
    this.consumerQueue = [];
    // 创建 worker
    this.spawnWorkers(concurrency);
  }

  pushTask(task) {
    if (this.consumerQueue.length !== 0) {
      // 相当于 notify, 通知被挂起的生成器
      this.consumerQueue.shift()(null, task);
    } else {
      // 说明当前已达任务上限, 推入任务队列
      this.taskQueue.push(task);
    }
  }

  spawnWorkers(concurrency) {
    const self = this;
    for (let i = 0; i &lt; concurrency; i++) {
      co(function* () {
        while (true) {
          // worker获取下一个任务
          const task = yield self.nextTask();
          // 载入任务
          yield task;
        }
      });
    }
  }

  nextTask() {
    // nextTask 返回一个 Thunk, 这样 co 库才能载入这个生成器
    return callback =&gt; {
      // co 在获得这个 Thunk 函数后
      // 这个生成器被马上激活
      if (this.taskQueue.length !== 0) {
        // 如果任务队列中存在任务
        // 那么将它返回至生成器另一端
        return callback(null, this.taskQueue.shift());
      }
      // 如果任务队列为空
      // 那么挂起这个生成器, 直到 pushTask 被调用
      this.consumerQueue.push(callback);
    }
  }
}
</code></pre>

<p>利用<code>Generator</code>模拟的任务队列设计的非常巧妙, <code>this.consumerQueue</code>保存了<code>worker</code>生成器的状态, 用于在有新的任务时触发</p>

<h4 id="toc_22">Async await using Babel</h4>

<blockquote>
<p><code>async</code> 和 <code>await</code> 已经在<code>Node.js 8</code>中完全支持, 而不需要 Babel 了</p>
</blockquote>

<pre><code class="language-js">function getPageHtml(url) {
  return new Promise((resolve, reject) =&gt; {
    request(url, (error, response, body) =&gt; {
      resolve(body);
    });
  });
}

async function main() {
  const html = await getPageHtml(&#39;http://google.com&#39;);
  console.log(html);
}

main();
</code></pre>

<p><code>async</code>和<code>await</code>利用了原有的<code>Promise</code>, 并将传给<code>resolve</code>的值通过<code>await</code>返回, 传递给<code>reject</code>的值将会以异常的形式抛出, 通过<code>try...catch</code>捕获.</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15101331051720.html">JavaScript高级程序设计 · 4、5、6 章</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15096777193883.html">Node.js设计模式 · 第七章</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15093607735574.html">JavaScript高级程序设计 · 1、2、3、20章</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15087314678145.html">Node.js设计模式 · 第六章</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15078961128669.html">Node.js设计模式 · 第五章</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 -  -
  <span class="credit">Powered by <a target="_blank" href="https://zerolocusta.github.io">zerolocusta</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    

<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>
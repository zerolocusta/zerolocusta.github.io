<!DOCTYPE html>
<html>
    <head>
        <title>libco 源码阅读 · 协程实现</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="created" content="2017-09-10T21:18:22+0800"/>
        <meta name="modified" content="2017-09-15T17:26:55+0800"/>
        <meta name="tags" content=""/>
        <meta name="last device" content="LOCUSTCHEN-MB0"/>
    </head>
    <body>
        <div class="note-wrapper">
            <h1>libco 源码阅读 · 协程实现</h1>
<p><code class='code-inline'>最近正在计划做一个c++上的Actor模型框架, 准备利用libco作为协程调度器, 需要对libco进行改造, 读起了libco源码</code></p>
<br>
<h1>0. 源码蓝图</h1>
<h2>0.1 功能假设</h2>
<p>	读源码前先大概了解代码的功能, 然后思考如果是自己会怎么去设计这份代码, 做出了假设</p>
<ul><li>		libco作为一个协程库, 必须具有调度器, 而协程一般用于和多路复用IO结合以利用等待IO的时间
</li><li>		在做协程上下文转换时, 会利用汇编对当前逻辑进行保存, 然后将控制权让渡给主协程调度器, 由调度器决定下一个运行的协程
</li><li>		保存协程上下文需要额外的栈, 但是libco的介绍里说了它利用了共享栈去保存协程状态
</li></ul>	根据以上假设, 找出了几个相对应的文件和函数
<ul><li>		epoll与调度器
</li></ul>		<code class='code-inline'>co_routine.h</code> 中
<ul><li>			用于运行协程的主调度循环
</li></ul><pre><code class='code-multiline'><span class="sf_code_syntax_project">void</span> co_eventloop(stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, <span class="sf_code_syntax_project">void</span> *arg)
</code></pre><ul><li>			用于创建协程
</li></ul><pre><code class='code-multiline'><span class="sf_code_syntax_project">int</span> co_create(stCoRoutine_t **co, <span class="sf_code_syntax_project">const</span> stCoRoutineAttr_t *attr, <span class="sf_code_syntax_project">void</span> *(*routine)(<span class="sf_code_syntax_project">void</span> *), <span class="sf_code_syntax_project">void</span> *arg);
</code></pre><ul><li>			用于载入协程
</li></ul><pre><code class='code-multiline'><span class="sf_code_syntax_project">void</span> co_resume(stCoRoutine_t *co)
</code></pre><ul><li>			挂起协程相关操作
</li></ul><pre><code class='code-multiline'><span class="sf_code_syntax_project">void</span> co_yield_ct()
<span class="sf_code_syntax_project">void</span> co_yield_env(stCoRoutineEnv_t *env)
<span class="sf_code_syntax_project">void</span> co_yield(stCoRoutine_t *co)
</code></pre><hr>
<h2>0.2 简单尝试</h2>
	API那么多, 眼花缭乱了, 先找几个最简单的, 尝试一下他的效果吧
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// 新建协程的API
</span><span class="sf_code_syntax_project">int</span> co_create(stCoRoutine_t **co, <span class="sf_code_syntax_project">const</span> stCoRoutineAttr_t *attr, <span class="sf_code_syntax_project">void</span> *(*routine)(<span class="sf_code_syntax_project">void</span> *), <span class="sf_code_syntax_project">void</span> *arg);

<span class="sf_code_syntax_comment">// 挂起当前协程的API
</span><span class="sf_code_syntax_project">void</span> co_yield_ct()

<span class="sf_code_syntax_comment">// 恢复被挂起协程的API
</span><span class="sf_code_syntax_project">void</span> co_resume(stCoRoutine_t *co)
</code></pre>	利用这三个协程的创建, 挂起, 恢复, 简单地观察一下libco的协程运行状况.
	简单的写一个测试的demo
<pre><code class='code-multiline'><span class="sf_code_syntax_preprocessor">#include </span><span class="sf_code_syntax_string">"co_routine.h"</span><span class="sf_code_syntax_preprocessor">
#include </span><span class="sf_code_syntax_string">&lt;stdio.h&gt;</span>

<span class="sf_code_syntax_project">void</span> *foo(<span class="sf_code_syntax_project">void</span> *args)
{
    printf(<span class="sf_code_syntax_string">"[foo] Before Yield ①</span><span class="sf_code_syntax_number">\n</span><span class="sf_code_syntax_string">"</span>);
    co_yield_ct();
    printf(<span class="sf_code_syntax_string">"[foo] After  Yield ②</span><span class="sf_code_syntax_number">\n</span><span class="sf_code_syntax_string">"</span>);
    <span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">NULL</span>;
}

<span class="sf_code_syntax_project">void</span> *bar(<span class="sf_code_syntax_project">void</span> *args)
{
    printf(<span class="sf_code_syntax_string">"[bar] Before Yield ③</span><span class="sf_code_syntax_number">\n</span><span class="sf_code_syntax_string">"</span>);
    co_yield_ct();
    printf(<span class="sf_code_syntax_string">"[bar] After  Yield ④</span><span class="sf_code_syntax_number">\n</span><span class="sf_code_syntax_string">"</span>);
    <span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">NULL</span>;
}


<span class="sf_code_syntax_project">int</span> main(<span class="sf_code_syntax_project">int</span> argc, <span class="sf_code_syntax_project">char</span> *argv[])
{
    stCoRoutine_t *foo_co = <span class="sf_code_syntax_number">NULL</span>;
    stCoRoutine_t *bar_co = <span class="sf_code_syntax_number">NULL</span>;
    <span class="sf_code_syntax_comment">// 创建foo_co协程, 并且使用foo函数作为其入口函数
</span>    co_create(&foo_co, <span class="sf_code_syntax_number">NULL</span>, foo, <span class="sf_code_syntax_number">0</span>);
    <span class="sf_code_syntax_comment">// 创建bar_co协程, 并且使用bar函数作为其入口函数
</span>    co_create(&bar_co, <span class="sf_code_syntax_number">NULL</span>, bar, <span class="sf_code_syntax_number">0</span>);
    <span class="sf_code_syntax_comment">// 初次载入 foo_co 协程
</span>    co_resume(foo_co);
    <span class="sf_code_syntax_comment">// 初次载入 bar_co 协程
</span>    co_resume(bar_co);
    <span class="sf_code_syntax_comment">// 再次载入 foo_co 协程
</span>    co_resume(foo_co);
    <span class="sf_code_syntax_comment">// 再次载入 bar_co 协程
</span>    co_resume(bar_co);
}
</code></pre>	运行结果
				<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.00.40.png'>
	符合我们对协程的预期和理解, 接下来应该深入<code class='code-inline'>co_create</code>, <code class='code-inline'>co_resume</code> 和 <code class='code-inline'>co_yield_ct()</code>去理解libco究竟如何实现这个过程了.
<hr>
<h2>0.3 跟踪<code class='code-inline'>co_create</code></h2>
<h3>0.3.1 <code class='code-inline'>co_create</code>函数本体</h3>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">int</span> co_create(stCoRoutine_t **ppco, <span class="sf_code_syntax_project">const</span> stCoRoutineAttr_t *attr, pfn_co_routine_t pfn, <span class="sf_code_syntax_project">void</span> *arg)
{
	<span class="sf_code_syntax_comment">// 尝试获取当前线程的 全局协程运行环境
</span>	<span class="sf_code_syntax_keyword">if</span> (!co_get_curr_thread_env())
	{
		<span class="sf_code_syntax_comment">// 如果当前线程的 全局协程运行环境 未初始化,
</span>		<span class="sf_code_syntax_comment">// 那么初始化它
</span>		co_init_curr_thread_env();
	}
	<span class="sf_code_syntax_comment">// 这里的 co_create_env 
</span>	<span class="sf_code_syntax_comment">// 要理解为 根据pfn入口函数, 
</span>	<span class="sf_code_syntax_comment">// 创建 协程私有的运行环境 , 
</span>	<span class="sf_code_syntax_comment">// 要和上面的 全局运行环境 分开
</span>	stCoRoutine_t *co = co_create_env(co_get_curr_thread_env(), attr, pfn, arg);
	*ppco = co;
	<span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">0</span>;
}
</code></pre>	根据<code class='code-inline'>co_create</code>的源码, 发现
<ul><li>			libco每个线程都有一个全局协程运行环境
</li><li>			每个协程也有自己的私有运行环境(类似于上下文)
</li></ul><hr>
<h3>0.3.1 <code class='code-inline'>co_get_curr_thread_env()</code>函数本体</h3>
	先看看这个<mark>当前线程的协程全局运行环境</mark>是什么吧
<pre><code class='code-multiline'>stCoRoutineEnv_t *co_get_curr_thread_env()
{
	<span class="sf_code_syntax_keyword">return</span> g_arrCoEnvPerThread[GetPid()];
}
</code></pre>	<code class='code-inline'>co_get_curr_thread_env()</code>根据不同的当前 线程/进程  id, 去获取相应的<code class='code-inline'>stCoRoutineEnv_t</code>
	<code class='code-inline'>g_arrCoEnvPerThread</code>数组长这样
<pre><code class='code-multiline'><span class="sf_code_syntax_project">static</span> stCoRoutineEnv_t *g_arrCoEnvPerThread[<span class="sf_code_syntax_number">204800</span>] = {<span class="sf_code_syntax_number">0</span>};
</code></pre><hr>
<h3>0.3.2 <code class='code-inline'>stCoRoutineEnv_t</code>结构体</h3>
	这个协程环境存了什么呢? 
	简单的看一下<code class='code-inline'>stCoRoutineEnv_t</code>结构体
<pre><code class='code-multiline'><span class="sf_code_syntax_project">struct</span> stCoRoutineEnv_t
{
  <span class="sf_code_syntax_comment">// 协程的调用栈 (resume/yield 栈) 
</span>	stCoRoutine_t *pCallStack[<span class="sf_code_syntax_number">128</span>];
  <span class="sf_code_syntax_comment">// 协程调用栈的大小
</span>	<span class="sf_code_syntax_project">int</span> iCallStackSize;
  <span class="sf_code_syntax_comment">// 当前线程使用的 epoll
</span>	stCoEpoll_t *pEpoll;

	<span class="sf_code_syntax_comment">// for copy stack log lastco and nextco
</span>  <span class="sf_code_syntax_comment">// 共享栈, 目前无视这个概念, 留到后面再深究
</span>	stCoRoutine_t *pending_co;
	stCoRoutine_t *occupy_co;
};
</code></pre>	目前看起来还是云里雾里, 因为这个<code class='code-inline'>stCoRoutineEnv_t</code>需要和<code class='code-inline'>co_resume</code> 和 <code class='code-inline'>co_yield_ct()</code> 结合起来理解, 先放一边吧
<hr>
<h3>0.3.3 <code class='code-inline'>co_init_curr_thread_env()</code>函数本体</h3>
	<code class='code-inline'>co_create</code>下一个函数就是<code class='code-inline'>co_init_curr_thread_env()</code>
<pre><code class='code-multiline'> <span class="sf_code_syntax_project">void</span> co_init_curr_thread_env()
{
	<span class="sf_code_syntax_comment">// 获取当前 线程/进程 id
</span>	pid_t pid = GetPid();

	<span class="sf_code_syntax_comment">// 在堆中建立 stCoRoutineEnv_t 结构体
</span>	<span class="sf_code_syntax_comment">// 将指针存入 g_arrCoEnvPerThread 相应的位置中
</span>	g_arrCoEnvPerThread[pid] = (stCoRoutineEnv_t *)calloc(<span class="sf_code_syntax_number">1</span>, <span class="sf_code_syntax_keyword">sizeof</span>(stCoRoutineEnv_t));
	stCoRoutineEnv_t *env = g_arrCoEnvPerThread[pid];

	<span class="sf_code_syntax_comment">// 初始化调用栈大小
</span>	env-&gt;iCallStackSize = <span class="sf_code_syntax_number">0</span>;

	<span class="sf_code_syntax_comment">// 创建一个self协程, self协程并没有入口函数!
</span>	<span class="sf_code_syntax_project">struct</span> stCoRoutine_t *self = co_create_env(env, <span class="sf_code_syntax_number">NULL</span>, <span class="sf_code_syntax_number">NULL</span>, <span class="sf_code_syntax_number">NULL</span>);
	<span class="sf_code_syntax_comment">// 设置self协程为当前线程的主协程
</span>	self-&gt;cIsMain = <span class="sf_code_syntax_number">1</span>;

	<span class="sf_code_syntax_comment">// 共享栈相关
</span>	env-&gt;pending_co = <span class="sf_code_syntax_number">NULL</span>;
	env-&gt;occupy_co = <span class="sf_code_syntax_number">NULL</span>;

	<span class="sf_code_syntax_comment">// 初始化self协程的上下文
</span>	coctx_init(&self-&gt;ctx);

	<span class="sf_code_syntax_comment">// 将self协程置入 pCallStack 协程调用栈的栈底
</span>	env-&gt;pCallStack[env-&gt;iCallStackSize++] = self;

	<span class="sf_code_syntax_comment">// 暂时无视epoll
</span>	stCoEpoll_t *ev = AllocEpoll();
	SetEpoll(env, ev);›
}
</code></pre>	<code class='code-inline'>co_init_curr_thread_env()</code>中有几个关键点
<ul><li>			<code class='code-inline'>stCoRoutine_t</code>结构体
</li><li>			<code class='code-inline'>self</code>主协程
</li><li>			<code class='code-inline'>pCallStack</code> 协程调用栈
</li></ul>	<code class='code-inline'>stCoRoutine_t</code>结构体 和 <code class='code-inline'>self</code>主协程延后关注, 先看看当前<code class='code-inline'>pCallStack</code>的样子
				<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%889.58.18.png'>
	<code class='code-inline'>self</code>协程被置入<code class='code-inline'>pCallStack</code>的底部
<hr>
<h3>0.3.4 <code class='code-inline'>stCoRoutine_t</code>结构体</h3>
	<code class='code-inline'>stCoRoutine_t</code>是用于描述和记录<b>一个协程</b>上下文的结构体
<pre><code class='code-multiline'><span class="sf_code_syntax_project">struct</span> stCoRoutine_t
{
	stCoRoutineEnv_t *env; 	<span class="sf_code_syntax_comment">// 记录协程所在的当前线程全局环境
</span>	pfn_co_routine_t pfn; 	<span class="sf_code_syntax_comment">// 当前协程运行的入口函数
</span>	<span class="sf_code_syntax_project">void</span> *arg;   	<span class="sf_code_syntax_comment">// 传递给入口函数的形参
</span>	coctx_t ctx; 	<span class="sf_code_syntax_comment">// 保存着当前协程的寄存器状态
</span>	<span class="sf_code_syntax_project">char</span> cStart; 	<span class="sf_code_syntax_comment">// 记录当前协程是否已经开始执行
</span>	<span class="sf_code_syntax_project">char</span> cEnd;   	<span class="sf_code_syntax_comment">// 记录当前协程是否已经结束执行
</span>	<span class="sf_code_syntax_project">char</span> cIsMain;	<span class="sf_code_syntax_comment">// 记录当前协程是否为主协程
</span>	<span class="sf_code_syntax_project">char</span> cEnableSysHook; <span class="sf_code_syntax_comment">// 记录当前协程是否开启系统API钩子
</span>	<span class="sf_code_syntax_project">char</span> cIsShareStack;  <span class="sf_code_syntax_comment">// 记录当前协程是否开启共享栈
</span>	<span class="sf_code_syntax_comment">// 系统API钩子相关, 本节无视之
</span>	<span class="sf_code_syntax_project">void</span> *pvEnv;

	stStackMem_t* stack_mem;<span class="sf_code_syntax_comment">// 记录当前协程存放栈数据的内存地址
</span>
	<span class="sf_code_syntax_comment">// 以下均为共享栈相关, 本节无视之
</span>	<span class="sf_code_syntax_project">char</span>* stack_sp; 
	<span class="sf_code_syntax_project">unsigned</span> <span class="sf_code_syntax_project">int</span> save_size;
	<span class="sf_code_syntax_project">char</span>* save_buffer;
	stCoSpec_t aSpec[<span class="sf_code_syntax_number">1024</span>];
};
</code></pre>	需要关注<code class='code-inline'>coctx_t</code>和<code class='code-inline'>stStackMem_t</code>这个结构体, 因为 恢复\保存(resume\yield) 协程的运行状态就靠他了.
<hr>
<h3>0.3.5 <code class='code-inline'>coctx_t</code> 和 <code class='code-inline'>stStackMem_t</code></h3>

	仔细观察<mark>章节0.2 简单尝试</mark>中, 在<code class='code-inline'>main</code>函数中通过<code class='code-inline'>co_resume</code>载入<code class='code-inline'>foo_co</code>, 并且调用<code class='code-inline'>foo</code>函数, 而在<code class='code-inline'>foo</code>函数中, 通过<code class='code-inline'>co_yield_ct</code>回到<code class='code-inline'>main</code>函数中, 而后在<b>再次调用</b><code class='code-inline'>foo</code>函数的时候, 又能回到上一次调用<code class='code-inline'>co_yield_ct</code>的地方, 并继续执行直到函数返回.
	在那段代码里, <code class='code-inline'>main</code>函数没有直接调用<code class='code-inline'>foo</code>, 而在<code class='code-inline'>foo</code>中也没有直接调用<code class='code-inline'>main</code>, 但是却能通过<code class='code-inline'>co_resume</code>和<code class='code-inline'>co_yield_ct</code>来回调用
	这里的魔法: <b>利用汇编, 保存被挂起协程的运行现场, 然后恢复别的协程的运行现场</b>
	运行现场, 其实更确切的说法是, 协程被挂起前 CPU寄存器 和 内存中栈 的状态.
	而<code class='code-inline'>coctx_t</code>就是记录着协程被挂起前 CPU寄存器状态 的结构了.
	至于协程被挂起前 内存中栈的状态, 当然记录在<code class='code-inline'>stack_mem</code>里
	要把 寄存器状态、内存中栈的状态 和协程运行状态的关系说清楚, 要理解<mark>处理器中的寄存器(libco里仅支持x86及amd64)</mark>还有<mark>X86调用约定</mark>, 以及<mark>操作系统如何载入程序、分配内存并运行的</mark>.
	<u>即使libco同时支持x86和amd64架构, 但是为了简化文章, 这里只探讨x86架构</u>
<hr>
<h4>0.3.5.1 x86处理器中的寄存器</h4>
	这里只关注主要用到的几个
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-14%20%E4%B8%8B%E5%8D%8811.56.26.png'>
	x86主要用到这几个寄存器
<hr>
<h4>0.3.5.2 x86调用协定</h4>
	根据维基百科上的<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl">X86调用约定</a>, 在c语言中发生函数调用时, 调用者会操作寄存器和内存, 保存函数调用前状态, 然后跳转到被调函数的地址
	这里有三个很重要的寄存器
<ul><li>			esp:  栈指针, 用于存放当前栈的位置
</li><li>			ebp: 基栈指针, 用于存放当前函数栈帧的开始位置
</li><li>			eip: 存放着下一条指令的地址, CPU会自动读取eip并载入取下一条指令
</li></ul>		
	参考维基百科上<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl">X86调用约定</a>给出的实例, 存在这样的c语言代码
<pre><code class='code-multiline'> <span class="sf_code_syntax_project">int</span> callee(<span class="sf_code_syntax_project">int</span>, <span class="sf_code_syntax_project">int</span>, <span class="sf_code_syntax_project">int</span>);
 <span class="sf_code_syntax_project">int</span> caller(<span class="sf_code_syntax_project">void</span>)
 {
     <span class="sf_code_syntax_project">register</span> <span class="sf_code_syntax_project">int</span> ret;
     
     ret = callee(<span class="sf_code_syntax_number">1</span>, <span class="sf_code_syntax_number">2</span>, <span class="sf_code_syntax_number">3</span>);
     ret += <span class="sf_code_syntax_number">5</span>;
     <span class="sf_code_syntax_keyword">return</span> ret;
 }
</code></pre>	编译后产生这样的代码,
	(0 - 9是我添加的, 用于简单标识出地址, 实际编译不会产生)
<pre><code class='code-multiline'>       .globl  caller
 caller:
0       pushl   %ebp			# 记录调用caller函数的栈帧
1       movl    %esp, %ebp   # 构造caller栈帧
2       pushl   $3           # 逆序将callee函数入栈
3       pushl   $2
4       pushl   $1
5       call    callee       # 调用callee函数
6       addl    $12,%esp     # 缩减栈大小
7       addl    $5,%eax      # 将callee返回值+ 5
8       leave					# 清理栈帧
9       ret					# 返回至调用者
</code></pre><ul><li>		<code class='code-inline'>pushl [操作数]</code>:  <code class='code-inline'>push long</code>, 将操作数中的值推入栈中, 并将栈指针增加4字节的大小.
</li><li>		<code class='code-inline'>movl [a] [b]</code>    : <code class='code-inline'>move long</code>, 将 a 中的4字节值复制到 b 中
</li><li>		<code class='code-inline'>call [函数地址]</code> :  将eip中的值推入栈中, 并跳转到函数地址
</li><li>		<code class='code-inline'>addl [a] [b]</code>    :  相当于<code class='code-inline'>b = a + b</code>
</li><li>		<code class='code-inline'>leave</code>                   : 清空当前函数调用栈帧
</li><li>		<code class='code-inline'>ret</code>                       : 从栈顶取得eip地址, 返回至该地址
</li></ul>	可视化这个函数调用
<ol start="1"><li><code class='code-inline'>call callee</code>前
</li></ol><img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.56.12.png'>
<ol start="2"><li><code class='code-inline'>call callee时</code>
</li></ol><img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.54.09.png'>
<ol start="3"><li><code class='code-inline'>call callee后 - leave前</code>
</li></ol><img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%888.52.19.png'>
	函数调用就是操纵CPU寄存器和内存栈, 有了这样的概念, 那么我们在协程切换时, 直接利用<b>汇编</b>操纵寄存器和栈就好啦.
<ol start="1"><li>保存当前协程所处寄存器状态
</li><li>恢复需要载入协程的寄存器状态
</li></ol><hr>
<h4>0.3.5.3 操作系统如何载入程序、分配内存并运行的</h4>
	寄存器的问题解决了, 但是栈的问题还没解决
	操作系统在载入程序时, 会给一个线程分配<b>一个</b>固定大小的栈, 而在libco中, 一个线程里有多个协程
	先来看看所有协程都使用操作系统分配的一个栈会怎样
	仍然利用上面的<mark>章节0.2 简单尝试</mark>中实例代码展示
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.25.52.png'>
	如果只有一个栈,  在<code class='code-inline'>co_yield_ct</code>时, <code class='code-inline'>foo_co</code>的栈帧被抹去, 可是这时<code class='code-inline'>foo_co</code>还没执行完啊, 抹去了<code class='code-inline'>foo_co</code>栈帧, 那么就没办法恢复<code class='code-inline'>foo_co</code>被挂起前状态了.
	所以, 必须要有一个地方存放协程的栈帧, 可以申请堆内存去存放协程的栈帧
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8A%E5%8D%889.37.52.png'>
	利用汇编, 将esp和ebp指向我们申请的堆内存就好了, 这样程序运行的时候从esp和ebp取得的就是堆内存中的地址
<hr>
<h3>0.3.6 <code class='code-inline'>coctx_t</code>结构体</h3>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">struct</span> coctx_t
{
<span class="sf_code_syntax_preprocessor">#</span><span class="sf_code_syntax_keyword">if</span><span class="sf_code_syntax_preprocessor"> defined(__i386__)</span>
	<span class="sf_code_syntax_project">void</span> *regs[ <span class="sf_code_syntax_number">8</span> ];
<span class="sf_code_syntax_preprocessor">#</span><span class="sf_code_syntax_keyword">else</span>
	<span class="sf_code_syntax_project">void</span> *regs[ <span class="sf_code_syntax_number">14</span> ];
#endif
  <span class="sf_code_syntax_comment">// 栈大小
</span>	size_t ss_size;
  <span class="sf_code_syntax_comment">// 栈指针
</span>	<span class="sf_code_syntax_project">char</span> *ss_sp;
};

<span class="sf_code_syntax_comment">//----- --------
// 32 bit
// | regs[0]: ret |
// | regs[1]: ebx |
// | regs[2]: ecx |
// | regs[3]: edx |
// | regs[4]: edi |
// | regs[5]: esi |
// | regs[6]: ebp |
// | regs[7]: eax |
</span></code></pre>	只关注x86架构下, <code class='code-inline'>coctx_t</code>存放了8个CPU寄存器的值, 就是<mark>0.3.5.1 x86处理器中的寄存器</mark>那张图里的8个, 堆中协程栈的大小和起始位置
<hr>
<h3>0.3.7 <code class='code-inline'>coctx_t</code>结构体的相关操作</h3>
<h4>0.3.7.1 <code class='code-inline'>coctx_init</code>函数, 初始化<code class='code-inline'>coctx_t</code>结构体</h4>
<code class='code-inline'>coctx_init</code>源码
<pre><code class='code-multiline'><span class="sf_code_syntax_project">int</span> coctx_init( coctx_t *ctx )
{
	memset( ctx,<span class="sf_code_syntax_number">0</span>,<span class="sf_code_syntax_keyword">sizeof</span>(*ctx));
	<span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">0</span>;
}
</code></pre><hr>
<h4>0.3.7.1 <code class='code-inline'>coctx_make</code>函数, 准备协程入口</h4>
<code class='code-inline'>coctx_make</code>源码
<pre><code class='code-multiline'><span class="sf_code_syntax_project">enum</span>
{
	<span class="sf_code_syntax_number">kEIP</span> = <span class="sf_code_syntax_number">0</span>,
	<span class="sf_code_syntax_number">kESP</span> = <span class="sf_code_syntax_number">7</span>,
};

<span class="sf_code_syntax_project">int</span> coctx_make(coctx_t *ctx, coctx_pfn_t pfn, <span class="sf_code_syntax_project">const</span> <span class="sf_code_syntax_project">void</span> *s, <span class="sf_code_syntax_project">const</span> <span class="sf_code_syntax_project">void</span> *s1)
{
	<span class="sf_code_syntax_comment">//make room for coctx_param
</span>	<span class="sf_code_syntax_project">char</span> *sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - <span class="sf_code_syntax_keyword">sizeof</span>(coctx_param_t);
  <span class="sf_code_syntax_comment">// 清空sp末位, (-16L == 0xfffffff0), 为了内存对齐
</span>	sp = (<span class="sf_code_syntax_project">char</span> *)((<span class="sf_code_syntax_project">unsigned</span> <span class="sf_code_syntax_project">long</span>)sp & -<span class="sf_code_syntax_number">16L</span>);

	coctx_param_t *param = (coctx_param_t *)sp;
	param-&gt;s1 = s;
	param-&gt;s2 = s1;

	memset(ctx-&gt;regs, <span class="sf_code_syntax_number">0</span>, <span class="sf_code_syntax_keyword">sizeof</span>(ctx-&gt;regs));

	<span class="sf_code_syntax_comment">// sizeof(void*)是给pfn的形参预留的位置
</span>	ctx-&gt;regs[<span class="sf_code_syntax_number">kESP</span>] = (<span class="sf_code_syntax_project">char</span> *)(sp) - <span class="sf_code_syntax_keyword">sizeof</span>(<span class="sf_code_syntax_project">void</span> *);
	ctx-&gt;regs[<span class="sf_code_syntax_number">kEIP</span>] = (<span class="sf_code_syntax_project">char</span> *)pfn;

	<span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">0</span>;
}
</code></pre>	调用<code class='code-inline'>coctx_make</code>后, 堆中协程栈和<code class='code-inline'>coctx_t</code>结构体状态
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.05.19.png'>
<hr>
<h3>0.3.8 跟踪<code class='code-inline'>co_create_env</code></h3>
<code class='code-inline'>co_create_env</code>用于申请协程结构体<code class='code-inline'>stCoRoutine_t</code>的内存及协程栈的内存
<pre><code class='code-multiline'><span class="sf_code_syntax_project">struct</span> stCoRoutine_t *co_create_env(stCoRoutineEnv_t *env, <span class="sf_code_syntax_project">const</span> stCoRoutineAttr_t *attr, pfn_co_routine_t pfn, <span class="sf_code_syntax_project">void</span> *arg)
{

	stCoRoutineAttr_t at;
	<span class="sf_code_syntax_keyword">if</span> (attr)
	{
		<span class="sf_code_syntax_comment">// 复制 stCoRoutineAttr_t 至 at 中
</span>		memcpy(&at, attr, <span class="sf_code_syntax_keyword">sizeof</span>(at));
	}
	<span class="sf_code_syntax_keyword">if</span> (at.stack_size &lt;= <span class="sf_code_syntax_number">0</span>)
	{
		at.stack_size = <span class="sf_code_syntax_number">128</span> * <span class="sf_code_syntax_number">1024</span>;
	}
	<span class="sf_code_syntax_keyword">else</span> <span class="sf_code_syntax_keyword">if</span> (at.stack_size &gt; <span class="sf_code_syntax_number">1024</span> * <span class="sf_code_syntax_number">1024</span> * <span class="sf_code_syntax_number">8</span>)
	{
		at.stack_size = <span class="sf_code_syntax_number">1024</span> * <span class="sf_code_syntax_number">1024</span> * <span class="sf_code_syntax_number">8</span>;
	}

	<span class="sf_code_syntax_keyword">if</span> (at.stack_size & 0xFFF)
	{
		at.stack_size &= ~0xFFF;
		at.stack_size += 0x1000;
	}

	stCoRoutine_t *lp = (stCoRoutine_t *) malloc( <span class="sf_code_syntax_keyword">sizeof</span>( stCoRoutine_t ));

	memset(lp, <span class="sf_code_syntax_number">0</span>, (<span class="sf_code_syntax_project">long</span>)(<span class="sf_code_syntax_keyword">sizeof</span>(stCoRoutine_t)));

	lp-&gt;env = env;
	lp-&gt;pfn = pfn;
	lp-&gt;arg = arg;

	stStackMem_t *stack_mem = <span class="sf_code_syntax_number">NULL</span>;
	<span class="sf_code_syntax_keyword">if</span> (at.share_stack)
	{
		<span class="sf_code_syntax_comment">// 共享栈, 本章不关注
</span>		stack_mem = co_get_stackmem(at.share_stack);
		at.stack_size = at.share_stack-&gt;stack_size;
	}
	<span class="sf_code_syntax_keyword">else</span>
	{
		<span class="sf_code_syntax_comment">// 为协程申请运行栈
</span>		stack_mem = co_alloc_stackmem(at.stack_size);
	}
	<span class="sf_code_syntax_comment">// 以下均为初始化协程信息
</span>	lp-&gt;stack_mem = stack_mem;

	lp-&gt;ctx.ss_sp = stack_mem-&gt;stack_buffer;
	lp-&gt;ctx.ss_size = at.stack_size;

	lp-&gt;cStart = <span class="sf_code_syntax_number">0</span>;
	lp-&gt;cEnd = <span class="sf_code_syntax_number">0</span>;
	lp-&gt;cIsMain = <span class="sf_code_syntax_number">0</span>;
	lp-&gt;cEnableSysHook = <span class="sf_code_syntax_number">0</span>;
	lp-&gt;cIsShareStack = at.share_stack != <span class="sf_code_syntax_number">NULL</span>;

	lp-&gt;save_size = <span class="sf_code_syntax_number">0</span>;
	lp-&gt;save_buffer = <span class="sf_code_syntax_number">NULL</span>;

	<span class="sf_code_syntax_keyword">return</span> lp;
}</code></pre>
<p><br></p>
<hr>
<h2>0.4 跟踪<code class='code-inline'>co_resume</code></h2>
<p>协程的栈, 存放寄存器<code class='code-inline'>coctx_t</code>结构体准备好了, 接下来是调用<code class='code-inline'>co_resume</code>载入协程了.</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">void</span> co_resume(stCoRoutine_t *co)
{
  <span class="sf_code_syntax_comment">// 获取协程全局环境
</span>	stCoRoutineEnv_t *env = co-&gt;env;
  <span class="sf_code_syntax_comment">// 获取上一个协程
</span>	stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[env-&gt;iCallStackSize - <span class="sf_code_syntax_number">1</span>];
  <span class="sf_code_syntax_comment">// 检查协程是否已经执行过
</span>	<span class="sf_code_syntax_keyword">if</span> (!co-&gt;cStart)
	{
		<span class="sf_code_syntax_comment">// 创建协程入口, coctx_make在上面讨论过
</span>		<span class="sf_code_syntax_comment">// 注意这里 CoRoutineFunc
</span>		coctx_make(&co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, <span class="sf_code_syntax_number">0</span>);
		co-&gt;cStart = <span class="sf_code_syntax_number">1</span>;
	}
  <span class="sf_code_syntax_comment">// 增加 pCallStack 协程调用栈, 并设置为 co
</span>	env-&gt;pCallStack[env-&gt;iCallStackSize++] = co;
  <span class="sf_code_syntax_comment">// 保存当前协程现场, 切换到 co 协程现场
</span>	co_swap(lpCurrRoutine, co);
}
</code></pre><hr>
<h3>0.4.1 <code class='code-inline'>CoRoutineFunc</code>协程入口函数</h3>
在<code class='code-inline'>co_resume</code>的<code class='code-inline'>coctx_make</code>中, 并没有直接将需要运行的函数直接传递给<code class='code-inline'>coctx_make</code>, 而是将另一个函数<code class='code-inline'>CoRoutineFunc</code>和<code class='code-inline'>co</code>传给它, 先看<code class='code-inline'>CoRoutineFunc</code>的源码
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// 我认为 void * 是为了兼容历史遗留的API
</span><span class="sf_code_syntax_project">static</span> <span class="sf_code_syntax_project">int</span> CoRoutineFunc(stCoRoutine_t *co, <span class="sf_code_syntax_project">void</span> *)
{
	<span class="sf_code_syntax_keyword">if</span> (co-&gt;pfn)
	{
		<span class="sf_code_syntax_comment">// 在此调用需要运行在协程中的函数
</span>		co-&gt;pfn(co-&gt;arg);
	}
	<span class="sf_code_syntax_comment">// 将协程运行完成的标识置为1
</span>	co-&gt;cEnd = <span class="sf_code_syntax_number">1</span>;

	stCoRoutineEnv_t *env = co-&gt;env;
	<span class="sf_code_syntax_comment">// 直接跳到上一个协程, co_yield_env 后面会讨论, 无需返回
</span>	co_yield_env(env);
	<span class="sf_code_syntax_comment">// return 0 不该发生, 否则引发 SIGSEGV
</span>  <span class="sf_code_syntax_comment">// 因为没有构造返回地址
</span>	<span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">0</span>;
}
</code></pre>	再看在调用<code class='code-inline'>coctx_make(&co-&gt;ctx, (coctx_pfn_t)CoRoutineFunc, co, 0);</code>后,   堆中协程栈和<code class='code-inline'>coctx_t</code>结构体状态.
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%884.17.00.png'>
<hr>
<h3>0.4.2 回到<code class='code-inline'>co_resume</code></h3>
	同样以<mark>章节0.2 简单尝试</mark>中实例代码为例, 标上行号
<pre><code class='code-multiline'><span class="sf_code_syntax_number">1</span> <span class="sf_code_syntax_project">int</span> main(<span class="sf_code_syntax_project">int</span> argc, <span class="sf_code_syntax_project">char</span> *argv[])
<span class="sf_code_syntax_number">2</span> {
<span class="sf_code_syntax_number">3</span>     stCoRoutine_t *foo_co = <span class="sf_code_syntax_number">NULL</span>;
<span class="sf_code_syntax_number">4</span>     stCoRoutine_t *bar_co = <span class="sf_code_syntax_number">NULL</span>;
<span class="sf_code_syntax_number">5</span>     <span class="sf_code_syntax_comment">// 创建foo_co协程, 并且使用foo函数作为其入口函数
</span><span class="sf_code_syntax_number">6</span>     co_create(&foo_co, <span class="sf_code_syntax_number">NULL</span>, foo, <span class="sf_code_syntax_number">0</span>);
<span class="sf_code_syntax_number">7</span>     <span class="sf_code_syntax_comment">// 创建bar_co协程, 并且使用bar函数作为其入口函数
</span><span class="sf_code_syntax_number">8</span>     co_create(&bar_co, <span class="sf_code_syntax_number">NULL</span>, bar, <span class="sf_code_syntax_number">0</span>);
<span class="sf_code_syntax_number">9</span>     <span class="sf_code_syntax_comment">// 初次载入 foo_co 协程
</span><span class="sf_code_syntax_number">10</span>    co_resume(foo_co);
<span class="sf_code_syntax_number">11</span>    <span class="sf_code_syntax_comment">// 初次载入 bar_co 协程
</span><span class="sf_code_syntax_number">12</span>    co_resume(bar_co);
<span class="sf_code_syntax_number">13</span>    <span class="sf_code_syntax_comment">// 再次载入 foo_co 协程
</span><span class="sf_code_syntax_number">14</span>    co_resume(foo_co);
<span class="sf_code_syntax_number">15</span>    <span class="sf_code_syntax_comment">// 再次载入 bar_co 协程
</span><span class="sf_code_syntax_number">16</span>    co_resume(bar_co);
<span class="sf_code_syntax_number">17</span> }
</code></pre>	在第10行初次载入<code class='code-inline'>foo_co</code>的时候, <code class='code-inline'>env-&gt;pCallStack</code>的状态,
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14.png'>
	调用<code class='code-inline'>co_resume</code>增加pCallStack栈大小之后的状态                                            <img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52.png'> 
<hr>
<h3>0.4.1 <code class='code-inline'>co_swap</code>函数, 切换协程</h3>

<code class='code-inline'>co_swap</code>是一个用汇编实现的方法
	它的签名
<pre><code class='code-multiline'><span class="sf_code_syntax_project">extern</span> <span class="sf_code_syntax_project">void</span> coctx_swap(coctx_t *, coctx_t *) <span class="sf_code_syntax_project">asm</span>(<span class="sf_code_syntax_string">"coctx_swap"</span>)
</code></pre>	它的实现
<pre><code class='code-multiline'>	leal 4(%esp), %eax //sp 
	movl 4(%esp), %esp 
	leal 32(%esp), %esp //parm a : &regs[7] + sizeof(void*)

	pushl %eax //esp -&gt;parm a 

	pushl %ebp
	pushl %esi
	pushl %edi
	pushl %edx
	pushl %ecx
	pushl %ebx
	pushl -4(%eax)

	
	movl 4(%eax), %esp //parm b -&gt; &regs[0]

	popl %eax  //ret func addr
	popl %ebx  
	popl %ecx
	popl %edx
	popl %edi
	popl %esi
	popl %ebp

	popl %esp
	pushl %eax //set ret func addr

	xorl %eax, %eax
	ret
</code></pre>	对于<mark>章节0.2 简单尝试</mark>中初次<code class='code-inline'>co_resume(foo_co)</code>中的<code class='code-inline'>co_swap</code>来说, 可视化后的图
<ol start="1"><li>保存<code class='code-inline'>self</code>现场
</li></ol><img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.23.57.png'>
<ol start="2"><li>恢复<code class='code-inline'>foo_co</code>现场
</li></ol><img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%885.13.05.png'>
<ol start="3"><li>CPU会自动从eip寄存器去下一条指令地址, 即此时载入<code class='code-inline'>CoRoutineFunc</code>函数, 而<code class='code-inline'>CoRoutineFunc</code>载入的协程<code class='code-inline'>co</code>中记录的<code class='code-inline'>foo</code>函数
</li></ol><hr>
<h2>跟踪<code class='code-inline'>co_yield_ct</code></h2>
创建、载入协程都说完了, 然后就是挂起协程的<code class='code-inline'>co_yield_ct</code>了吧
	源码
<pre><code class='code-multiline'><span class="sf_code_syntax_project">void</span> co_yield_env(stCoRoutineEnv_t *env)
{
	<span class="sf_code_syntax_comment">// pCallStack 调用栈中, 调用co_resume(当前协程)的协程
</span>	stCoRoutine_t *last = \
		env-&gt;pCallStack[env-&gt;iCallStackSize - <span class="sf_code_syntax_number">2</span>];
	<span class="sf_code_syntax_comment">// 栈顶部的协程, 也就是当前协程
</span>	stCoRoutine_t *curr = \
		env-&gt;pCallStack[env-&gt;iCallStackSize - <span class="sf_code_syntax_number">1</span>];
	<span class="sf_code_syntax_comment">// 栈大小减1, 栈顶元素出栈
</span>	env-&gt;iCallStackSize--;
	<span class="sf_code_syntax_comment">// 切换至 上一个协程
</span>	co_swap(curr, last);
}

<span class="sf_code_syntax_project">void</span> co_yield_ct()
{
	co_yield_env(co_get_curr_thread_env());
}
</code></pre>同样以<mark>章节0.2 简单尝试</mark>中实例代码为例
<pre><code class='code-multiline'><span class="sf_code_syntax_project">void</span> *foo(<span class="sf_code_syntax_project">void</span> *args)
{
    printf(<span class="sf_code_syntax_string">"[foo] Before Yield ①</span><span class="sf_code_syntax_number">\n</span><span class="sf_code_syntax_string">"</span>);
    co_yield_ct();
    printf(<span class="sf_code_syntax_string">"[foo] After  Yield ②</span><span class="sf_code_syntax_number">\n</span><span class="sf_code_syntax_string">"</span>);
    <span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_number">NULL</span>;
}
</code></pre>	<code class='code-inline'>foo</code>函数在调用<code class='code-inline'>co_yield_ct</code>前, pCallStack的状态
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.16.52%201.png'>

	在调用<code class='code-inline'>co_yield_ct</code>后, pCallStack的状态
<img src='libco%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20%C2%B7%20%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-15%20%E4%B8%8B%E5%8D%8812.18.14%201.png'>
	然后调用<code class='code-inline'>co_swap</code>回到<code class='code-inline'>self</code>协程中保存的现场, 继续执行.
<hr>
<h2>未解问题</h2>
本章只探讨了libco中协程的基本操作, libco还有更多特性
<ul><li>		协程共享栈
</li><li>		co_eventloop
</li><li>		系统钩子
</li></ul>之后再探讨
        </div>
        <script type="text/javascript">
            (function() {

    var doc_ols = document.getElementsByTagName("ol");

    for ( i=0; i<doc_ols.length; i++) {

        var ol_start = doc_ols[i].getAttribute("start") - 1;
        doc_ols[i].setAttribute("style", "counter-reset:ol " + ol_start + ";");

    }

})();
        </script>
        <style>
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline}html{line-height:1}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}caption,th,td{text-align:left;font-weight:normal;vertical-align:middle}q,blockquote{quotes:none}q:before,q:after,blockquote:before,blockquote:after{content:"";content:none}a img{border:none}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:87.5%;line-height:1.57143em}html{font-size:14px;line-height:1.6em;-webkit-text-size-adjust:100%}body{background:#fcfcfc;color:#545454;text-rendering:optimizeLegibility;font-family:"AvenirNext-Regular"}a{color:#de4c4f;text-decoration:none}h1{font-family:"AvenirNext-Medium";color:#333;font-size:1.6em;line-height:1.3em;margin-bottom:.78571em}h2{font-family:"AvenirNext-Medium";color:#333;font-size:1.3em;line-height:1em;margin-bottom:.62857em}h3{font-family:"AvenirNext-Medium";color:#333;font-size:1.15em;line-height:1em;margin-bottom:.47143em}p{margin-bottom:1.57143em;hyphens:auto}hr{height:1px;border:0;background-color:#dedede;margin:-1px auto 1.57143em auto}ul,ol{margin-bottom:1.57143em}ul ul,ul ol,ol ul,ol ol{margin-bottom:0px}ol li:before{content:counter(ol) ".";counter-increment:ol;color:#e06e73;text-align:right;display:inline-block;min-width:1em;margin-right:0.5em}b,strong{font-family:"AvenirNext-Bold"}i,em{font-family:"AvenirNext-Italic"}code{font-family:"Menlo-Regular"}.text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sf_code_syntax_string{color:#D33905}.sf_code_syntax_comment{color:#838383}.sf_code_syntax_documentation_comment{color:#128901}.sf_code_syntax_number{color:#0E73A2}.sf_code_syntax_project{color:#5B2599}.sf_code_syntax_keyword{color:#0E73A2}.sf_code_syntax_character{color:#1B00CE}.sf_code_syntax_preprocessor{color:#920448}.note-wrapper{max-width:46em;margin:0px auto;padding:1.57143em 3.14286em}.note-wrapper.spotlight-preview{overflow-x:hidden}u{text-decoration:none;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#e06e73 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}s{color:#878787}p{margin-bottom:0.1em}hr{margin-bottom:0.7em;margin-top:0.7em}ul li{text-indent:-0.6em}ul li:before{content:"•";color:#e06e73;display:inline-block;margin-right:0.3em}ul ul{margin-left:1.25714em}ol li{text-indent:-1.55em}ol ol{margin-left:1.25714em}blockquote{display:block;margin-left:-1em;padding-left:0.8em;border-left:0.2em solid #e06e73}.todo-list ul{margin-left:1.88571em}.todo-list li{text-indent:-1.75em}.todo-list li:before{content:"";display:static;margin-right:0px}.todo-checkbox{text-indent:-1.7em}.todo-checkbox svg{margin-right:0.3em;position:relative;top:0.2em}.todo-checkbox svg #check{display:none}.todo-checkbox.todo-checked #check{display:inline}.todo-checkbox.todo-checked .todo-text{text-decoration:line-through;color:#878787}.code-inline{display:inline-block;background:white;border:solid 1px #dedede;padding:0.0em 0.5em;font-size:0.9em}.code-multiline{display:block;background:white;border:solid 1px #dedede;padding:0.7em 1em;font-size:0.9em;overflow-x:auto}.hashtag{display:inline-block;color:white;background:#b8bfc2;padding:0.0em 0.5em;border-radius:1em;text-indent:0}.hashtag a{color:#fff}.address a{color:#545454;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#0da35e 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}.address svg{position:relative;top:0.2em;display:inline-block;margin-right:0.2em}.color-preview{display:inline-block;width:1em;height:1em;border:solid 1px rgba(0,0,0,0.3);border-radius:50%;margin-right:0.1em;position:relative;top:0.2em;white-space:nowrap}.color-code{margin-right:0.2em;font-family:"Menlo-Regular";font-size:0.9em}.color-hash{opacity:0.4}.ordered-list-number{color:#e06e73;text-align:right;display:inline-block;min-width:1em}.arrow svg{position:relative;top:0.08em;display:inline-block;margin-right:0.15em;margin-left:0.15em}.arrow svg #rod{stroke:#545454}.arrow svg #point{fill:#545454}mark{color:inherit;display:inline-block;padding:0px 4px;background-color:#fcffc0}img{max-width:100%;height:auto}

        </style>
    </body>
</html>
